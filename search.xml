<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ActiveMQ学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ActiveMQ.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ActiveMQ.html</url>
      
        <content type="html"><![CDATA[<p>ActiveMQ</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Elasticsearch.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Elasticsearch.html</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JDBC.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JDBC.html</url>
      
        <content type="html"><![CDATA[<p>JDBC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM.html</url>
      
        <content type="html"><![CDATA[<p>JVM</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaSE.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaSE.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章Java基本语法"><a href="#第一章Java基本语法" class="headerlink" title="第一章Java基本语法"></a>第一章Java基本语法</h1><h2 id="1-1关键字与标识符"><a href="#1-1关键字与标识符" class="headerlink" title="1.1关键字与标识符"></a>1.1关键字与标识符</h2><h3 id="1-1-1java关键字的使用"><a href="#1-1-1java关键字的使用" class="headerlink" title="1.1.1java关键字的使用"></a>1.1.1java关键字的使用</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p>特点：关键字中所字母都为小写</p><p>具体哪些关键字：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161343448.png" alt="image-20230211161343448"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161347035.png*" alt="image-20230211161347035">*</p><h3 id="1-1-2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"><a href="#1-1-2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。" class="headerlink" title="1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"></a>1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。</h3><p>具体哪些保留字：goto 、const</p><p>注意：自己命名标识符时要避免使用这些保留字</p><h3 id="1-1-3-标识符的使用"><a href="#1-1-3-标识符的使用" class="headerlink" title="1.1.3.标识符的使用"></a>1.1.3.标识符的使用</h3><p>定义：凡是自己可以起名字的地方都叫标识符。</p><p>涉及到的结构：</p><p>包名、类名、接口名、变量名、方法名、常量名</p><p>规则：(必须要遵守。否则，编译不通过)</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161451423.png" alt="image-20230211161451423"></p><p>规范：（可以不遵守，不影响编译和运行。但是要求遵守）</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161457024.png" alt="image-20230211161457024"></p><p>注意点：</p><p>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p><h2 id="1-2变量的使用"><a href="#1-2变量的使用" class="headerlink" title="1.2变量的使用"></a>1.2变量的使用</h2><h3 id="1-2-1变量的分类"><a href="#1-2-1变量的分类" class="headerlink" title="1.2.1变量的分类"></a>1.2.1变量的分类</h3><p>按数据类型分类</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161545642.png" alt="image-20230211161545642"></p><h3 id="1-2-2定义变量的格式"><a href="#1-2-2定义变量的格式" class="headerlink" title="1.2.2定义变量的格式"></a>1.2.2定义变量的格式</h3><p>数据类型 变量名 &#x3D; 变量值;</p><p>或</p><p>数据类型 变量名;</p><p>变量名 &#x3D; 变量值;</p><h3 id="1-2-3变量使用的注意点"><a href="#1-2-3变量使用的注意点" class="headerlink" title="1.2.3变量使用的注意点"></a>1.2.3变量使用的注意点</h3><p>① 变量必须先声明，后使用</p><p>② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</p><p>③ 同一个作用域内，不可以声明两个同名的变量</p><h3 id="1-2-4基本数据类型变量间运算规则"><a href="#1-2-4基本数据类型变量间运算规则" class="headerlink" title="1.2.4基本数据类型变量间运算规则"></a>1.2.4基本数据类型变量间运算规则</h3><ul><li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p></li><li><p>自动类型转换(只涉及7种基本数据类型）</p></li></ul><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double</p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p><ul><li>强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。</li></ul><ol><li>需要使用强转符：()</li><li>注意点：强制类型转换，可能导致精度损失。</li></ol><ul><li>String与8种基本数据类型间的运算</li></ul><ol><li>String属于引用数据类型,翻译为：字符串</li><li>声明String类型变量时，使用一对””</li><li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li><li>运算的结果仍然是String类型</li></ol><p>避免：</p><p>String s &#x3D; 123;&#x2F;&#x2F;编译错误</p><p>String s1 &#x3D; “123”;</p><p>int i &#x3D; (int)s1;&#x2F;&#x2F;编译错误</p><h2 id="1-3进制"><a href="#1-3进制" class="headerlink" title="1.3进制"></a>1.3进制</h2><h3 id="1-3-1编程中涉及的进制及表示方式："><a href="#1-3-1编程中涉及的进制及表示方式：" class="headerlink" title="1.3.1编程中涉及的进制及表示方式："></a>1.3.1编程中涉及的进制及表示方式：</h3><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162011508.png" alt="image-20230211162011508"></p><h3 id="1-3-2二进制的使用说明："><a href="#1-3-2二进制的使用说明：" class="headerlink" title="1.3.2二进制的使用说明："></a>1.3.2二进制的使用说明：</h3><ul><li>计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。</li><li>二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。</li><li>原码、反码、补码的说明：</li></ul><p>正数：三码合一</p><p>负数：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162056385.png" alt="image-20230211162056385"></p><h3 id="1-3-3进制间的互相转换"><a href="#1-3-3进制间的互相转换" class="headerlink" title="1.3.3进制间的互相转换"></a>1.3.3进制间的互相转换</h3><ul><li><p>图示：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162207149.png" alt="image-20230211162207149"></p></li><li><p>图示二进制转换为十进制：</p></li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162235888.png" alt="image-20230211162235888"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162240553.png" alt="image-20230211162240553"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162248195.png" alt="image-20230211162248195"></p><ul><li>图示十进制转换为二进制：</li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162310209.png" alt="image-20230211162310209"></p><ul><li>二进制与八进制、十六进制间的转换</li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162324210.png" alt="image-20230211162324210"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162329667.png" alt="image-20230211162329667"></p><h2 id="1-4运算符"><a href="#1-4运算符" class="headerlink" title="1.4运算符"></a>1.4运算符</h2><h3 id="1-4-1算术运算符"><a href="#1-4-1算术运算符" class="headerlink" title="1.4.1算术运算符"></a>1.4.1算术运算符</h3><p>算术运算符： + - + - * &#x2F; % (前)++ (后)++ (前)– (后)– +</p><p>除号：&#x2F;</p><p>%:取余运算</p><p>(前)++ :先自增1，后运算</p><p>(后)++ :先运算，后自增1</p><p>(前)– :先自减1，后运算</p><p>(后)– :先运算，后自减1</p><p>连接符：+：只能使用在String与其他数据类型变量之间使用。</p><h3 id="1-4-2赋值运算符"><a href="#1-4-2赋值运算符" class="headerlink" title="1.4.2赋值运算符"></a>1.4.2赋值运算符</h3><p>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</p><h3 id="1-4-3比较运算符"><a href="#1-4-3比较运算符" class="headerlink" title="1.4.3比较运算符"></a>1.4.3比较运算符</h3><p>比较运算符（关系运算符）: &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; instanceof</p><p>比较运算符的结果是boolean类型</p><p>&lt; &gt; &gt;&#x3D; &lt;&#x3D; :只能使用在数值类型的数据之间。</p><p>&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p><h3 id="1-4-4逻辑运算符"><a href="#1-4-4逻辑运算符" class="headerlink" title="1.4.4逻辑运算符"></a>1.4.4逻辑运算符</h3><p>&amp; &amp;&amp; | || ! ^</p><p>区分&amp; 与 &amp;&amp;</p><p>相同点1：&amp; 与 &amp;&amp; 的运算结果相同</p><p>相同点2：当符号左边是true时，二者都会执行符号右边的运算</p><p>不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</p><p>区分：| 与 ||</p><p>相同点1：| 与 || 的运算结果相同</p><p>相同点2：当符号左边是false时，二者都会执行符号右边的运算</p><p>不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</p><p>逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型</p><h3 id="1-4-5位运算符"><a href="#1-4-5位运算符" class="headerlink" title="1.4.5位运算符"></a>1.4.5位运算符</h3><p>&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~</p><p>一个&amp;时，参加运算的两个数据，按二进制位进行“与”运算。运算规则：同1为一，其余为0。</p><p>一个 | 时，参加运算的两个对象，按二进制位进行“或”运算。运算规则：同0为0，有1为1。另外，负数按补码形式参加按位或运算。</p><p><strong>位异或（^）：</strong></p><p>参与运算的两个数据，按二进制位进行“异或”运算。运算规则：相同为0，不同为1。</p><p><strong>非位（~）：</strong></p><p>按位取反操作会翻转其每一位。运算规则：0变为1，1变为0。</p><p><strong>左移（&lt;&lt;）：</strong></p><p>符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：高位丢弃，低位补0。</p><p><strong>右移（&gt;&gt;）：</strong></p><p>符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：正数左补0，负数左补1.</p><p><strong>无符号右移（&gt;&gt;&gt;）：</strong></p><p>即右移之后，无论该数为正还是为负，右移之后左补0。</p><h3 id="1-4-6三元运算符"><a href="#1-4-6三元运算符" class="headerlink" title="1.4.6三元运算符"></a>1.4.6三元运算符</h3><p>(条件表达式)? 表达式1 : 表达式2</p><ul><li>说明</li></ul><p>① 条件表达式的结果为boolean类型</p><p>② 根据条件表达式真或假，决定执行表达式1，还是表达式2.</p><p>如果表达式为true，则执行表达式1。</p><p>如果表达式为false，则执行表达式2。</p><ul><li><p>凡是可以使用三元运算符的地方，都可以改写为if-else</p></li><li><p>如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p></li></ul><h2 id="1-5流程控制"><a href="#1-5流程控制" class="headerlink" title="1.5流程控制"></a>1.5流程控制</h2><h3 id="1-5-1分支结构"><a href="#1-5-1分支结构" class="headerlink" title="1.5.1分支结构"></a>1.5.1分支结构</h3><p><strong>if-else条件判断结构</strong></p><p>结构一：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if(条件表达式)&#123;执行表达式&#125;</code></pre><p>结构二：二选一</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if(条件表达式)&#123;执行表达式1&#125;else&#123;执行表达式2&#125;</code></pre><p>结构三：n选一</p><pre class="line-numbers language-none"><code class="language-none">if(条件表达式)&#123;执行表达式1&#125;else if(条件表达式)&#123;执行表达式2&#125;else if(条件表达式)&#123;执行表达式3&#125;...else&#123;执行表达式n&#125;</code></pre><p><strong>说明：</strong></p><ul><li><p>else 结构是可选的。</p></li><li><p>针对于条件表达式：</p><p>&gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</p><p>&gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</p><p>&gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了</p></li><li><p>if-else结构是可以相互嵌套的。</p></li><li><p>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p></li></ul><p>switch-case<strong>选择结构</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch(表达式)&#123;case 常量1:执行语句1;&#x2F;&#x2F;break;case 常量2:执行语句2;&#x2F;&#x2F;break;...default:执行语句n;&#x2F;&#x2F;break;&#125;</code></pre><p><strong>说明：</strong></p><p>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。</p><p>当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</p><p>② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</p><p>③ switch结构中的表达式，只能是如下的6种数据类型之一：</p><p>byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</p><p>④ case 之后只能声明常量。不能声明范围。</p><p>⑤ break关键字是可选的。</p><p>⑥ default:相当于if-else结构中的else.</p><p>default结构是可选的，而且位置是灵活的。</p><ul><li><p>如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。</p></li><li><p>break在switch-case中是可选的</p></li></ul><h3 id="1-5-2循环结构"><a href="#1-5-2循环结构" class="headerlink" title="1.5.2循环结构"></a>1.5.2循环结构</h3><p><strong>1.循环结构的四要素</strong></p><p>① 初始化条件</p><p>② 循环条件 —&gt;是boolean类型</p><p>③ 循环体</p><p>④ 迭代条件</p><p>说明：通常情况下，循环结束都是因为②中循环条件返回false了。</p><p><strong>2.循环的三种结构</strong></p><p>2.1 for循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(①;②;④)&#123;③&#125;</code></pre><p>执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><p>2.2 while循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">①while(②)&#123;③;④;&#125;</code></pre><p>执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><p>说明：</p><p>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p><p>for和while循环总结：</p><ul><li>开发中，基本上我们都会从for、while中进行选择，实现循环结构。</li><li>for循环和while循环是可以相互转换的！</li><li>区别：for循环和while循环的初始化条件部分的作用范围不同。</li><li>我们写程序，要避免出现死循环。</li></ul><p>2.3 do-while循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">①do&#123;③;④;&#125;while(②);</code></pre><p>执行过程：① - ③ - ④ - ② - ③ - ④ - … - ②</p><p>说明：</p><ul><li>do-while循环至少会执行一次循环体！</li><li>开发中，使用for和while更多一些。较少使用do-while</li></ul><p><strong>3.“无限循环”结构: while(true) 或 for(;;)</strong></p><p>总结：如何结束一个循环结构？</p><p>方式一：当循环条件是false时</p><p>方式二：在循环体中，执行break</p><p><strong>4.嵌套循环</strong></p><p>1.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</p><p>内层循环：循环结构A</p><p>外层循环：循环结构B</p><p>2.说明：</p><p>① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p><p>② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</p><p>③ 外层循环控制行数，内层循环控制列数</p><p>补充:衡量一个功能代码的优劣：</p><p>1.正确性</p><p>2.可读性</p><p>3.健壮性</p><p>4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</p><h3 id="1-5-3break和continue"><a href="#1-5-3break和continue" class="headerlink" title="1.5.3break和continue"></a>1.5.3break和continue</h3><p>1.break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。</p><p>注意：<br>（1）只能在循环体内和switch语句体内使用break。<br>（2）不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。<br>（3）当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。</p><p>2.continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。</p><p>注意：<br>（1）continue语句并没有使整个循环终止。<br>（2）continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。</p><h1 id="第二章数组"><a href="#第二章数组" class="headerlink" title="第二章数组"></a>第二章数组</h1><h2 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h2><p>1.一维数组的声明与初始化</p><p>正确的方式：</p><pre class="line-numbers language-none"><code class="language-none">int num;&#x2F;&#x2F;声明num &#x3D; 10;&#x2F;&#x2F;初始化int id &#x3D; 1001;&#x2F;&#x2F;声明 + 初始化</code></pre><p>int[] ids;&#x2F;&#x2F;声明</p><pre class="line-numbers language-none"><code class="language-none">1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行ids &#x3D; new int[]&#123;1001,1002,1003,1004&#125;;1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行String[] names &#x3D; new String[5];</code></pre><p>2.一维数组元素的引用：通过角标的方式调用。</p><p>&#x2F;&#x2F;数组的角标（或索引从0开始的，到数组的长度-1结束。</p><pre class="line-numbers language-none"><code class="language-none">names[0] &#x3D; &quot;王铭&quot;;names[1] &#x3D; &quot;王赫&quot;;names[2] &#x3D; &quot;张学良&quot;;names[3] &#x3D; &quot;孙居龙&quot;;names[4] &#x3D; &quot;王宏志&quot;;&#x2F;&#x2F;charAt(0)</code></pre><p>3.数组的属性：length</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(names.length);&#x2F;&#x2F;5System.out.println(ids.length);</code></pre><p>说明：</p><p>数组一旦初始化，其长度就是确定的。arr.length</p><p>数组长度一旦确定，就不可修改。</p><p>4.一维数组的遍历</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int i &#x3D; 0;i &lt; names.length;i++)&#123;System.out.println(names[i]);&#125;</code></pre><p>5.一维数组元素的默认初始化值</p><p>数组元素是整型：0</p><p>数组元素是浮点型：0.0</p><p>数组元素是char型：0或’\u0000’，而非’0’</p><p>数组元素是boolean型：false</p><h2 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h2><p>1.如何理解二维数组？</p><ul><li>数组属于引用数据类型</li><li>数组的元素也可以是引用数据类型</li><li>一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</li></ul><p>2.二维数组的声明与初始化</p><p>正确的方式：</p><pre class="line-numbers language-none"><code class="language-none">int[] arr &#x3D; new int[]&#123;1,2,3&#125;;&#x2F;&#x2F;一维数组&#x2F;&#x2F;静态初始化 二维数组int[][] arr1 &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;动态初始化1String[][] arr2 &#x3D; new String[3][2];&#x2F;&#x2F;动态初始化2String[][] arr3 &#x3D; new String[3][];&#x2F;&#x2F;也是正确的写法：int[] arr4[] &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;int[] arr5[] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;类型推断</code></pre><p>3.如何调用二维数组元素:</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr1[0][1]);&#x2F;&#x2F;2System.out.println(arr2[1][1]);&#x2F;&#x2F;null</code></pre><p>4.二维数组的属性：</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr4.length);&#x2F;&#x2F;3System.out.println(arr4[0].length);&#x2F;&#x2F;3System.out.println(arr4[1].length);&#x2F;&#x2F;4</code></pre><p>5.遍历二维数组元素</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(int i &#x3D; 0;i &lt; arr4.length;i++)&#123;for(int j &#x3D; 0;j &lt; arr4[i].length;j++)&#123;System.out.print(arr4[i][j] + &quot; &quot;);&#125;System.out.println();&#125;</code></pre><p>6.二维数组元素的默认初始化值</p><p>规定：二维数组分为外层数组的元素，内层数组的元素</p><p>int[][] arr &#x3D; new int[4][3];</p><p>外层元素：arr[0],arr[1]等</p><p>内层元素：arr[0][0],arr[1][2]等</p><h2 id="2-3数组常见算法"><a href="#2-3数组常见算法" class="headerlink" title="2.3数组常见算法"></a>2.3数组常见算法</h2><p>1.数组的创建与元素赋值：</p><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p><p>2.针对于数值型的数组：</p><p>最大值、最小值、总和、平均数等</p><p>3.数组的赋值与复制</p><p>int[] array1,array2;</p><p>array1 &#x3D; new int[]{1,2,3,4};</p><p>3.1 赋值：</p><p>array2 &#x3D; array1;</p><p>如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p>3.2 复制：</p><pre class="line-numbers language-none"><code class="language-none">array2 &#x3D; new int[array1.length];for(int i &#x3D; 0;i &lt; array2.length;i++)&#123;array2[i] &#x3D; array1[i];&#125;</code></pre><p>如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p><p>4.数组元素的反转</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;方法一：for(int i &#x3D; 0;i &lt; arr.length &#x2F; 2;i++)&#123;String temp &#x3D; arr[i];arr[i] &#x3D; arr[arr.length - i -1];arr[arr.length - i -1] &#x3D; temp;&#125;</code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;方法二：for(int i &#x3D; 0,j &#x3D; arr.length - 1;i &lt; j;i++,j--)&#123;String temp &#x3D; arr[i];arr[i] &#x3D; arr[j];arr[j] &#x3D; temp;&#125; </code></pre><p>5.数组中指定元素的查找：搜索、检索</p><p>5.1 线性查找：</p><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p><p>适用性：具有普遍适用性。</p><p>5.2 二分法查找：</p><p>实现思路：每次比较中间值，折半的方式检索。</p><p>适用性：（前提：数组必须有序）</p><p>6.数组的排序算法</p><p>理解：</p><p>1）衡量排序算法的优劣：</p><p>时间复杂度、空间复杂度、稳定性</p><p>2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p><p>3）不同排序算法的时间复杂度</p><p>4）手写冒泡排序</p><p>int[] arr &#x3D; new int[]{43,32,76,-98,0,64,33,-21,32,99};</p><p>&#x2F;&#x2F;冒泡排序</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(int i &#x3D; 0;i &lt; arr.length - 1;i++)&#123;for(int j &#x3D; 0;j &lt; arr.length - 1 - i;j++)&#123;if(arr[j] &gt; arr[j + 1])&#123;int temp &#x3D; arr[j];arr[j] &#x3D; arr[j + 1];arr[j + 1] &#x3D; temp;&#125;&#125;&#125;        </code></pre><h2 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h2><p>1.理解：</p><p>① 定义在java.util包下。</p><p>② Arrays:提供了很多操作数组的方法。</p><p>2.使用：</p><p>&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</p><pre class="line-numbers language-none"><code class="language-none">int[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;int[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;boolean isEquals &#x3D; Arrays.equals(arr1, arr2);System.out.println(isEquals);</code></pre><p>&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(Arrays.toString(arr1));</code></pre><p>&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。</p><pre class="line-numbers language-none"><code class="language-none">Arrays.fill(arr1,10);System.out.println(Arrays.toString(arr1));</code></pre><p>&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。</p><pre class="line-numbers language-none"><code class="language-none">Arrays.sort(arr2);System.out.println(Arrays.toString(arr2));</code></pre><p>&#x2F;&#x2F;5.int binarySearch(int[] a,int key)</p><pre class="line-numbers language-none"><code class="language-none">int[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int index &#x3D; Arrays.binarySearch(arr3, 210);if(index &gt;&#x3D; 0)&#123;System.out.println(index);&#125;else&#123;System.out.println(&quot;未找到&quot;);&#125;</code></pre><h2 id="2-5数组的常见异常"><a href="#2-5数组的常见异常" class="headerlink" title="2.5数组的常见异常"></a>2.5数组的常见异常</h2><p>1.数组角标越界异常：ArrayIndexOutOfBoundsException</p><p>int[] arr &#x3D; new int[]{1,2,3,4,5};</p><pre class="line-numbers language-none"><code class="language-none">for(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;System.out.println(arr[i]);&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr[-2]);System.out.println(&quot;hello&quot;);</code></pre><p>2.空指针异常：NullPointerException</p><p>&#x2F;&#x2F;情况一：</p><pre class="line-numbers language-none"><code class="language-none">int[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;arr1 &#x3D; null;System.out.println(arr1[0]);</code></pre><p>&#x2F;&#x2F;情况二：</p><pre class="line-numbers language-none"><code class="language-none">int[][] arr2 &#x3D; new int[4][];System.out.println(arr2[0][0]);</code></pre><p>&#x2F;&#x2F;情况三：</p><pre class="line-numbers language-none"><code class="language-none">String[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;arr3[0] &#x3D; null;System.out.println(arr3[0].toString());</code></pre><p>小知识：一旦程序出现异常，未处理时，就终止执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高频面试题总结</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-抽象类与接口的区别"><a href="#1-抽象类与接口的区别" class="headerlink" title="1.抽象类与接口的区别"></a>1.抽象类与接口的区别</h1><ul><li>接口中除了static、final变量以外不能有其他变量，而抽象类不一定</li><li>一个类可以实现多个接口但是实现一个抽象类，接口本身可以通过extends关键字扩展多个接口</li><li>接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供实现，抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法</li><li>接口中不能有构造器，抽象类中可以(用于子类调用完成抽象类的初始化操作)</li></ul><h1 id="2-final、static、synchronized"><a href="#2-final、static、synchronized" class="headerlink" title="2.final、static、synchronized"></a>2.final、static、synchronized</h1><p>final：</p><ul><li>被final修饰的类不能被继承</li><li>被final修饰的方法不可用被重写</li><li>被final修饰的变量不可用被改变，如果修饰引用表示引用不可变，引用指向的内容可变</li><li>被final修饰的方法，jvm会尝试将其内联，以提高运行效率</li><li>被final修饰的常量，在编译阶段会存入常量池</li></ul><p>static：</p><ul><li>被static修饰的变量&#x2F;方法都属于类的静态资源，由类的实例所共享</li></ul><p>synchronized（同步锁）：</p><p>被sychronized修饰的代码块或方法只会有一个线程执行，已到达保证并发安全的效果</p><ul><li>修饰实例方法：作用于当前实例加锁</li><li>修饰静态方法：作用于当前类对象加锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁</li></ul><h1 id="3-String、StringBuilder、StringBuffer区别"><a href="#3-String、StringBuilder、StringBuffer区别" class="headerlink" title="3.String、StringBuilder、StringBuffer区别"></a>3.String、StringBuilder、StringBuffer区别</h1><p>String类中使用final关键字修饰字符数组来保存字符串，所以String是不可变的</p><p>StringBuilder和StringBuffer都是继承自AbstractStringBuilder 类，底层字符数组没有使用final修饰，所以可变</p><p>StringBuffer中对方法加了同步锁，所以线程安全，而StringBuilder则没有</p><p>总结：</p><p>操作少量数据时使用String</p><p>单线程操作字符串缓冲区下操作大量数据时使用StringBuilder</p><p>多线程操作字符串缓冲区下操作大量数据时使用StringBuffer</p><h1 id="4-equals与-x3D-x3D-的区别和使用场景"><a href="#4-equals与-x3D-x3D-的区别和使用场景" class="headerlink" title="4.equals与&#x3D;&#x3D;的区别和使用场景"></a>4.equals与&#x3D;&#x3D;的区别和使用场景</h1><p>如果是基本数据类型 &#x3D;&#x3D; 就是比较的值，引用数据类型&#x3D;&#x3D;比较的是内存地址</p><p>equals没有被重写时，比较的是内存地址，被重写则是比较值</p><h1 id="5-深拷贝和浅拷贝"><a href="#5-深拷贝和浅拷贝" class="headerlink" title="5.深拷贝和浅拷贝"></a>5.深拷贝和浅拷贝</h1><p><strong>浅拷贝</strong> ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块</p><p><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象</p><h1 id="6-Error和Exception"><a href="#6-Error和Exception" class="headerlink" title="6.Error和Exception"></a>6.Error和Exception</h1><ul><li>Exception 和 Error体现了java平台设计者对不同异常情况的分类, Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理.</li><li>Error 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获, 常见的OutOfMemoryError 是Error的子类.</li></ul><h1 id="7-反射的机制和应用场景"><a href="#7-反射的机制和应用场景" class="headerlink" title="7.反射的机制和应用场景"></a>7.反射的机制和应用场景</h1><p><strong>反射</strong>：动态获取信息或动态调用对象方法的机制，对于任何一个类都能知道他的所有属性和方法，对于任何对象，都可以获取对象的方法</p><p><strong>应用场景</strong>：</p><ul><li>通过配置信息调用类的方法</li><li>结合注解实现特殊功能</li><li>按需加载jar包或class</li></ul><h1 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h1><pre class="line-numbers language-none"><code class="language-none">谈谈List,Set,Map的区别？谈谈ArrayList和LinkedList的区别？请说一下HashMap与HashTable的区别谈一谈ArrayList的扩容机制？HashMap 的实现原理？请简述 LinkedHashMap 的工作原理和使用方式？谈谈对于ConcurrentHashMap的理解?</code></pre><pre class="line-numbers language-none"><code class="language-none">Java 中使用多线程的方式有哪些？说一下线程的几种状态？如何实现多线程中的同步？谈谈线程死锁，如何有效的避免线程死锁？谈谈线程阻塞的原因？请谈谈 Thread 中 run() 与 start()的区别？synchronized和volatile关键字的区别？如何保证线程安全？谈谈ThreadLocal用法和原理？Java 线程中notify 和 notifyAll有什么区别？synchronized和volatile关键字的区别？</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaWeb.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaWeb.html</url>
      
        <content type="html"><![CDATA[<p>JavaWeb</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux.html</url>
      
        <content type="html"><![CDATA[<p>Linux</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Maven.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Maven.html</url>
      
        <content type="html"><![CDATA[<p>Maven</p>]]></content>
      
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL.html</url>
      
        <content type="html"><![CDATA[<p>MySQL</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatisPlus.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatisPlus.html</url>
      
        <content type="html"><![CDATA[<p>MyBatisPlus</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbtiMQ学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ.html</url>
      
        <content type="html"><![CDATA[<p>RabbitMQ</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nginx.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nginx.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章认识Nginx"><a href="#第一章认识Nginx" class="headerlink" title="第一章认识Nginx"></a>第一章认识Nginx</h1><h2 id="1-1什么是Nginx"><a href="#1-1什么是Nginx" class="headerlink" title="1.1什么是Nginx"></a>1.1什么是Nginx</h2><p>Nginx (engine x)  是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p><h2 id="1-2为什么需要Nginx"><a href="#1-2为什么需要Nginx" class="headerlink" title="1.2为什么需要Nginx"></a>1.2为什么需要Nginx</h2><p>在简单环境中，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/HPM7S24YDD4TXOW%5BSKR4%5BFT.png" alt="image-1"></p><p>但是当项目持续迭代后，平台的用户快速增长，并发了增大，这时候一台服务器就无法满足需求了。</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/2.png" alt="image-2"></p><p>于是我们需要横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/3.png" alt="image-3"></p><p>我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。</p><h2 id="1-3Nginx的作用"><a href="#1-3Nginx的作用" class="headerlink" title="1.3Nginx的作用"></a>1.3Nginx的作用</h2><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p><p>正向代理：</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/4.png" alt="image-4"></p><p>反向代理：</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/5.png" alt="image-5"></p><pre class="line-numbers language-none"><code class="language-none">Nginx提供了两种负载均衡策略，内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</code></pre><p>轮询</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/6.png" alt="image-6"></p><p>加权轮询</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/7.png" alt="image-7"></p><p>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/8.png" alt="image-8"></p><pre class="line-numbers language-none"><code class="language-none">动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</code></pre><p><img src="https://blog-xml.oss-cn-beijing.aliyuncs.com/Nginx/9.png" alt="image-9"></p><p>目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！</p><p>具体操作配置参考：<br><a href="https://blog.csdn.net/S_ZaiJiangHu/article/details/126838279">https://blog.csdn.net/S_ZaiJiangHu/article/details/126838279</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis6</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6.html</url>
      
        <content type="html"><![CDATA[<p>Redis6</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SSM%E6%95%B4%E5%90%88.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SSM%E6%95%B4%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<p>SSM整合</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring5.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring5.html</url>
      
        <content type="html"><![CDATA[<p>Spring5</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%20Security.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%20Security.html</url>
      
        <content type="html"><![CDATA[<p>Spring Security</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC.html</url>
      
        <content type="html"><![CDATA[<p>SpringMVC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot学习笔记"><a href="#SpringBoot学习笔记" class="headerlink" title="SpringBoot学习笔记"></a>SpringBoot学习笔记</h1><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>官方文档：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><h3 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h3><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。</p><p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p><h3 id="Spring如何简化Java开发"><a href="#Spring如何简化Java开发" class="headerlink" title="Spring如何简化Java开发"></a>Spring如何简化Java开发</h3><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p><pre class="line-numbers language-none"><code class="language-none">基于POJO的轻量级和最小侵入性编程，所有东西都是bean；通过IOC，依赖注入（DI）和面向接口实现松耦合；基于切面（AOP）和惯例进行声明式编程；通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</code></pre><h3 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h3><p>就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p><pre class="line-numbers language-none"><code class="language-none">Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</code></pre><p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p><h3 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h3><ul><li>为所有Spring开发者更快的入门</li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p> 微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合；可以通过http的方式进行互通，要说微服务架构，先得说说过去的单体应用架构。</p><h3 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h3><p> 所谓单体应用架构(all in one)是指，我们将一个应用中的所有应用服务都封装在一个应用中。 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问，等等各个功能放在一个war包内。</p><ul><li>这么做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需把war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。</li><li>单体应用架构缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里，我们如何维护、如何分工合作都是问题。</li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p> all in one 的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。</p><p> 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。</p><p>这样做的好处 ：</p><ul><li>节省了调用资源</li><li>每个功能元素的服务都是一个可替换的、可独立升级的软件代码。</li></ul><h3 id="如何构建微服务架构"><a href="#如何构建微服务架构" class="headerlink" title="如何构建微服务架构"></a>如何构建微服务架构</h3><p> 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。<br>​ 但是这种庞大的系统架构给部署和运维带来很大的难度。于是，spring为我们带来了构建大型分布式微服务的全套、全程产品:</p><ul><li>构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用</li><li>大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式</li><li>在分布式中间，进行流式数据计算、批处理，我们有spring cloud data flow。</li><li>spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。</li></ul><h2 id="第一个SpringBoot项目"><a href="#第一个SpringBoot项目" class="headerlink" title="第一个SpringBoot项目"></a>第一个SpringBoot项目</h2><p>环境准备：</p><ul><li>jdk1.8</li><li>Maven-3.6.3</li><li>SpringBoot 2.7.8</li></ul><p>开发工具：</p><ul><li>IDEA</li></ul><p>Spring官方提供了非常方便的工具让我们快速构建应用</p><p>Spring Initializr：<a href="https://start.spring.io/">https://start.spring.io/</a></p><h3 id="项目创建方式一"><a href="#项目创建方式一" class="headerlink" title="项目创建方式一"></a>项目创建方式一</h3><p><strong>使用Spring Initializr 的 Web页面创建项目</strong></p><p>1、打开 <a href="https://start.spring.io/">https://start.spring.io/</a></p><p>2、填写项目信息</p><p>3、点击”Generate Project“按钮生成项目；下载此项目</p><p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p><p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p><h3 id="项目创建方式二"><a href="#项目创建方式二" class="headerlink" title="项目创建方式二"></a>项目创建方式二</h3><p><strong>使用 IDEA 直接创建项目</strong></p><p>1、创建一个新项目</p><p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p><p>3、填写项目信息</p><p>4、选择初始化的组件（初学勾选 Web 即可）</p><p>5、填写项目路径</p><p>6、等待项目构建成功</p><h3 id="pom-xml分析"><a href="#pom-xml分析" class="headerlink" title="pom.xml分析"></a>pom.xml分析</h3><p>打开pom.xml，看看Spring Boot项目的依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;!--有父项目--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.7.8&lt;&#x2F;version&gt;        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;    &lt;&#x2F;parent&gt;    &lt;groupId&gt;com.lc&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;helloworld&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;name&gt;helloworld&lt;&#x2F;name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;    &lt;&#x2F;properties&gt;    &lt;dependencies&gt;        &lt;!--web依赖:tomcat,dispatcherServlet,xml--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;!--spring-boot-start所有的springboot依赖都是使用这个开头--&gt;        &lt;!--单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    &lt;build&gt;        &lt;!--打jar包插件--&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;            &lt;&#x2F;plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;                &lt;version&gt;3.0.2&lt;&#x2F;version&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;&lt;&#x2F;project&gt;</code></pre><h3 id="编写http接口"><a href="#编写http接口" class="headerlink" title="编写http接口"></a>编写http接口</h3><p>在主程序的同级目录下，新建一个controller包，一定要在启动类同级目录下，否则识别不到</p><p>在包中新建一个HelloController类 :</p><pre class="line-numbers language-none"><code class="language-none">package com.lc.helloworld.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;&#x2F;自动装配@RestControllerpublic class HelloController &#123;    &#x2F;&#x2F;接口：http:&#x2F;&#x2F;localhost:8080&#x2F;hello    @RequestMapping(&quot;&#x2F;hello&quot;)    public String hello()&#123;        &#x2F;&#x2F;调用业务，接收前端参数        return &quot;hello,World&quot;;    &#125;&#125;</code></pre><p>编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425115905804.png" alt="image-20230425115905804"></p><p>这样一个web接口的开发就完成了</p><h3 id="将项目打成jar包"><a href="#将项目打成jar包" class="headerlink" title="将项目打成jar包"></a>将项目打成jar包</h3><p>点击右侧Maven Projectc工具栏中的package 即可将项目打包成一个jar包，如果打包成功，则会在target目录下生成一个 jar 包，打成了jar包后，就可以在任何地方运行了！</p><h3 id="更改项目端口号"><a href="#更改项目端口号" class="headerlink" title="更改项目端口号"></a>更改项目端口号</h3><p>在配置文件中修改server.port</p><pre class="line-numbers language-none"><code class="language-none">#更改项目端口号server.port&#x3D;8081</code></pre><h3 id="更改启动时banner图案"><a href="#更改启动时banner图案" class="headerlink" title="更改启动时banner图案"></a>更改启动时banner图案</h3><p>到项目下的 resources 目录下新建一个banner.txt 即可:</p><p>图案可以到网站 <a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a> 生成，拷贝到文件中即可！</p><h2 id="SpringBoot运行原理"><a href="#SpringBoot运行原理" class="headerlink" title="SpringBoot运行原理"></a>SpringBoot运行原理</h2><h3 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h3><p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;</code></pre><p>点进去，发现还有一个父依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;    &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;&lt;&#x2F;parent&gt;</code></pre><p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p><strong>以后我们导入依赖默认是不需要写版本，因为有这些版本仓库；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p><h3 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p><p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p><h3 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h3><p><strong>默认的主启动类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.lc;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;&#x2F;&#x2F;@SpringBootApplication 来标注一个主程序类&#x2F;&#x2F;说明这是一个Spring Boot应用@SpringBootApplicationpublic class Springboot01HellowroldApplication &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;以为是启动了一个方法，没想到启动了一个服务        SpringApplication.run(Springboot01HellowroldApplication.class, args);    &#125;&#125;</code></pre><p>注解：</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplication : 标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；@@SpringBootConfiguration : Spring配置类，标注在某个类上，表示这是一个SpringBoot的配置类；@Configuration : 说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；@Component : 说明启动类本身也是Spring中的一个组件而已，负责启动应用！@ComponentScan : 这个注解在Spring中很重要 ,它对应XML配置中的元素，扫码当前主启动类同级的包。作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中@EnableAutoConfiguration : 开启自动配置功能AutoConfigurationPackage : 自动配置包@Import(&#123;Registrar.class&#125;) : 自动配置 ‘包组件’Spring底层注解@import ， 给容器中导入一个组件Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器@Import(&#123;AutoConfigurationImportSelector.class&#125;) : 给容器导入组件AutoConfigurationImportSelector ：自动配置导入选择器</code></pre><h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！所有的自动配置类都在这里。</p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><p><strong>SpringBoot所有自动配置都是在启动的时候扫描并加载: <code>spring.factories</code>所有的自动配置类都在这里面，但是不一定生效。要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功!</strong></p><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootApplicationpublic class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;&#125;</code></pre><p><strong>SpringApplication.run分析</strong></p><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p><p><strong>SpringApplication这个类主要做了以下四件事情：</strong></p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>查看构造器：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;    &#x2F;&#x2F; ......    this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();    this.setInitializers(this.getSpringFactoriesInstances();    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));    this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();&#125;</code></pre><h3 id="run方法流程"><a href="#run方法流程" class="headerlink" title="run方法流程"></a>run方法流程</h3><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2023/02/01/kuangstudy3bdd474f-d73b-4ad1-9cca-8f9e12683d0b.jpg" alt="img"></p><h2 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p><ul><li><p>application.properties</p><p>​语法结构 ：key&#x3D;value</p></li><li><p>application.yml</p><p>​语法结构 ：key：空格 value</p></li></ul><p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p><p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p><p>server.port&#x3D;8081</p><h3 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h3><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p><p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p><p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p><p>传统xml配置：</p><pre class="line-numbers language-none"><code class="language-none">&lt;server&gt;    &lt;port&gt;8081&lt;port&gt;&lt;&#x2F;server&gt;</code></pre><p>yaml配置：</p><pre class="line-numbers language-none"><code class="language-none">server:prot: 8080</code></pre><h3 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h3><p>说明：语法要求严格！</p><ul><li>空格不能省略</li><li>以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</li><li>属性和值的大小写都是十分敏感的。</li></ul><p><strong>字面量：普通的值 [ 数字，布尔值，字符串 ]</strong></p><p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>k: v</p></blockquote><p>注意：</p><ul><li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p><p>比如 ：name: “kuang \n shen” 输出 ：kuang 换行 shen</p></li><li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p><p>比如 ：name: ‘kuang \n shen’ 输出 ：kuang \n shen</p></li></ul><p><strong>对象、Map（键值对）</strong></p><pre class="line-numbers language-none"><code class="language-none">#对象、Map格式k:     v1:v2:</code></pre><p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p><pre class="line-numbers language-none"><code class="language-none">student:  name: qinjiang age: 3</code></pre><p>行内写法</p><pre class="line-numbers language-none"><code class="language-none">student: &#123;name: qinjiang,age: 3&#125;</code></pre><p><strong>数组（ List、set ）</strong></p><p>用 - 值表示数组中的一个元素,比如：</p><pre class="line-numbers language-none"><code class="language-none">pets:   - cat  - dog  - pig</code></pre><p>行内写法</p><pre class="line-numbers language-none"><code class="language-none">pets: [cat,dog,pig]</code></pre><p><strong>修改SpringBoot的默认端口号</strong></p><p><strong>配置文件中添加，端口号的参数，就可以切换端口；</strong></p><pre class="line-numbers language-none"><code class="language-none">server: port: 8082</code></pre><h3 id="给属性赋值"><a href="#给属性赋值" class="headerlink" title="给属性赋值"></a>给属性赋值</h3><p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p><p><strong>yaml注入配置文件</strong></p><p>在springboot项目中的resources目录下新建一个文件 application.yml</p><p>编写一个实体类 Dog，原来使用@Value给bean注入属性值 :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.springboot.pojo;@Component  &#x2F;&#x2F;注册bean到容器中public class Dog &#123;    @Value(&quot;旺财&quot;)    &#x2F;&#x2F;注入属性值    private String name;    @Value(&quot;3&quot;)    private Integer age;    &#x2F;&#x2F;有参无参构造、get、set方法、toString()方法  &#125;</code></pre><p>在SpringBoot的测试类下注入狗狗输出一下 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootTestclass DemoApplicationTests &#123;    @Autowired &#x2F;&#x2F;将狗狗自动注入进来    private Dog dog;    @Test    public void contextLoads() &#123;        System.out.println(dog); &#x2F;&#x2F;打印看下狗狗对象    &#125;&#125;</code></pre><p>结果成功输出，@Value注入成功</p><p><strong>指定配置文件</strong></p><p><strong>@PropertySource：</strong>加载指定的配置文件；</p><p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p><p>在resources目录下新建一个<strong>person.properties</strong>文件</p><pre class="line-numbers language-none"><code class="language-none">name&#x3D;lisi</code></pre><p>然后代码中指定加载person.properties文件</p><pre class="line-numbers language-none"><code class="language-none">@Component  &#x2F;&#x2F;注册bean&#x2F;&#x2F;@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)&#x2F;&#x2F;加载指定的配置文件@PropertySource(value &#x3D; &quot;classpath:lisi.properties&quot;)public class Person &#123;&#x2F;&#x2F;SPEL表达式取出配置文件的值@Value(&quot;$&#123;name&#125;&quot;)private String name;……&#125;</code></pre><p>输出测试，指定配置文件绑定成功！</p><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><p>配置文件还可以编写占位符生成随机数</p><pre class="line-numbers language-none"><code class="language-none">person:    name: 张三$&#123;random.uuid&#125; # 随机uuid    age: $&#123;random.int&#125;  # 随机int    happy: false    birth: 2000&#x2F;01&#x2F;01    maps: &#123;k1: v1,k2: v2&#125;    lists:      - code      - girl      - music    dog:      name: $&#123;person.hello:other&#125;_旺财      age: 1</code></pre><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p><p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接configurationProperties</p><h2 id="JSR303校验"><a href="#JSR303校验" class="headerlink" title="JSR303校验"></a>JSR303校验</h2><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。这里写个注解让我们的name只能支持Email格式；</p><p>添加依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Component &#x2F;&#x2F;注册bean@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)@Validated  &#x2F;&#x2F;数据校验public class Person &#123;    @Email(message&#x3D;&quot;邮箱格式错误&quot;) &#x2F;&#x2F;name必须是邮箱格式    private String name;&#125;</code></pre><p>运行结果 ：default message [不是一个合法的电子邮件地址];</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425115938719.png" alt="image-20230425115938719"></p><p><strong>使用数据校验，可以保证数据的正确性；</strong></p><p><strong>常见校验参数</strong></p><pre class="line-numbers language-none"><code class="language-none">@NotNull(message&#x3D;&quot;名字不能为空&quot;)private String userName;@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)private int age;@Email(message&#x3D;&quot;邮箱格式错误&quot;)private String email;空检查@Null       验证对象是否为null@NotNull    验证对象是否不为null, 无法查检长度为0的字符串@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty   检查约束元素是否为NULL或者是EMPTY.Booelan检查@AssertTrue     验证 Boolean 对象是否为 true  @AssertFalse    验证 Boolean 对象是否为 false  长度检查@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min&#x3D;, max&#x3D;) string is between min and max included.日期检查@Past       验证 Date 和 Calendar 对象是否在当前时间之前  @Future     验证 Date 和 Calendar 对象是否在当前时间之后  @Pattern    验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则</code></pre><h2 id="多环境装配"><a href="#多环境装配" class="headerlink" title="多环境装配"></a>多环境装配</h2><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p><h3 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties&#x2F;yml , 用来指定多个环境版本；</p><p><strong>例如：</strong></p><p>application-test.properties 代表测试环境配置</p><p>application-dev.properties 代表开发环境配置</p><p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>。</p><p>我们需要通过一个配置来选择需要激活的环境：</p><pre class="line-numbers language-none"><code class="language-none">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active&#x3D;dev</code></pre><h3 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h3><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8081#选择要激活那个环境块spring:  profiles:    active: prod---server:  port: 8083spring:  profiles: dev #配置环境的名称---server:  port: 8084spring:  profiles: prod  #配置环境的名称</code></pre><p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p><h3 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h3><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p><p>官方外部配置文件说明参考文档</p><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p><p>优先级1：项目路径下的config文件夹配置文件</p><p>优先级2：项目路径下配置文件</p><p>优先级3：资源路径下的config文件夹配置文件</p><p>优先级4：资源路径下配置文件</p><p>优先级由高到低，高优先级的配置会覆盖低优先级的配置</p><p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p><p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p><pre class="line-numbers language-none"><code class="language-none">#配置项目的访问路径server.servlet.context-path&#x3D;&#x2F;kuang</code></pre><h3 id="扩展，运维小技巧"><a href="#扩展，运维小技巧" class="headerlink" title="扩展，运维小技巧"></a>扩展，运维小技巧</h3><p>指定位置加载配置文件</p><p>我们还可以通过spring.config.location来改变默认的配置文件位置</p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p><pre class="line-numbers language-none"><code class="language-none">java -jar spring-boot-config.jar --spring.config.location&#x3D;F:&#x2F;application.properties</code></pre><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="分析自动配置原理"><a href="#分析自动配置原理" class="headerlink" title="分析自动配置原理"></a>分析自动配置原理</h3><p>以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration &#x2F;&#x2F;启动指定类的ConfigurationProperties功能；  &#x2F;&#x2F;进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；  &#x2F;&#x2F;并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) &#x2F;&#x2F;Spring底层@Conditional注解  &#x2F;&#x2F;根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；  &#x2F;&#x2F;这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication(    type &#x3D; Type.SERVLET)&#x2F;&#x2F;判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)&#x2F;&#x2F;判断配置文件中是否存在某个配置：spring.http.encoding.enabled；  &#x2F;&#x2F;如果不存在，判断也是成立的  &#x2F;&#x2F;即使我们配置文件中不配置pring.http.encoding.enabled&#x3D;true，也是默认生效的；@ConditionalOnProperty(    prefix &#x3D; &quot;spring.http.encoding&quot;,    value &#x3D; &#123;&quot;enabled&quot;&#125;,    matchIfMissing &#x3D; true)public class HttpEncodingAutoConfiguration &#123;    &#x2F;&#x2F;他已经和SpringBoot的配置文件映射了    private final Encoding properties;    &#x2F;&#x2F;只有一个有参构造器的情况下，参数的值就会从容器中拿    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;        this.properties &#x3D; properties.getEncoding();    &#125;    &#x2F;&#x2F;给容器中添加一个组件，这个组件的某些值需要从properties中获取    @Bean    @ConditionalOnMissingBean &#x2F;&#x2F;判断容器没有这个组件？    public CharacterEncodingFilter characterEncodingFilter() &#123;        CharacterEncodingFilter filter &#x3D; new OrderedCharacterEncodingFilter();        filter.setEncoding(this.properties.getCharset().name());        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));        return filter;    &#125;    &#x2F;&#x2F;......&#125;</code></pre><p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p><ul><li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li><li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li><li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li><li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix &#x3D; &quot;spring.http&quot;) public class HttpProperties &#123;    &#x2F;&#x2F; .....&#125;</code></pre><p><strong>这就是自动装配的原理！</strong></p><h3 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h3><p>1、SpringBoot启动会加载大量的自动配置类</p><p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p><p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p><p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p><p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p><p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p><p><strong>了解：</strong>@Conditionl：</p><p>了解完自动装配的原理后，关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2023/02/01/kuangstudy31d7f34c-829b-4fe1-a184-d9114bb328a3.jpg" alt="img"></p><p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p><p>我们怎么知道哪些自动配置类生效？</p><p><strong>我们可以通过启用 debug&#x3D;true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p><pre class="line-numbers language-none"><code class="language-none">#开启springboot的调试类debug&#x3D;true</code></pre><p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p><p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p><p><strong>Unconditional classes: （没有条件的类）</strong></p><h2 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h2><p><strong>使用SpringBoot的步骤：</strong></p><p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p><p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p><p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p><p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p><p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p><ul><li>向容器中自动配置组件 ：<strong>Autoconfiguration</strong></li><li>自动配置类，封装配置文件的内容：<strong>Properties</strong></li></ul><h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><ul><li>导入静态资源</li><li>首页</li><li>jsp，模板引擎Thymeleaf</li><li>装配扩展SpringMVC</li><li>增删改查</li><li>拦截器</li><li>国际化</li></ul><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p><p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p><p>有一个方法：addResourceHandlers 添加资源处理</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    if (!this.resourceProperties.isAddMappings()) &#123;        &#x2F;&#x2F; 已禁用默认资源处理        logger.debug(&quot;Default resource handling disabled&quot;);        return;    &#125;    &#x2F;&#x2F; 缓存控制    Duration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod();    CacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();    &#x2F;&#x2F; webjars 配置    if (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)                                             .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;    &#x2F;&#x2F; 静态资源配置    String staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;&#125;</code></pre><p>读一下源代码：比如所有的 &#x2F;webjars&#x2F;** ， 都需要去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找对应的资源；</p><h4 id="1-webjars方式引入"><a href="#1-webjars方式引入" class="headerlink" title="1.webjars方式引入"></a>1.webjars方式引入</h4><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p><p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p><p>网站：<a href="https://www.webjars.org/">https://www.webjars.org</a></p><p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源</p><p>我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120052766.png" alt="image-20230425120052766"></p><h4 id="2-静态资源映射规则"><a href="#2-静态资源映射规则" class="headerlink" title="2.静态资源映射规则"></a>2.静态资源映射规则</h4><p>我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p><p>我们去找staticPathPattern发现第二种映射规则 ：&#x2F;** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 进入方法public String[] getStaticLocations() &#123;    return this.staticLocations;&#125;&#x2F;&#x2F; 找到对应的值private String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;&#x2F;&#x2F; 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123;     &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,  &quot;classpath:&#x2F;resources&#x2F;&quot;,     &quot;classpath:&#x2F;static&#x2F;&quot;,     &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;</code></pre><p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p><p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p><pre class="line-numbers language-none"><code class="language-none">“classpath:&#x2F;META-INF&#x2F;resources&#x2F;““classpath:&#x2F;resources&#x2F;““classpath:&#x2F;static&#x2F;““classpath:&#x2F;public&#x2F;“</code></pre><p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p><p>比如我们访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p><h4 id="3-自定义静态资源路径"><a href="#3-自定义静态资源路径" class="headerlink" title="3.自定义静态资源路径"></a>3.自定义静态资源路径</h4><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p><pre class="line-numbers language-none"><code class="language-none">spring.resources.static-locations&#x3D;classpath:&#x2F;coding&#x2F;,classpath:&#x2F;kuang&#x2F;</code></pre><p><strong>注意：</strong>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p><h3 id="首页和图标定制"><a href="#首页和图标定制" class="headerlink" title="首页和图标定制"></a>首页和图标定制</h3><p>继续向下看源码，可以看到一个欢迎页的映射，就是我们的首页！</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,                                                           FormattingConversionService mvcConversionService,                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;    WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), &#x2F;&#x2F; getWelcomePage 获得欢迎页        this.mvcProperties.getStaticPathPattern());    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));    return welcomePageHandlerMapping;&#125;</code></pre><p>点进去继续看</p><pre class="line-numbers language-none"><code class="language-none">private Optional&lt;Resource&gt; getWelcomePage() &#123;    String[] locations &#x3D; getResourceLocations(this.resourceProperties.getStaticLocations());    &#x2F;&#x2F; ::是java8 中新引入的运算符    &#x2F;&#x2F; Class::function的时候function是属于Class的，应该是静态方法。    &#x2F;&#x2F; this::function的funtion是属于这个对象的。    &#x2F;&#x2F; 简而言之，就是一种语法糖而已，是一种简写    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;&#x2F;&#x2F; 欢迎页就是一个location下的的 index.html 而已private Resource getIndexHtml(String location) &#123;    return this.resourceLoader.getResource(location + &quot;index.html&quot;);&#125;</code></pre><p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 &#x2F;** 映射。</p><p>比如我访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p><p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 <a href="http://localhost:8080/">http://localhost:8080/</a> 看结果！</p><h4 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a><strong>网站图标</strong></h4><p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p><p>1、关闭SpringBoot默认图标</p><pre class="line-numbers language-none"><code class="language-none">#关闭默认图标spring.mvc.favicon.enabled&#x3D;false</code></pre><p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p><p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230424164500756.png" alt="image-20230424164500756"></p><p>新版将 favicon.ico图片放入static目录即可。</p><h3 id="thymeleaf模板引擎"><a href="#thymeleaf模板引擎" class="headerlink" title="thymeleaf模板引擎"></a>thymeleaf模板引擎</h3><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p><p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p><p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦</p><p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p><p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120148915.png" alt="image-20230425120148915"></p><p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且功能更强大。</p><h4 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h4><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p><p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p><p>Spring官方文档：找到我们对应的版本</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p><p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--thymeleaf--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>Maven会自动下载jar包，我们可以去看下下载的东西；</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120206867.png" alt="image-20230425120206867"></p><h4 id="Thymeleaf分析"><a href="#Thymeleaf分析" class="headerlink" title="Thymeleaf分析"></a>Thymeleaf分析</h4><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p><p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p><p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p><pre class="line-numbers language-none"><code class="language-none">@ConfigurationProperties(    prefix &#x3D; &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123;    private static final Charset DEFAULT_ENCODING;    public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;    public static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;    private boolean checkTemplate &#x3D; true;    private boolean checkTemplateLocation &#x3D; true;    private String prefix &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;    private String suffix &#x3D; &quot;.html&quot;;    private String mode &#x3D; &quot;HTML&quot;;    private Charset encoding;&#125;</code></pre><p>我们可以在其中看到默认的前缀和后缀！</p><p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p><p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p><h4 id="Thymeleaf语法学习"><a href="#Thymeleaf语法学习" class="headerlink" title="Thymeleaf语法学习"></a>Thymeleaf语法学习</h4><p>修改测试请求，增加数据传输；</p><pre class="line-numbers language-none"><code class="language-none">@RequestMapping(&quot;&#x2F;t1&quot;)public String test1(Model model)&#123;    &#x2F;&#x2F;存入数据    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);    &#x2F;&#x2F;classpath:&#x2F;templates&#x2F;test.html    return &quot;test&quot;;&#125;</code></pre><p>要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。可以去官方文档的#3中看一下命名空间拿来过来：</p><pre class="line-numbers language-none"><code class="language-none">xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;</code></pre><p>去编写下前端页面</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;!--使用http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;thymeleaf-extras-spring,红色下划线消失--&gt;&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;测试页面&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;Test&lt;&#x2F;h1&gt;&lt;!--th:text就是将div中的内容设置为它指定的值--&gt;&lt;div th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="提取公共页面"><a href="#提取公共页面" class="headerlink" title="提取公共页面"></a>提取公共页面</h4><p>可以将导航栏、侧边栏、底部栏等放入一个html文件中，在第一句标签上加上th:fragment&#x3D;”XXXX”。</p><p>在其它html文件中调用只需:</p><pre class="line-numbers language-none"><code class="language-none">&lt;div th:insert&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--插入--&gt;&lt;div th:replace&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--替换--&gt;</code></pre><p>如果要传递参数，直接在XXXX后面用(参数名&#x3D;参数值)传参。</p><p>(接收可以th:class&#x3D;”${参数名&#x3D;&#x3D;参数值?”正确就执行的属性”:”不正确执行的属性”}”)</p><h4 id="日期转义"><a href="#日期转义" class="headerlink" title="日期转义"></a>日期转义</h4><pre class="line-numbers language-none"><code class="language-none">th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)</code></pre><h3 id="MVC配置"><a href="#MVC配置" class="headerlink" title="MVC配置"></a>MVC配置</h3><p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p><p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p><p>地址 ：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p><h2 id="SpringBoot-Web项目练习"><a href="#SpringBoot-Web项目练习" class="headerlink" title="SpringBoot Web项目练习"></a>SpringBoot Web项目练习</h2><h3 id="登录实现"><a href="#登录实现" class="headerlink" title="登录实现"></a>登录实现</h3><p>在LoginController中编写登陆方法 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.lc.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.thymeleaf.util.StringUtils;import javax.servlet.http.HttpSession;@Controllerpublic class LoginController &#123;    @RequestMapping(&quot;&#x2F;user&#x2F;login&quot;)    public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model model, HttpSession session)&#123;        &#x2F;&#x2F;具体业务        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password))&#123;            session.setAttribute(&quot;loginUser&quot;,username);            return &quot;redirect:&#x2F;main.html &quot;;        &#125;else &#123;            &#x2F;&#x2F;告知用户登陆失败            model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误!&quot;);            return &quot;login&quot;;        &#125;    &#125;&#125;</code></pre><p>在MyMvcConfig中添加跳转视图控制 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;    &#x2F;&#x2F;添加视图控制    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;访问&#x2F;前往登录页        registry.addViewController(&quot;&#x2F;login.html&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;前往登录页        registry.addViewController(&quot;&#x2F;main.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页        registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页    &#125;    &#x2F;&#x2F;自定义的国际化组件就生效了    @Bean    public LocaleResolver localeResolver()&#123;        return new MyLocaleResolver();    &#125;&#125;</code></pre><p>在templates中编写登陆页面login.html :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;amazeui.min.css&#125;&quot;&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;admin.css&#125;&quot;&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;app.css&#125;&quot;&gt;    &lt;title&gt;登陆页面&lt;&#x2F;title&gt;    &lt;style&gt;        div.set_center&#123;            margin-left: auto;            margin-right: auto;            width: 450px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body class&#x3D;&quot;am-text-center&quot;&gt;    &lt;form class&#x3D;&quot;&quot; th:action&#x3D;&quot;@&#123;&#x2F;user&#x2F;login&#125;&quot;&gt;        &lt;div class&#x3D;&quot;set_center&quot;&gt;            &lt;h1 th:text&#x3D;&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;&#x2F;h1&gt;            &lt;!--如果msg为空则不显示--&gt;            &lt;p style&#x3D;&quot;color: red&quot; th:text&#x3D;&quot;$&#123;msg&#125;&quot; th:if&#x3D;&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;&#x2F;p&gt;            &lt;label&gt;Username:&lt;&#x2F;label&gt;            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;username&quot; th:placeholder&#x3D;&quot;#&#123;login.username&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;&lt;br&gt;            &lt;label&gt;Password:&lt;&#x2F;label&gt;            &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; th:placeholder&#x3D;&quot;#&#123;login.password&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;            &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;remember-me&quot; th:text&#x3D;&quot;#&#123;login.remember&#125;&quot;&gt;&lt;br&gt;            &lt;button class&#x3D;&quot;btn-box&quot; th:text&#x3D;&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;&#x2F;button&gt;            &lt;!-- 这里传入参数不需要使用 ？使用 （key&#x3D;value）--&gt;&lt;br&gt;            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;&#x2F;a&gt;&amp;nbsp;&amp;nbsp;            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;en_US&#39;)&#125;&quot;&gt;English&lt;&#x2F;a&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>运行，输入任意账号和123456密码成功登陆:</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425102149050.png" alt="image-20230425102149050"></p><h3 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h3><p>新建LoginHandlerInterceptor继承HandlerInterceptor方法实现拦截器 </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.lc.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginHandlerInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        &#x2F;&#x2F;登录成功后，应该有用户的session        Object loginUser &#x3D; request.getSession().getAttribute(&quot;loginUser&quot;);        if(loginUser &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;没有登陆            request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;);            request.getRequestDispatcher(&quot;&#x2F;login.html&quot;).forward(request,response);            return false;        &#125;else&#123;            return true;        &#125;    &#125;&#125;</code></pre><p>在MyMvcConfig中添加自定义拦截器</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;自定义拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    &#x2F;&#x2F;拦截所有页面除了登陆页面和静态资源    registry.addInterceptor(new LoginHandlerInterceptor())            .addPathPatterns(&quot;&#x2F;**&quot;)            .excludePathPatterns(&quot;&#x2F;login.html&quot;,&quot;&#x2F;&quot;,&quot;&#x2F;user&#x2F;login&quot;,&quot;&#x2F;css&#x2F;*&quot;,&quot;&#x2F;js&#x2F;*&quot;);&#125;</code></pre><p>直接访问main.html拦截成功，转入登录页面 :</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/kuangstudy47189c2f-8ff2-436b-96c2-fca9d53e41e8.png" alt="img"></p><h3 id="展示员工列表"><a href="#展示员工列表" class="headerlink" title="展示员工列表"></a>展示员工列表</h3><p>在EmployeeController中写入员工列表代码 ,传入员工列表:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Controllerpublic class EmployeeController &#123;    @Autowired    EmployeeDao employeeDao;    @RequestMapping(&quot;&#x2F;emps&quot;)    public String list(Model model)&#123;        Collection&lt;Employee&gt; employees &#x3D; employeeDao.getAllEmployee();        model.addAttribute(&quot;emps&quot;,employees);        System.out.println(&quot;!!!!!!!!!!!!&quot;);        return &quot;emp&#x2F;user&quot;;    &#125;&#125;</code></pre><p>部分前端代码 :</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table class&#x3D;&quot;am-table am-table-striped am-table-hover table-main&quot;&gt;&lt;thead&gt;&lt;tr&gt;    &lt;th class&#x3D;&quot;table-check&quot;&gt;        &lt;input id&#x3D;&quot;chkAll&quot; type&#x3D;&quot;checkbox&quot;&gt;    &lt;&#x2F;th&gt;    &lt;th class&#x3D;&quot;table-id&quot;&gt;        ID    &lt;&#x2F;th&gt;    &lt;th class&#x3D;&quot;table-title&quot;&gt;        姓名    &lt;&#x2F;th&gt;    &lt;th&gt;        性别    &lt;&#x2F;th&gt;    &lt;th&gt;        部门名称    &lt;&#x2F;th&gt;    &lt;th&gt;        邮箱    &lt;&#x2F;th&gt;    &lt;th&gt;        生日    &lt;&#x2F;th&gt;    &lt;th class&#x3D;&quot;table-set&quot;&gt;        操作    &lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody id&#x3D;&quot;tUser&quot;&gt;&lt;tr th:each&#x3D;&quot;emp:$&#123;emps&#125;&quot;&gt;    &lt;td&gt;&lt;input name&#x3D;&quot;ids&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;emp.getId()&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;emp.getName()&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;emp.getGander()&#x3D;&#x3D;0?&#39;女&#39;:&#39;男&#39;&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;emp.getDepartment().getDepartmentName()&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;emp.getEmail()&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td&gt;        &lt;div class&#x3D;&quot;am-btn-toolbar&quot;&gt;            &lt;div class&#x3D;&quot;am-btn-group am-btn-group-xs&quot;&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-secondary btnEdit&quot;&gt;&lt;span class&#x3D;&quot;am-icon-pencil-square-o&quot;&gt;&lt;&#x2F;span&gt; 编辑&lt;&#x2F;button&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-danger am-hide-sm-only&quot; onclick&#x3D;&quot;delUser(1,1)&quot;&gt;&lt;span class&#x3D;&quot;am-icon-trash-o&quot;&gt;&lt;&#x2F;span&gt; 删除&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;</code></pre><h3 id="添加员工"><a href="#添加员工" class="headerlink" title="添加员工"></a>添加员工</h3><p>在EmployeeController中添加方法 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;跳转到addUser页面@GetMapping(&quot;&#x2F;add&quot;)public String toAddUser(Model model)&#123;    Collection&lt;Department&gt; departments &#x3D; departmentDao.getDepartment();    model.addAttribute(&quot;departs&quot;,departments);    return &quot;emp&#x2F;addUser&quot;;&#125;&#x2F;&#x2F;添加员工@RequestMapping(&quot;&#x2F;addEmp&quot;)public String addEmp(Employee employee)&#123;    employeeDao.addEmployee(employee);    System.out.println(&quot;employee++&gt;&quot;+employee);    return &quot;redirect:&#x2F;emps&quot;;&#125;</code></pre><p>部分前端代码 :</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form class&#x3D;&quot;am-form am-form-horizontal&quot; th:action&#x3D;&quot;@&#123;&#x2F;addEmp&#125;&quot; method&#x3D;&quot;post&quot; style&#x3D;&quot;padding-top: 30px;&quot;&gt;&lt;input name&#x3D;&quot;id&quot; type&#x3D;&quot;hidden&quot;&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;    姓名    &lt;&#x2F;label&gt;    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入姓名&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot;&gt;        &lt;small&gt;请输入姓名。&lt;&#x2F;small&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;    邮箱    &lt;&#x2F;label&gt;    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入邮箱&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;email&quot; type&#x3D;&quot;text&quot;&gt;        &lt;small &gt;请输入邮箱。&lt;&#x2F;small&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;            性别 &#x2F; sex        &lt;&#x2F;label&gt;    &lt;div class&#x3D;&quot;am-u-sm-9&quot; style&#x3D;&quot;line-height: 30px;&quot;&gt;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;man&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;        &lt;label for&#x3D;&quot;man&quot;&gt;                男            &lt;&#x2F;label&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;woman&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;        &lt;label for&#x3D;&quot;woman&quot;&gt;                女            &lt;&#x2F;label&gt;        &lt;br &#x2F;&gt;        &lt;small&gt;请选择性别&lt;&#x2F;small&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;            部门        &lt;&#x2F;label&gt;    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;        &lt;select name&#x3D;&quot;department.id&quot; required&gt;            &lt;option th:each&#x3D;&quot;dept:$&#123;departs&#125;&quot; th:text&#x3D;&quot;$&#123;dept.getDepartmentName()&#125;&quot; th:value&#x3D;&quot;$&#123;dept.getId()&#125;&quot;&gt;&lt;&#x2F;option&gt;        &lt;&#x2F;select&gt;        &lt;small&gt;请选择部门&lt;&#x2F;small&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;        生日    &lt;&#x2F;label&gt;    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入生日&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;birth&quot; type&#x3D;&quot;text&quot;&gt;        &lt;small&gt;请输入生日。&lt;&#x2F;small&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;am-form-group&quot;&gt;    &lt;div class&#x3D;&quot;am-u-sm-9 am-u-sm-push-3&quot;&gt;        &lt;input class&#x3D;&quot;am-btn am-btn-success&quot; value&#x3D;&quot;添加&quot; type&#x3D;&quot;submit&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;form&gt;</code></pre><p>知识点:</p><p>默认时间格式为y&#x2F;m&#x2F;d，可以在配置文件中修改为y-m-d:</p><pre class="line-numbers language-none"><code class="language-none">#时间日期格式化spring.mvc.date-format&#x3D;yyyy-MM-dd</code></pre><h3 id="404错误页面"><a href="#404错误页面" class="headerlink" title="404错误页面"></a>404错误页面</h3><p>在templates下新建error文件夹</p><p>在里面建404.html，发生404自动使用该页面</p><p>存入500.html，发生500错误则自动跳入。</p><h2 id="整合JDBC"><a href="#整合JDBC" class="headerlink" title="整合JDBC"></a>整合JDBC</h2><h3 id="SpringDate"><a href="#SpringDate" class="headerlink" title="SpringDate"></a>SpringDate</h3><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p><p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p><p>Sping Data 官网：<a href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p><p>数据库相关的启动器 ：可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p><h3 id="整合JDBC-1"><a href="#整合JDBC-1" class="headerlink" title="整合JDBC"></a>整合JDBC</h3><p>创建一个项目，引入 依赖</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425112158482.png" alt="image-20230425112158482"></p><p>项目建好之后，发现自动帮我们导入了如下的启动器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre><p>编写yaml配置文件连接数据库；</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  datasource:    username: root    password: 123456    #?serverTimezone&#x3D;UTC解决时区的报错    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><p>配置完这一些东西后，就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    &#x2F;&#x2F;DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        &#x2F;&#x2F;看一下默认数据源    com.zaxxer.hikari.HikariDataSource        System.out.println(dataSource.getClass());        &#x2F;&#x2F;获得连接        Connection connection &#x3D; dataSource.getConnection();        System.out.println(connection);        &#x2F;&#x2F;关闭连接        connection.close();    &#125;&#125;</code></pre><p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p><p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p><p>有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p><h3 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h3><p>即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p><p>数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p><p>Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p><p>JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li><li>query方法及queryForXXX方法：用于执行查询相关语句；</li><li>call方法：用于执行存储过程、函数相关语句。</li></ul><p>现在编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p><pre class="line-numbers language-none"><code class="language-none">package com.lc.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;&#x2F;jdbc&quot;)public class JdbcController &#123;    &#x2F;**     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接     *&#x2F;    @Autowired    JdbcTemplate jdbcTemplate;    &#x2F;&#x2F;查询employee表中所有数据    &#x2F;&#x2F;List 中的1个 Map 对应数据库的 1行数据    &#x2F;&#x2F;Map 中的 key 对应数据库的字段名，value 对应数据库的字段值    @GetMapping(&quot;&#x2F;list&quot;)    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;        String sql &#x3D; &quot;select * from mybatis.user&quot;;        List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; jdbcTemplate.queryForList(sql);        return maps;    &#125;    &#x2F;&#x2F;新增一个用户    @GetMapping(&quot;&#x2F;add&quot;)    public String addUser()&#123;        &#x2F;&#x2F;插入语句，注意时间问题        String sql &#x3D; &quot;insert into mybatis.user(id, name, pwd) &quot; +                &quot; values (10,&#39;张三&#39;,&#39;123456&#39;)&quot;;        jdbcTemplate.update(sql);        &#x2F;&#x2F;查询        return &quot;addOk&quot;;    &#125;    &#x2F;&#x2F;修改用户信息    @GetMapping(&quot;&#x2F;update&#x2F;&#123;id&#125;&quot;)    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;        &#x2F;&#x2F;插入语句        String sql &#x3D; &quot;update mybatis.user set name&#x3D;?,pwd&#x3D;? where id&#x3D;&quot;+id;        &#x2F;&#x2F;数据        Object[] objects &#x3D; new Object[2];        objects[0] &#x3D; &quot;修改名&quot;;        objects[1] &#x3D; &quot;AAAAAA&quot;;        jdbcTemplate.update(sql,objects);        &#x2F;&#x2F;查询        return &quot;updateOk&quot;;    &#125;    &#x2F;&#x2F;删除用户    @GetMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;        &#x2F;&#x2F;插入语句        String sql &#x3D; &quot;delete from mybatis.user where id&#x3D;?&quot;;        jdbcTemplate.update(sql,id);        &#x2F;&#x2F;查询        return &quot;deleteOk&quot;;    &#125;&#125;</code></pre><p>测试请求，结果正常；</p><p>到此，CURD的基本操作，使用 JDBC 就搞定了。</p><h2 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p><p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>添加上 Druid 数据源依赖。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.1.21&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p><pre class="line-numbers language-none"><code class="language-none">spring:  datasource:    username: root    password: 123456    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源</code></pre><p>数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425112640019.png" alt="image-20230425112640019"></p><p>确定切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  datasource:    username: root    password: 123456    #?serverTimezone&#x3D;UTC解决时区的报错    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500</code></pre><p>导入Log4j 的依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.kuang.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class DruidConfig &#123;    &#x2F;*       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效       @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)：作用就是将 全局配置文件中       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中     *&#x2F;    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)    @Bean    public DataSource druidDataSource() &#123;        return new DruidDataSource();    &#125;&#125;</code></pre><p>去测试类中测试一下；看是否成功！</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    &#x2F;&#x2F;DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        &#x2F;&#x2F;看一下默认数据源        System.out.println(dataSource.getClass());        &#x2F;&#x2F;获得连接        Connection connection &#x3D;   dataSource.getConnection();        System.out.println(connection);        DruidDataSource druidDataSource &#x3D; (DruidDataSource) dataSource;        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());        &#x2F;&#x2F;关闭连接        connection.close();    &#125;&#125;</code></pre><p>输出结果 ：可见配置参数已经生效！</p><h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><p>官方文档：<a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><p>Maven仓库地址：<a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</a></p><h3 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h3><p>导入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.1.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>配置数据库连接信息（不变）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  datasource:    username: root    password: 123456    #?serverTimezone&#x3D;UTC解决时区的报错    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500</code></pre><p><strong>测试数据库是否连接成功！</strong></p><p><strong>创建实体类，导入 Lombok！</strong></p><p>User.java</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.xiao.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;    private Integer id;    private String name;    private String pwd;&#125;</code></pre><p><strong>创建mapper目录以及对应的 Mapper 接口</strong></p><p>UserMapper.java</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.lc.mapper;import com.lc.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;&#x2F;&#x2F;这个注解表示这是一个Mybatis的mapper类@Mapper@Repositorypublic interface UserMapper &#123;    List&lt;User&gt; queryUserList();    User queryUserById(int id);    int addUser(User user);    int updateUser(User user);    int deleteUser(int id);&#125;</code></pre><p><strong>对应的Mapper映射文件</strong></p><p>UserMapper.xml，建在resources&#x2F;mybatis&#x2F;mapper下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper&gt;    &lt;select id&#x3D;&quot;queryUserList&quot; resultType&#x3D;&quot;User&quot;&gt;        select * from mybatis.user;    &lt;&#x2F;select&gt;    &lt;select id&#x3D;&quot;queryUserById&quot; resultType&#x3D;&quot;User&quot;&gt;        select * from mybatis.user where id &#x3D; #&#123;id&#125;    &lt;&#x2F;select&gt;    &lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;User&quot;&gt;        insert into mybatis.user(id, name, pwd)        values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);    &lt;&#x2F;insert&gt;    &lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;        update mybatis.user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id&#x3D;#&#123;id&#125;    &lt;&#x2F;update&gt;    &lt;delete id&#x3D;&quot;deleteUser&quot;parameterType&#x3D;&quot;int&quot;&gt;        delete from mybatis.user where id&#x3D;#&#123;id&#125;    &lt;&#x2F;delete&gt;&lt;&#x2F;mapper&gt;</code></pre><p>在配置文件application.yml中整合Mybatis :</p><pre class="line-numbers language-none"><code class="language-none">#整合Mybatis#别名#mapper地址mybatis:  type-aliases-package: com.lc.pojo  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml</code></pre><p><strong>编写UserController 进行测试！</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.lc.controller;import com.lc.mapper.UserMapper;import com.lc.pojo.User;import org.apache.ibatis.annotations.Param;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class UserController &#123;    @Autowired    private UserMapper userMapper;    @RequestMapping(&quot;&#x2F;list&quot;)    public List&lt;User&gt; queryUserList()&#123;        List&lt;User&gt; list &#x3D; userMapper.queryUserList();        for (User user : list) &#123;            System.out.println(user);        &#125;        return list;    &#125;    @RequestMapping(&quot;&#x2F;queryUser&#x2F;&#123;id&#125;&quot;)    public User queryUserById(@PathVariable(&quot;id&quot;) int id)&#123;        return userMapper.queryUserById(id);    &#125;    @RequestMapping(&quot;&#x2F;addUser&quot;)    public String addUser()&#123;        int res &#x3D; userMapper.addUser(new User(10,&quot;增加&quot;,&quot;123456&quot;));        if (res &#x3D;&#x3D; 1)            return &quot;OK&quot;;        else            return &quot;ERROR&quot;;    &#125;    @RequestMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)    public String deleteUser(@PathVariable(&quot;id&quot;) int id)&#123;        int res &#x3D; userMapper.deleteUser(id);        if (res &#x3D;&#x3D; 1)            return &quot;OK&quot;;        else            return &quot;ERROR&quot;;    &#125;    @RequestMapping(&quot;&#x2F;updateUser&quot;)    public String updateUser()&#123;        int res &#x3D; userMapper.updateUser(new User(10,&quot;xxxx&quot;,&quot;111111&quot;));        if (res &#x3D;&#x3D; 1)            return &quot;OK&quot;;        else            return &quot;ERROR&quot;;    &#125;&#125;</code></pre><p><strong>启动项目访问进行测试！</strong></p><h2 id="SpringSecurity-安全"><a href="#SpringSecurity-安全" class="headerlink" title="SpringSecurity(安全)"></a>SpringSecurity(安全)</h2><p>在 Web  开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p><p>市面上存在比较有名的：Shiro，Spring Security ！</p><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p><p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web  应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security  框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP  等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control  List，ACL），可以对应用中的领域对象进行细粒度的控制。</p><h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><p>新建一个初始的springboot项目web模块，thymeleaf模块</p><p>导入静态资源</p><p>controller实现跳转 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RouterController &#123;   @RequestMapping(&#123;&quot;&#x2F;&quot;,&quot;&#x2F;index&quot;&#125;)   public String index()&#123;       return &quot;index&quot;;  &#125;   @RequestMapping(&quot;&#x2F;toLogin&quot;)   public String toLogin()&#123;       return &quot;views&#x2F;login&quot;;  &#125;   @RequestMapping(&quot;&#x2F;level1&#x2F;&#123;id&#125;&quot;)   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;       return &quot;views&#x2F;level1&#x2F;&quot;+id;  &#125;   @RequestMapping(&quot;&#x2F;level2&#x2F;&#123;id&#125;&quot;)   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;       return &quot;views&#x2F;level2&#x2F;&quot;+id;  &#125;   @RequestMapping(&quot;&#x2F;level3&#x2F;&#123;id&#125;&quot;)   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;       return &quot;views&#x2F;level3&#x2F;&quot;+id;  &#125;&#125;</code></pre><h3 id="认识SpringSecurity"><a href="#认识SpringSecurity" class="headerlink" title="认识SpringSecurity"></a>认识SpringSecurity</h3><p>Spring Security  是针对Spring项目的安全框架，也是Spring  Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入  spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p><p>记住几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li><a href="https://github.com/EnableWebSecurity">@EnableWebSecurity</a>：开启WebSecurity模式</li></ul><p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p><p><strong>“认证”（Authentication）</strong></p><p>身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。</p><p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p><p> <strong>“授权” （Authorization）</strong></p><p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p><p>这个概念是通用的，而不是只在Spring Security 中存在。</p><h3 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h3><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p><p>引入 Spring Security 模块</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>编写 Spring Security 配置类</p><p>参考官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> </p><p>查看我们自己项目中的版本，找到对应的帮助文档：</p><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>  #servlet-applications 8.16.4</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425113500453.png" alt="image-20230425113500453"></p><p>编写基础配置类</p><pre class="line-numbers language-none"><code class="language-none">package com.kuang.config;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecurity &#x2F;&#x2F; 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    &#x2F;&#x2F;授权   @Override   protected void configure(HttpSecurity http) throws Exception &#123;  &#125;&#125;</code></pre><p>定制请求的授权规则</p><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;授权@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;   &#x2F;&#x2F; 定制请求的授权规则   &#x2F;&#x2F; 首页所有人可以访问   http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()  .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)  .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)  .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);&#125;</code></pre><p>测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p><p>在configure()方法中加入以下配置，开启自动配置的登录功能！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 开启自动配置的登录功能&#x2F;&#x2F; &#x2F;login 请求来到登录页&#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败&#x2F;&#x2F;没有权限默认到登陆页面，需要开启登陆页面http.formLogin();</code></pre><p>测试一下：发现，没有权限的时候，会跳转到登录的页面！</p><p>查看刚才登录页的注释信息；</p><p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....   auth.inMemoryAuthentication()          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)          .and()          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)          .and()          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125;</code></pre><p>测试，我们可以使用这些账号登录进行测试！发现会报错！</p><p>There is no PasswordEncoder mapped for the id “null”</p><p>原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....   &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。   &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密   &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)          .and()          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)          .and()          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125;</code></pre><p>测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p><h3 id="完整配置代码"><a href="#完整配置代码" class="headerlink" title="完整配置代码"></a>完整配置代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;   &#x2F;&#x2F;定制请求的授权规则   @Override   protected void configure(HttpSecurity http) throws Exception &#123;       http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()      .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)      .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)      .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);       &#x2F;&#x2F;开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！           &#x2F;&#x2F; &#x2F;login 请求来到登录页           &#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败       http.formLogin()          .usernameParameter(&quot;username&quot;)          .passwordParameter(&quot;password&quot;)          .loginPage(&quot;&#x2F;toLogin&quot;)          .loginProcessingUrl(&quot;&#x2F;login&quot;); &#x2F;&#x2F; 登陆表单提交请求       &#x2F;&#x2F;开启自动配置的注销的功能           &#x2F;&#x2F; &#x2F;logout 注销请求           &#x2F;&#x2F; .logoutSuccessUrl(&quot;&#x2F;&quot;); 注销成功来到首页       http.csrf().disable();&#x2F;&#x2F;关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求       http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);       &#x2F;&#x2F;记住我       http.rememberMe().rememberMeParameter(&quot;remember&quot;);  &#125;   &#x2F;&#x2F;定义认证规则   @Override   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;       &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....       &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。       &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密       &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);  &#125;&#125;</code></pre><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><h3 id="什么是Shiro"><a href="#什么是Shiro" class="headerlink" title="什么是Shiro"></a>什么是Shiro</h3><ul><li>Apache Shiro是一个Java的安全（权限）框架。</li><li>Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。</li><li>Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。</li><li>下载地址: <a href="http://shiro.apache.org/">http://shiro.apache.org/</a></li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>Authentication:身份认证、登录，验证用户是不是拥有相应的身份;</li><li>Authorization: 授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如:验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!</li><li>Session Manager:会话管理，即用户登录后就是第一次会话，在没有退出之前，它的所有信息都在会话中;会话可以是普通的JavaSE环境，也可以是Web环境;</li><li>Cryptography:加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储;</li><li>Web Support: Web支持，可以非常容易的集成到Web环境;</li><li>Caching:缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，这样可以提高效率</li><li>Concurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去</li><li>Testing:提供测试支持;</li><li>Run As:允许一个用户假装为另一个用户(如果他们允许）的身份进行访问;</li><li>Remember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</li></ul><h3 id="三大核心组件"><a href="#三大核心组件" class="headerlink" title="三大核心组件"></a>三大核心组件</h3><p>Shiro有三大核心组件，即<strong>Subject、SecurityManager和Realm</strong></p><p><strong>Subject</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为认证主体。应用代码直接交互的对象是Subject,Subject代表了当前的用户。包含Principals和Credentials两个信息。</p><p>Pricipals:代表身份。可以是用户名、邮件、手机号码等等，用来标识一个登陆主题的身份。</p><p>Credentials:代表凭证。常见的有密码、数字证书等等。</p><p>也就是说两者代表了认证的内容，最常见就是用户名密码了。用Shiro进行身份认证，其中就包括主体认证。</p></blockquote><p><strong>SecurityManager</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为安全管理员。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager, Subject相当于是一个门面，而SecurityManager才是真正的执行者。它负责与Shiro 的其他组件进行交互。</p></blockquote><p><strong>Realm</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>是一个域。充当了Shiro与应用安全数据间的“桥梁”。</p><p>Shiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能过进行，可以把Realm看成DataSource，即安全数据源。</p></blockquote><h3 id="内部架构"><a href="#内部架构" class="headerlink" title="内部架构"></a>内部架构</h3><ul><li>Subject: 主体，主体可以是任何可以与应用交互的“用户”</li><li>SecurityManager: 是Shiro的核心，所有具体的交互都需通过SecurityManager进行，它管理所有的Subject，且负责进行认证授权，会话，及缓存的管理。</li><li>Authenticator:负责主体认证。当用户尝试登录时，该逻辑被Authenticatior执行。Authenticator知道如何与一个或多个Realm协调来存储相关的用户。从Realm中获得的数据被用来验证用户的身份来保证用户确实是他们所说的他们是谁。</li><li>Autentication Strategy:如果不止一个Realm被配置，其会协调这些Realm来决定身份认证尝试成功或失败下的条件（比如，如果一个Realm成功，而其他的失败，是否该尝试成功？）</li><li>Authorizer:负责在应用程序中决定用户的访问控制。它是一种最终判定用户是否被允许做某事的机制。与Authenticator相似，Authorizer也知道如何协调多个后台数据源来访问角色恶化权限信息。Authorizer使用该信息来准确度的决定用户是否被允许执行给定的动作。</li><li>SessionManager：知道如何去创建及管理用户Session生命周期来为所有环境下的用户提供一个强健的session体验。</li><li>SessionDAO：代表SessionManager执行Session持久化操作。允许数据存储**入到会员管理的基础之中。</li><li>CacheManager:创建并管理其他Shiro组件使用的Cache实例声明周期。因为Shiro能访问许多后台数据源，由于身份验证、授权和会话管理，缓存在框架中一直是一流 的架构功能，用来在通过还是使用这些数据源时提高性能。</li><li>Cryptograhy：是对企业安全框架的一个自然的补充。密码模块，shrio提高了一些常见的加密组件用于密码加密，解密等。</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;    &lt;artifactid&gt;shiro-spring&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="什么是Swagger"><a href="#什么是Swagger" class="headerlink" title="什么是Swagger"></a>什么是Swagger</h3><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 &#x3D;&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><p><strong>前后端分离</strong></p><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互</li><li>前后端相对独立且松耦合</li></ul><p><strong>产生的问题</strong></p><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><h3 id="Springboot集成Swagger"><a href="#Springboot集成Swagger" class="headerlink" title="Springboot集成Swagger"></a>Springboot集成Swagger</h3><p>需要如下两个jar包</p><ul><li><strong>Springfox-swagger2</strong></li><li>swagger-springmvc</li></ul><p>同时要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><p>1、新建一个SpringBoot-web项目</p><p>2、添加Maven依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>3、编写HelloController，测试确保运行成功！</p><p>4、要使用Swagger，我们需要编写一个配置类 SwaggerConfig 来配置 Swagger</p><pre class="line-numbers language-none"><code class="language-none">@Configuration &#x2F;&#x2F;配置类@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置public class SwaggerConfig &#123;  &#125;</code></pre><p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114030387.png" alt="image-20230425114030387"></p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td><a href="https://github.com/Api">@Api</a>(tags &#x3D; “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td><a href="https://github.com/ApiOperation">@ApiOperation</a>(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td><a href="https://github.com/ApiModel">@ApiModel</a>(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td><a href="https://github.com/ApiModelProperty">@ApiModelProperty</a>(value &#x3D; “xxx属性说明”,hidden &#x3D; true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td><a href="https://github.com/ApiParam">@ApiParam</a>(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似<a href="https://github.com/ApiModelProperty">@ApiModelProperty</a></td></tr></tbody></table><p>我们也可以给请求的接口配置一些注释</p><pre class="line-numbers language-none"><code class="language-none">@ApiOperation(&quot;xiao的接口&quot;)@PostMapping(&quot;&#x2F;xiao&quot;)@ResponseBodypublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;   return username;&#125;</code></pre><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC【Remote Procedure  Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114416458.png" alt="image-20230425114416458"></p><p><strong>步骤解析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114433842.png" alt="image-20230425114433842"></p><p>RPC两个核心模块：通讯，序列化。</p><p>序列化：数据传输需要转换</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<p>操作系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91.html</url>
      
        <content type="html"><![CDATA[<p>计网</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>数据结构与算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringCloud.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringCloud.html</url>
      
        <content type="html"><![CDATA[<h4 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h4><p>🤤基础篇</p><ul><li>认识微服务</li><li>服务拆分</li><li>远程调用</li><li>Eureka</li><li>Ribbon</li><li>Nacos</li><li>Feign</li><li>Gateway</li><li>RabbitMQ</li><li>Elasticsearch</li></ul><p>💻高级篇</p><ul><li>JMeter</li><li>Sentinel</li><li>Seata</li><li>Redis</li><li>。。。</li></ul><h4 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h4><h5 id="单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署"><a href="#单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署" class="headerlink" title="单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署"></a>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901083809.png" alt="img"></p><p>优点：架构简单，部署成本较低</p><p>缺点：耦合度高（维护困难、升级困难）</p><h5 id="分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务"><a href="#分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务" class="headerlink" title="分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务"></a>分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901092921.png" alt="img"></p><p>优点：降低服务耦合，有利于服务升级和拓展</p><p>缺点：调用服务关系错综复杂</p><p>分布式架构虽然降低了服务耦合，但是服务拆分时也会有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>所以需要一套行之有效的标准来约束分布式架构</p><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>微服务的架构特征：</p><ul><li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</p></li><li><p>自治：团队独立、技术独立、数据独立，独立部署和交付</p></li><li><p>面向服务：服务提供统一标准的接口，与语言和技术无关</p></li><li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p><p><img src="https://cdn.xn2001.com/img/2022/202205162352847.png" alt="img"></p></li></ul><p>微服务的上述特征其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><h5 id="因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法"><a href="#因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法" class="headerlink" title="因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法"></a>因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法</h5><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901083717.png" alt="img"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901084050.png" alt="img"></p><h4 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h4><p><img src="https://cdn.xn2001.com/img/2021/20210901092925.png" alt="需要学习的微服务知识内容"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901084131.png" alt="技术栈"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901090737.png" alt="自动化部署"></p><h4 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h4><p><img src="https://cdn.xn2001.com/img/2021/20210901090726.png" alt="img"></p><h4 id="服务拆分："><a href="#服务拆分：" class="headerlink" title="服务拆分："></a>服务拆分：</h4><pre class="line-numbers language-none"><code class="language-none">代码参考：Gitee：https:&#x2F;&#x2F;gitee.com&#x2F;xn2001&#x2F;cloudcode&#x2F;tree&#x2F;master&#x2F;01-cloud-demo</code></pre><p><strong>服务拆分注意事项</strong></p><p>单一职责：不同微服务，不要重复开发相同业务</p><p>数据独立：不要访问其它微服务的数据库</p><p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090745.png" alt="img"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li><li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li><li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li></ul><p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615132840054.png" alt="image-20220615132840054"></p><p>启动完成后，访问 <a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901090757.png" alt="img"></p><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><p>正如上面的服务拆分要求中所提到，</p><pre class="line-numbers language-none"><code class="language-none">订单服务如果需要查询用户信息，**只能调用用户服务的 Restful 接口**，不能查询用户数据库</code></pre><p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615133219788.png" alt="image-20220615133219788"></p><p>发送请求，自动序列化为 Java 对象。</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615133314248.png" alt="image-20220615133314248"></p><p>启动完成后，访问：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615132930294.png" alt="image-20220615132930294"></p><p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用关系</p><ul><li>服务提供者：暴露接口给其它微服务调用</li><li>服务消费者：调用其它微服务提供的接口</li></ul><p>服务调用中可能出现的问题</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615134720536.png" alt="image-20220615134720536"></p><h4 id="Eureka的作用："><a href="#Eureka的作用：" class="headerlink" title="Eureka的作用："></a>Eureka的作用：</h4><p>提供一个注册中心，将所有的服务进行注册，需要时动态调用，每30秒检测一次服务是否正常</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090919.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901090919.png"><img src="https://cdn.xn2001.com/img/2021/20210901090919.png" alt="img"></a></p><p><strong>order-service 如何得知 user-service 实例地址？</strong></p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li></ul><p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p><p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p><p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><p>接下来我们动手实践的步骤包括</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090932.png" alt="img"></p><h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p>搭建 eureka-server</p><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>编写启动类</strong></p><p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class,args);    &#125;&#125;</code></pre><p><strong>编写配置文件</strong></p><p>编写一个 application.yml 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka</code></pre><p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p><p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615144833798.png" alt="image-20220615144833798"></p><p>到这 服务注册中心就搭建完成了</p><p>服务注册</p><pre><code>将 user-service、order-service 都注册到 eureka</code></pre><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 client</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">在启动类上添加注解：@EnableEurekaClient</code></pre><p>在 application.yml 文件，添加下面的配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:  application:      #name：orderservice    name: userserviceeureka:  client:    service-url:       defaultZone: http:127.0.0.1:10086&#x2F;eureka</code></pre><p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615151100786.png" alt="image-20220615151100786"></p><p>可以看到eureka本身和另外两个服务都注册成功</p><p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091005.png" alt="img"></p><p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615151554375.png"></p><h5 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h5><pre class="line-numbers language-none"><code class="language-none">在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</code></pre><p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@LoadBalancedpublic RestTemplate restTemplate()&#123;    return new RestTemplate();&#125;</code></pre><p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615175754571.png" alt="image-20220615175754571"></p><p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p><h5 id="SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。"><a href="#SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。" class="headerlink" title="SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。"></a>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901091242.png" alt="img"></p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>进入源码跟踪查看底层原理：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091323.png" alt="img"></p><p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，即 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p><p>继续跟入 <code>execute()</code> 方法：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091330.png" alt="img"></p><ul><li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li><li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li></ul><p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091345.png" alt="img"></p><p>我们继续跟入：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091355.png" alt="img"></p><p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091414.png" alt="img"></p><p>我们看看这个 <code>rule</code> 是谁：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091432.png" alt="img"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091442.png" alt="img"></p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p><p>基本流程如下：</p><ul><li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><p><img src="https://cdn.xn2001.com/img/2021/20210901091755.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901091755.png"><img src="https://cdn.xn2001.com/img/2021/20210901091755.png" alt="img"></a></p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091811.png" alt="img"></p><p>不同规则的含义如下：</p><table><thead><tr><th align="left"><strong>内置负载均衡规则类</strong></th><th align="left"><strong>规则描述</strong></th></tr></thead><tbody><tr><td align="left">RoundRobinRule</td><td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule  规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td align="left">WeightedResponseTimeRule</td><td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td align="left"><strong>ZoneAvoidanceRule</strong></td><td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td align="left">BestAvailableRule</td><td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td align="left">RandomRule</td><td align="left">随机选择一个可用的服务器。</td></tr><tr><td align="left">RetryRule</td><td align="left">重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p><h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615193912474.png" alt="image-20220615193912474"></p><p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">userservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre><p><strong>注意</strong>：一般情况下都采用默认的负载均衡规则，不做修改。</p><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091850.png" alt="img"></p><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">ribbon:  eager-load:    enabled: true    clients:     -userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;-&quot;隔开</code></pre><h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，功能相对eureka会有提升</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091857.png" alt="img"></p><p>解压启动 Nacos，详细请看 安装指南</p><p>由于nacos默认采用集群启动， 所以需要使用如下命令进行单机启动</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd -m standalone</code></pre><p>访问：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a> 就可以看到nocas管理界面了</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091904.png" alt="img"></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。<strong>引入依赖</strong></p><p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p><p>如果之前引入过eureka的依赖，需要注释掉~</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.6.RELEASE&lt;&#x2F;version&gt;    &lt;type&gt;pom&lt;&#x2F;type&gt;    &lt;scope&gt;import&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre><p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>配置nacos地址</strong></p><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: 127.0.0.1:8848</code></pre><p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091918.png" alt="img"></p><p>浏览器访问：<a href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p><h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091928.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901091928.png"><img src="https://cdn.xn2001.com/img/2021/20210901091928.png" alt="img"></a></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091937.png" alt="img"></p><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称 HZ杭州</code></pre><p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p><pre class="line-numbers language-none"><code class="language-none">-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH</code></pre><p><img src="https://cdn.xn2001.com/img/2021/20210901091947.png" alt="img"></p><p>查看 nacos 控制台</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091957.png" alt="img"></p><h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic IRule iRule()&#123;    &#x2F;&#x2F;默认为轮询规则，这里自定义为随机规则    return new NacosRule();&#125;</code></pre><p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">userservice:  ribbon:    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则</code></pre><p>然后，再对 orderservice 配置集群。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称</code></pre><p>现在我启动了四个服务，分别是：</p><ul><li>orderservice - HZ</li><li>userservice - HZ</li><li>userservice1 - HZ</li><li>userservice2 - SH</li></ul><p>访问地址：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p><p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p><p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092012.png" alt="img"></p><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p><p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092020.png" alt="img"></p><p>在弹出的编辑窗口，修改权重</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092026.png" alt="img"></p><p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到  0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li><p>Nacos 中可以有多个 namespace</p></li><li><p>namespace 下可以有 group、service 等</p></li><li><p>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</p></li><li><h2 id="环境隔离-1"><a href="#环境隔离-1" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li></ul></li></ul><p><img src="https://cdn.xn2001.com/img/2021/20210901092032.png" alt="img"></p><h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092038.png" alt="img"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092050.png" alt="img"></p><p>然后，填写表单：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092059.png" alt="img"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092114.png" alt="img"></p><h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID</code></pre><p>重启 order-service 后，访问控制台。</p><p><strong>public</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092143.png" alt="img"></p><p><strong>dev</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092130.png" alt="img"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092138.png" alt="img"></p><h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p><ul><li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li></ul><p>配置一个服务实例为永久实例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      discovery:        ephemeral: false # 设置为非临时实例</code></pre><p>另外，Nacos 集群**默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p><h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092150.png" alt="img"></p><p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p><h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092159.png" alt="img"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092206.png" alt="img"></p><p><strong>注意</strong>：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。</p><h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092215.png" alt="img"></p><p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092223.png" alt="img"></p><p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p><p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092228.png" alt="img"></p><p><strong>引入 nacos-config 依赖</strong></p><p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>添加 bootstrap.yml</strong></p><p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yaml # 文件后缀名</code></pre><p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092237.png" alt="img"></p><p>使用代码来验证是否拉取成功</p><p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)private String dateformat;@GetMapping(&quot;now&quot;)public String now()&#123;    &#x2F;&#x2F;格式化时间    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));&#125;</code></pre><p><img src="https://cdn.xn2001.com/img/2021/20210901092243.png" alt="img"></p><p>启动服务后，访问：<a href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092251.png" alt="img"></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p><h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092258.png" alt="img"></p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p><p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@Component@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)public class PatternProperties &#123;    public String dateformat;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate PatternProperties patternProperties;@GetMapping(&quot;now2&quot;)public String now2()&#123;    &#x2F;&#x2F;格式化时间    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));&#125;</code></pre><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p><p><strong>添加一个环境共享配置</strong></p><p>我们在 nacos 中添加一个 userservice.yaml 文件：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092323.png" alt="img"></p><p><strong>在 user-service 中读取共享配置</strong></p><p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092314.png" alt="img"></p><p>在 user-service 服务中，修改 UserController，添加一个方法：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092331.png" alt="img"></p><p><strong>运行两个 UserApplication，使用不同的profile</strong></p><p>修改 UserApplication2 这个启动项，改变其profile值：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092345.png" alt="img"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092338.png" alt="img"></p><p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p><p>启动 UserApplication 和 UserApplication2</p><p>访问地址：<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092400.png" alt="img"></p><p>访问地址：<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092419.png" alt="img"></p><p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p><p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p><p>通过下面的两种方式来指定：</p><ul><li>extension-configs</li><li>shared-configs</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:   cloud:    nacos:      config:        file-extension: yaml # 文件后缀名        extends-configs: # 多微服务间共享的配置列表          - dataId: common.yaml # 要共享的配置文件id</code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:   cloud:    nacos:      config:        file-extension: yaml # 文件后缀名        shared-configs: # 多微服务间共享的配置列表          - dataId: common.yaml # 要共享的配置文件id</code></pre><h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092501.png" alt="img"></p><p>更细致的配置</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092520.png" alt="img"></p><h1 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h1><h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p><img src="https://cdn.xn2001.com/img/2021/202108181959897.png" alt="img"></p><p>其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。</p><p><img src="https://cdn.xn2001.com/img/2021/202108182000220.png" alt="img"></p><p>三个 Nacos 节点的地址</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。</p><p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;config_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) DEFAULT NULL,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;c_desc&#96; varchar(256) DEFAULT NULL,  &#96;c_use&#96; varchar(64) DEFAULT NULL,  &#96;effect&#96; varchar(64) DEFAULT NULL,  &#96;type&#96; varchar(64) DEFAULT NULL,  &#96;c_schema&#96; text,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_aggr&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_beta&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_tag&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_tags_relation&#96; (  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;nid&#96;),  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;group_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;his_config_info&#96; (  &#96;id&#96; bigint(64) unsigned NOT NULL,  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,  &#96;data_id&#96; varchar(255) NOT NULL,  &#96;group_id&#96; varchar(128) NOT NULL,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL,  &#96;md5&#96; varchar(32) DEFAULT NULL,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;src_user&#96; text,  &#96;src_ip&#96; varchar(50) DEFAULT NULL,  &#96;op_type&#96; char(10) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;nid&#96;),  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),  KEY &#96;idx_did&#96; (&#96;data_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;tenant_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;CREATE TABLE &#96;tenant_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;CREATE TABLE &#96;users&#96; (&#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,&#96;password&#96; varchar(500) NOT NULL,&#96;enabled&#96; boolean NOT NULL);CREATE TABLE &#96;roles&#96; (&#96;username&#96; varchar(50) NOT NULL,&#96;role&#96; varchar(50) NOT NULL,UNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE);CREATE TABLE &#96;permissions&#96; (    &#96;role&#96; varchar(50) NOT NULL,    &#96;resource&#96; varchar(255) NOT NULL,    &#96;action&#96; varchar(8) NOT NULL,    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE);INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);</code></pre><h2 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h2><p>进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p><p><img src="https://cdn.xn2001.com/img/2021/202108182004564.png" alt="img"></p><p>添加内容</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:8845127.0.0.1.8846127.0.0.1.8847</code></pre><p>然后修改 application.properties 文件，添加数据库配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.datasource.platform&#x3D;mysqldb.num&#x3D;1db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTCdb.user.0&#x3D;rootdb.password.0&#x3D;123456</code></pre><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"></code></pre><p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://cdn.xn2001.com/img/2021/202108182004103.png" alt="img"></p><p>然后分别修改三个文件夹中的 application.properties，</p><p>nacos1</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8845</code></pre><p>nacos2</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8846</code></pre><p>nacos3</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8847</code></pre><p>然后分别启动三个 nacos</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd</code></pre><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">upstream nacos-cluster &#123;    server 127.0.0.1:8845;server 127.0.0.1:8846;server 127.0.0.1:8847;&#125;server &#123;    listen       80;    server_name  localhost;    location &#x2F;nacos &#123;        proxy_pass http:&#x2F;&#x2F;nacos-cluster;    &#125;&#125;</code></pre><p>启动 nginx，在浏览器访问：<a href="http://localhost/nacos">http://localhost/nacos</a></p><p>在代码中的 application.yml 文件配置改为如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:80 # Nacos地址</code></pre><p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。</p><h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092616.png" alt="img"></p><ul><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ul><p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092639.png" alt="img"></p><h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p><p>我们在 order-service 引入 feign 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>添加注解</strong></p><p>在 order-service 启动类添加注解开启 Feign</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220710135442258.png" alt="image-20220710135442258"></p><p><strong>请求接口</strong></p><p>在 order-service 中新建一个接口，内容如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.order.clients;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p><p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p><p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p><p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p><p><strong>测试</strong></p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate UserClient userClient;public Order queryOrderById(Long orderId) &#123;    &#x2F;&#x2F; 1.查询订单    Order order &#x3D; orderMapper.findById(orderId);    &#x2F;&#x2F; 2.用feign进行远程调用，替代之前的RestTemplate    User user &#x3D; userClient.findById(order.getUserId());    order.setUser(user);    &#x2F;&#x2F; 4.返回    return order;&#125;</code></pre><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign.Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p><p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:    client:    config:       userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别 </code></pre><p><strong>也可以针对所有服务</strong>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:    client:    config:       default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别</code></pre><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul><p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DefaultFeignConfiguration  &#123;    @Bean    public Logger.Level feignLogLevel()&#123;        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC    &#125;&#125;</code></pre><p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) </code></pre><p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) </code></pre><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p><ul><li><strong>URLConnection</strong>：默认实现，不支持连接池</li><li><strong>Apache HttpClient</strong> ：支持连接池</li><li><strong>OKHttp</strong>：支持连接池</li></ul><p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p><p>另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。</p><p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p><p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>配置连接池</strong></p><p>在 order-service 的 application.yml 中添加配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数</code></pre><p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220712153433953.png" alt="image-20220712153433953"></p><p>Debug 方式启动 order-service  服务，可以看到这里的 client，底层就是 HttpClient</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092737.png" alt="img"></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p><p>2）Feign 客户端、Controller 都集成该接口</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092803.png"><img src="https://cdn.xn2001.com/img/2021/20210901092803.png" alt="img"></a></p><p>优点</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li></ul><h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092811.png"><img src="https://cdn.xn2001.com/img/2021/20210901092811.png" alt="img"></a></p><p>接下来我们就用该方法在代码中实现</p><p><strong>首先创建一个 module，命名为 feign-api</strong></p><p><a href="https://cdn.xn2001.com/img/2021/20210901092835.png"><img src="https://cdn.xn2001.com/img/2021/20210901092835.png" alt="img"></a></p><p>在 feign-api 中然后引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>order-service中 的 UserClient、User 都复制到 feign-api 项目中</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092848.png"><img src="https://cdn.xn2001.com/img/2021/20210901092848.png" alt="img"></a></p><p>接下来在 order-service 中使用 feign-api</p><p>由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service  中引入 feign-api</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.xn2001.feign&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>修改注解</strong></p><p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p><p>修改 order-service 启动类上的 <code>@EnableFeignClients</code> 注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableFeignClients(basePackages &#x3D; &quot;com.xn2001.feign.clients&quot;)</code></pre><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>代码参考：</p><p>Gitee：<a href="https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway">https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway</a></p><p>GitHub：<a href="https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway">https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway</a></p></blockquote><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring  Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API  路由管理方式。</p><p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p><a href="https://cdn.xn2001.com/img/2021/20210901092857.png"><img src="https://cdn.xn2001.com/img/2021/20210901092857.png" alt="img"></a></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在 SpringCloud 中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol><li>创建 SpringBoot 工程 gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>创建 application.yml 文件，内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求</code></pre><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p><p>重启网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href="http://userservice/user/1">http://userservice/user/1</a></p><p><a href="https://cdn.xn2001.com/img/2021/202108220125749.png"><img src="https://cdn.xn2001.com/img/2021/202108220125749.png" alt="img"></a></p><p>多个 predicates 的话，要同时满足规则，下文有例子。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><a href="https://cdn.xn2001.com/img/2021/202108220127419.png"><img src="https://cdn.xn2001.com/img/2021/202108220127419.png" alt="img"></a></p><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p><p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p></blockquote><p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">predicates:  - Path&#x3D;&#x2F;order&#x2F;**  - After&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</code></pre><p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><a href="https://cdn.xn2001.com/img/2021/202108220133487.png"><img src="https://cdn.xn2001.com/img/2021/202108220133487.png" alt="img"></a></p><p>Spring提供了31种不同的路由过滤器工厂。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p></blockquote><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><p>下面我们以 AddRequestHeader 为例：</p><p><a href="https://cdn.xn2001.com/img/2021/202108220139913.png"><img src="https://cdn.xn2001.com/img/2021/202108220139913.png" alt="img"></a></p><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p><p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求          filters:            - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre><p>如何验证，我们修改 userservice 中的一个接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value &#x3D; &quot;sign&quot;, required &#x3D; false) String sign) &#123;    log.warn(sign);    return userService.queryById(id);&#125;</code></pre><p>重启两个服务，访问：<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p><p>可以看到控制台打印出了这个请求头</p><p><a href="https://cdn.xn2001.com/img/2021/202108220145565.png"><img src="https://cdn.xn2001.com/img/2021/202108220145565.png" alt="img"></a></p><p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      default-filters:        - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p><p><strong>需求</strong>：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p><ul><li>参数中是否有 authorization</li><li>authorization 参数值是否为 admin</li></ul><p>如果同时满足则放行，否则拦截。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class AuthorizeFilter implements GlobalFilter, Ordered &#123;    &#x2F;&#x2F; 测试：http:&#x2F;&#x2F;localhost:10010&#x2F;order&#x2F;101?authorization&#x3D;admin    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        &#x2F;&#x2F; 获取第一个 authorization 参数        String authorization &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;authorization&quot;);        if (&quot;admin&quot;.equals(authorization))&#123;            &#x2F;&#x2F; 放行            return chain.filter(exchange);        &#125;        &#x2F;&#x2F; 设置拦截状态码信息        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);        &#x2F;&#x2F; 设置拦截        return exchange.getResponse().setComplete();    &#125;    &#x2F;&#x2F; 设置过滤器优先级，值越低优先级越高    &#x2F;&#x2F; 也可以使用 @Order 注解    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;</code></pre><h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p><p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p><p><a href="https://cdn.xn2001.com/img/2021/202108230002747.png"><img src="https://cdn.xn2001.com/img/2021/202108230002747.png" alt="img"></a></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li><li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li><li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#39;[&#x2F;**]&#39;:            allowedOrigins: # 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
