<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ActiveMQ学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ActiveMQ.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ActiveMQ.html</url>
      
        <content type="html"><![CDATA[<p>ActiveMQ</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git.html</url>
      
        <content type="html"><![CDATA[<p>Git</p>]]></content>
      
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Elasticsearch.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Elasticsearch.html</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JDBC.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JDBC.html</url>
      
        <content type="html"><![CDATA[<p>JDBC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM.html</url>
      
        <content type="html"><![CDATA[<p>JVM</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaWeb.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaWeb.html</url>
      
        <content type="html"><![CDATA[<p>JavaWeb</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaSE.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaSE.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章Java基本语法"><a href="#第一章Java基本语法" class="headerlink" title="第一章Java基本语法"></a>第一章Java基本语法</h1><h2 id="1-1关键字与标识符"><a href="#1-1关键字与标识符" class="headerlink" title="1.1关键字与标识符"></a>1.1关键字与标识符</h2><h3 id="1-1-1java关键字的使用"><a href="#1-1-1java关键字的使用" class="headerlink" title="1.1.1java关键字的使用"></a>1.1.1java关键字的使用</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p>特点：关键字中所字母都为小写</p><p>具体哪些关键字：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161343448.png" alt="image-20230211161343448"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161347035.png" alt="image-20230211161347035"></p><h3 id="1-1-2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"><a href="#1-1-2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。" class="headerlink" title="1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"></a>1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。</h3><p>具体哪些保留字：goto 、const</p><p>注意：自己命名标识符时要避免使用这些保留字</p><h3 id="1-1-3-标识符的使用"><a href="#1-1-3-标识符的使用" class="headerlink" title="1.1.3.标识符的使用"></a>1.1.3.标识符的使用</h3><p>定义：凡是自己可以起名字的地方都叫标识符。</p><p>涉及到的结构：</p><p>包名、类名、接口名、变量名、方法名、常量名</p><p>规则：(必须要遵守。否则，编译不通过)</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161451423.png" alt="image-20230211161451423"></p><p>规范：（可以不遵守，不影响编译和运行。但是要求遵守）</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161457024.png" alt="image-20230211161457024"></p><p>注意点：</p><p>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p><h2 id="1-2变量的使用"><a href="#1-2变量的使用" class="headerlink" title="1.2变量的使用"></a>1.2变量的使用</h2><h3 id="1-2-1变量的分类"><a href="#1-2-1变量的分类" class="headerlink" title="1.2.1变量的分类"></a>1.2.1变量的分类</h3><p>按数据类型分类</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211161545642.png" alt="image-20230211161545642"></p><h3 id="1-2-2定义变量的格式"><a href="#1-2-2定义变量的格式" class="headerlink" title="1.2.2定义变量的格式"></a>1.2.2定义变量的格式</h3><p>数据类型 变量名 &#x3D; 变量值;</p><p>或</p><p>数据类型 变量名;</p><p>变量名 &#x3D; 变量值;</p><h3 id="1-2-3变量使用的注意点"><a href="#1-2-3变量使用的注意点" class="headerlink" title="1.2.3变量使用的注意点"></a>1.2.3变量使用的注意点</h3><p>① 变量必须先声明，后使用</p><p>② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</p><p>③ 同一个作用域内，不可以声明两个同名的变量</p><h3 id="1-2-4基本数据类型变量间运算规则"><a href="#1-2-4基本数据类型变量间运算规则" class="headerlink" title="1.2.4基本数据类型变量间运算规则"></a>1.2.4基本数据类型变量间运算规则</h3><ul><li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p></li><li><p>自动类型转换(只涉及7种基本数据类型）</p></li></ul><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double</p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p><ul><li>强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。</li></ul><ol><li>需要使用强转符：()</li><li>注意点：强制类型转换，可能导致精度损失。</li></ol><ul><li>String与8种基本数据类型间的运算</li></ul><ol><li>String属于引用数据类型,翻译为：字符串</li><li>声明String类型变量时，使用一对””</li><li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</li><li>运算的结果仍然是String类型</li></ol><p>避免：</p><p>String s &#x3D; 123;&#x2F;&#x2F;编译错误</p><p>String s1 &#x3D; “123”;</p><p>int i &#x3D; (int)s1;&#x2F;&#x2F;编译错误</p><h2 id="1-3进制"><a href="#1-3进制" class="headerlink" title="1.3进制"></a>1.3进制</h2><h3 id="1-3-1编程中涉及的进制及表示方式："><a href="#1-3-1编程中涉及的进制及表示方式：" class="headerlink" title="1.3.1编程中涉及的进制及表示方式："></a>1.3.1编程中涉及的进制及表示方式：</h3><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162011508.png" alt="image-20230211162011508"></p><h3 id="1-3-2二进制的使用说明："><a href="#1-3-2二进制的使用说明：" class="headerlink" title="1.3.2二进制的使用说明："></a>1.3.2二进制的使用说明：</h3><ul><li>计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。</li><li>二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。</li><li>原码、反码、补码的说明：</li></ul><p>正数：三码合一</p><p>负数：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162056385.png" alt="image-20230211162056385"></p><h3 id="1-3-3进制间的互相转换"><a href="#1-3-3进制间的互相转换" class="headerlink" title="1.3.3进制间的互相转换"></a>1.3.3进制间的互相转换</h3><ul><li><p>图示：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162207149.png" alt="image-20230211162207149"></p></li><li><p>图示二进制转换为十进制：</p></li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162235888.png" alt="image-20230211162235888"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162240553.png" alt="image-20230211162240553"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162248195.png" alt="image-20230211162248195"></p><ul><li>图示十进制转换为二进制：</li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162310209.png" alt="image-20230211162310209"></p><ul><li>二进制与八进制、十六进制间的转换</li></ul><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162324210.png" alt="image-20230211162324210"></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20230211162329667.png" alt="image-20230211162329667"></p><h2 id="1-4运算符"><a href="#1-4运算符" class="headerlink" title="1.4运算符"></a>1.4运算符</h2><h3 id="1-4-1算术运算符"><a href="#1-4-1算术运算符" class="headerlink" title="1.4.1算术运算符"></a>1.4.1算术运算符</h3><p>算术运算符： + - + - * &#x2F; % (前)++ (后)++ (前)– (后)– +</p><p>除号：&#x2F;</p><p>%:取余运算</p><p>(前)++ :先自增1，后运算</p><p>(后)++ :先运算，后自增1</p><p>(前)– :先自减1，后运算</p><p>(后)– :先运算，后自减1</p><p>连接符：+：只能使用在String与其他数据类型变量之间使用。</p><h3 id="1-4-2赋值运算符"><a href="#1-4-2赋值运算符" class="headerlink" title="1.4.2赋值运算符"></a>1.4.2赋值运算符</h3><p>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</p><h3 id="1-4-3比较运算符"><a href="#1-4-3比较运算符" class="headerlink" title="1.4.3比较运算符"></a>1.4.3比较运算符</h3><p>比较运算符（关系运算符）: &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; instanceof</p><p>比较运算符的结果是boolean类型</p><p>&lt; &gt; &gt;&#x3D; &lt;&#x3D; :只能使用在数值类型的数据之间。</p><p>&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p><h3 id="1-4-4逻辑运算符"><a href="#1-4-4逻辑运算符" class="headerlink" title="1.4.4逻辑运算符"></a>1.4.4逻辑运算符</h3><p>&amp; &amp;&amp; | || ! ^</p><p>区分&amp; 与 &amp;&amp;</p><p>相同点1：&amp; 与 &amp;&amp; 的运算结果相同</p><p>相同点2：当符号左边是true时，二者都会执行符号右边的运算</p><p>不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</p><p>区分：| 与 ||</p><p>相同点1：| 与 || 的运算结果相同</p><p>相同点2：当符号左边是false时，二者都会执行符号右边的运算</p><p>不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</p><p>逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型</p><h3 id="1-4-5位运算符"><a href="#1-4-5位运算符" class="headerlink" title="1.4.5位运算符"></a>1.4.5位运算符</h3><p>&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~</p><p>一个&amp;时，参加运算的两个数据，按二进制位进行“与”运算。运算规则：同1为一，其余为0。</p><p>一个 | 时，参加运算的两个对象，按二进制位进行“或”运算。运算规则：同0为0，有1为1。另外，负数按补码形式参加按位或运算。</p><p><strong>位异或（^）：</strong></p><p>参与运算的两个数据，按二进制位进行“异或”运算。运算规则：相同为0，不同为1。</p><p><strong>非位（~）：</strong></p><p>按位取反操作会翻转其每一位。运算规则：0变为1，1变为0。</p><p><strong>左移（&lt;&lt;）：</strong></p><p>符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：高位丢弃，低位补0。</p><p><strong>右移（&gt;&gt;）：</strong></p><p>符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：正数左补0，负数左补1.</p><p><strong>无符号右移（&gt;&gt;&gt;）：</strong></p><p>即右移之后，无论该数为正还是为负，右移之后左补0。</p><h3 id="1-4-6三元运算符"><a href="#1-4-6三元运算符" class="headerlink" title="1.4.6三元运算符"></a>1.4.6三元运算符</h3><p>(条件表达式)? 表达式1 : 表达式2</p><ul><li>说明</li></ul><p>① 条件表达式的结果为boolean类型</p><p>② 根据条件表达式真或假，决定执行表达式1，还是表达式2.</p><p>如果表达式为true，则执行表达式1。</p><p>如果表达式为false，则执行表达式2。</p><ul><li><p>凡是可以使用三元运算符的地方，都可以改写为if-else</p></li><li><p>如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p></li></ul><h2 id="1-5流程控制"><a href="#1-5流程控制" class="headerlink" title="1.5流程控制"></a>1.5流程控制</h2><h3 id="1-5-1分支结构"><a href="#1-5-1分支结构" class="headerlink" title="1.5.1分支结构"></a>1.5.1分支结构</h3><p><strong>if-else条件判断结构</strong></p><p>结构一：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if(条件表达式)&#123;执行表达式&#125;</code></pre><p>结构二：二选一</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if(条件表达式)&#123;执行表达式1&#125;else&#123;执行表达式2&#125;</code></pre><p>结构三：n选一</p><pre class="line-numbers language-none"><code class="language-none">if(条件表达式)&#123;执行表达式1&#125;else if(条件表达式)&#123;执行表达式2&#125;else if(条件表达式)&#123;执行表达式3&#125;...else&#123;执行表达式n&#125;</code></pre><p><strong>说明：</strong></p><ul><li><p>else 结构是可选的。</p></li><li><p>针对于条件表达式：</p><p>&gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</p><p>&gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</p><p>&gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了</p></li><li><p>if-else结构是可以相互嵌套的。</p></li><li><p>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p></li></ul><p>switch-case<strong>选择结构</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch(表达式)&#123;case 常量1:执行语句1;&#x2F;&#x2F;break;case 常量2:执行语句2;&#x2F;&#x2F;break;...default:执行语句n;&#x2F;&#x2F;break;&#125;</code></pre><p><strong>说明：</strong></p><p>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。</p><p>当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</p><p>② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</p><p>③ switch结构中的表达式，只能是如下的6种数据类型之一：</p><p>byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</p><p>④ case 之后只能声明常量。不能声明范围。</p><p>⑤ break关键字是可选的。</p><p>⑥ default:相当于if-else结构中的else.</p><p>default结构是可选的，而且位置是灵活的。</p><ul><li><p>如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。</p></li><li><p>break在switch-case中是可选的</p></li></ul><h3 id="1-5-2循环结构"><a href="#1-5-2循环结构" class="headerlink" title="1.5.2循环结构"></a>1.5.2循环结构</h3><p><strong>1.循环结构的四要素</strong></p><p>① 初始化条件</p><p>② 循环条件 —&gt;是boolean类型</p><p>③ 循环体</p><p>④ 迭代条件</p><p>说明：通常情况下，循环结束都是因为②中循环条件返回false了。</p><p><strong>2.循环的三种结构</strong></p><p>2.1 for循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(①;②;④)&#123;③&#125;</code></pre><p>执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><p>2.2 while循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">①while(②)&#123;③;④;&#125;</code></pre><p>执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><p>说明：</p><p>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p><p>for和while循环总结：</p><ul><li>开发中，基本上我们都会从for、while中进行选择，实现循环结构。</li><li>for循环和while循环是可以相互转换的！</li><li>区别：for循环和while循环的初始化条件部分的作用范围不同。</li><li>我们写程序，要避免出现死循环。</li></ul><p>2.3 do-while循环结构</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">①do&#123;③;④;&#125;while(②);</code></pre><p>执行过程：① - ③ - ④ - ② - ③ - ④ - … - ②</p><p>说明：</p><ul><li>do-while循环至少会执行一次循环体！</li><li>开发中，使用for和while更多一些。较少使用do-while</li></ul><p><strong>3.“无限循环”结构: while(true) 或 for(;;)</strong></p><p>总结：如何结束一个循环结构？</p><p>方式一：当循环条件是false时</p><p>方式二：在循环体中，执行break</p><p><strong>4.嵌套循环</strong></p><p>1.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</p><p>内层循环：循环结构A</p><p>外层循环：循环结构B</p><p>2.说明：</p><p>① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p><p>② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</p><p>③ 外层循环控制行数，内层循环控制列数</p><p>补充:衡量一个功能代码的优劣：</p><p>1.正确性</p><p>2.可读性</p><p>3.健壮性</p><p>4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</p><h3 id="1-5-3break和continue"><a href="#1-5-3break和continue" class="headerlink" title="1.5.3break和continue"></a>1.5.3break和continue</h3><p>1.break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。</p><p>注意：<br>（1）只能在循环体内和switch语句体内使用break。<br>（2）不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。<br>（3）当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。</p><p>2.continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。</p><p>注意：<br>（1）continue语句并没有使整个循环终止。<br>（2）continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。</p><h1 id="第二章数组"><a href="#第二章数组" class="headerlink" title="第二章数组"></a>第二章数组</h1><h2 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h2><p>1.一维数组的声明与初始化</p><p>正确的方式：</p><pre class="line-numbers language-none"><code class="language-none">int num;&#x2F;&#x2F;声明num &#x3D; 10;&#x2F;&#x2F;初始化int id &#x3D; 1001;&#x2F;&#x2F;声明 + 初始化</code></pre><p>int[] ids;&#x2F;&#x2F;声明</p><pre class="line-numbers language-none"><code class="language-none">1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行ids &#x3D; new int[]&#123;1001,1002,1003,1004&#125;;1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行String[] names &#x3D; new String[5];</code></pre><p>2.一维数组元素的引用：通过角标的方式调用。</p><p>&#x2F;&#x2F;数组的角标（或索引从0开始的，到数组的长度-1结束。</p><pre class="line-numbers language-none"><code class="language-none">names[0] &#x3D; &quot;王铭&quot;;names[1] &#x3D; &quot;王赫&quot;;names[2] &#x3D; &quot;张学良&quot;;names[3] &#x3D; &quot;孙居龙&quot;;names[4] &#x3D; &quot;王宏志&quot;;&#x2F;&#x2F;charAt(0)</code></pre><p>3.数组的属性：length</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(names.length);&#x2F;&#x2F;5System.out.println(ids.length);</code></pre><p>说明：</p><p>数组一旦初始化，其长度就是确定的。arr.length</p><p>数组长度一旦确定，就不可修改。</p><p>4.一维数组的遍历</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int i &#x3D; 0;i &lt; names.length;i++)&#123;System.out.println(names[i]);&#125;</code></pre><p>5.一维数组元素的默认初始化值</p><p>数组元素是整型：0</p><p>数组元素是浮点型：0.0</p><p>数组元素是char型：0或’\u0000’，而非’0’</p><p>数组元素是boolean型：false</p><h2 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h2><p>1.如何理解二维数组？</p><ul><li>数组属于引用数据类型</li><li>数组的元素也可以是引用数据类型</li><li>一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</li></ul><p>2.二维数组的声明与初始化</p><p>正确的方式：</p><pre class="line-numbers language-none"><code class="language-none">int[] arr &#x3D; new int[]&#123;1,2,3&#125;;&#x2F;&#x2F;一维数组&#x2F;&#x2F;静态初始化 二维数组int[][] arr1 &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;动态初始化1String[][] arr2 &#x3D; new String[3][2];&#x2F;&#x2F;动态初始化2String[][] arr3 &#x3D; new String[3][];&#x2F;&#x2F;也是正确的写法：int[] arr4[] &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;int[] arr5[] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;类型推断</code></pre><p>3.如何调用二维数组元素:</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr1[0][1]);&#x2F;&#x2F;2System.out.println(arr2[1][1]);&#x2F;&#x2F;null</code></pre><p>4.二维数组的属性：</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr4.length);&#x2F;&#x2F;3System.out.println(arr4[0].length);&#x2F;&#x2F;3System.out.println(arr4[1].length);&#x2F;&#x2F;4</code></pre><p>5.遍历二维数组元素</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(int i &#x3D; 0;i &lt; arr4.length;i++)&#123;for(int j &#x3D; 0;j &lt; arr4[i].length;j++)&#123;System.out.print(arr4[i][j] + &quot; &quot;);&#125;System.out.println();&#125;</code></pre><p>6.二维数组元素的默认初始化值</p><p>规定：二维数组分为外层数组的元素，内层数组的元素</p><p>int[][] arr &#x3D; new int[4][3];</p><p>外层元素：arr[0],arr[1]等</p><p>内层元素：arr[0][0],arr[1][2]等</p><h2 id="2-3数组常见算法"><a href="#2-3数组常见算法" class="headerlink" title="2.3数组常见算法"></a>2.3数组常见算法</h2><p>1.数组的创建与元素赋值：</p><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p><p>2.针对于数值型的数组：</p><p>最大值、最小值、总和、平均数等</p><p>3.数组的赋值与复制</p><p>int[] array1,array2;</p><p>array1 &#x3D; new int[]{1,2,3,4};</p><p>3.1 赋值：</p><p>array2 &#x3D; array1;</p><p>如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p>3.2 复制：</p><pre class="line-numbers language-none"><code class="language-none">array2 &#x3D; new int[array1.length];for(int i &#x3D; 0;i &lt; array2.length;i++)&#123;array2[i] &#x3D; array1[i];&#125;</code></pre><p>如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p><p>4.数组元素的反转</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;方法一：for(int i &#x3D; 0;i &lt; arr.length &#x2F; 2;i++)&#123;String temp &#x3D; arr[i];arr[i] &#x3D; arr[arr.length - i -1];arr[arr.length - i -1] &#x3D; temp;&#125;</code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;方法二：for(int i &#x3D; 0,j &#x3D; arr.length - 1;i &lt; j;i++,j--)&#123;String temp &#x3D; arr[i];arr[i] &#x3D; arr[j];arr[j] &#x3D; temp;&#125; </code></pre><p>5.数组中指定元素的查找：搜索、检索</p><p>5.1 线性查找：</p><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p><p>适用性：具有普遍适用性。</p><p>5.2 二分法查找：</p><p>实现思路：每次比较中间值，折半的方式检索。</p><p>适用性：（前提：数组必须有序）</p><p>6.数组的排序算法</p><p>理解：</p><p>1）衡量排序算法的优劣：</p><p>时间复杂度、空间复杂度、稳定性</p><p>2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p><p>3）不同排序算法的时间复杂度</p><p>4）手写冒泡排序</p><p>int[] arr &#x3D; new int[]{43,32,76,-98,0,64,33,-21,32,99};</p><p>&#x2F;&#x2F;冒泡排序</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">for(int i &#x3D; 0;i &lt; arr.length - 1;i++)&#123;for(int j &#x3D; 0;j &lt; arr.length - 1 - i;j++)&#123;if(arr[j] &gt; arr[j + 1])&#123;int temp &#x3D; arr[j];arr[j] &#x3D; arr[j + 1];arr[j + 1] &#x3D; temp;&#125;&#125;&#125;        </code></pre><h2 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h2><p>1.理解：</p><p>① 定义在java.util包下。</p><p>② Arrays:提供了很多操作数组的方法。</p><p>2.使用：</p><p>&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</p><pre class="line-numbers language-none"><code class="language-none">int[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;int[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;boolean isEquals &#x3D; Arrays.equals(arr1, arr2);System.out.println(isEquals);</code></pre><p>&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(Arrays.toString(arr1));</code></pre><p>&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。</p><pre class="line-numbers language-none"><code class="language-none">Arrays.fill(arr1,10);System.out.println(Arrays.toString(arr1));</code></pre><p>&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。</p><pre class="line-numbers language-none"><code class="language-none">Arrays.sort(arr2);System.out.println(Arrays.toString(arr2));</code></pre><p>&#x2F;&#x2F;5.int binarySearch(int[] a,int key)</p><pre class="line-numbers language-none"><code class="language-none">int[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int index &#x3D; Arrays.binarySearch(arr3, 210);if(index &gt;&#x3D; 0)&#123;System.out.println(index);&#125;else&#123;System.out.println(&quot;未找到&quot;);&#125;</code></pre><h2 id="2-5数组的常见异常"><a href="#2-5数组的常见异常" class="headerlink" title="2.5数组的常见异常"></a>2.5数组的常见异常</h2><p>1.数组角标越界异常：ArrayIndexOutOfBoundsException</p><p>int[] arr &#x3D; new int[]{1,2,3,4,5};</p><pre class="line-numbers language-none"><code class="language-none">for(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;System.out.println(arr[i]);&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">System.out.println(arr[-2]);System.out.println(&quot;hello&quot;);</code></pre><p>2.空指针异常：NullPointerException</p><p>&#x2F;&#x2F;情况一：</p><pre class="line-numbers language-none"><code class="language-none">int[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;arr1 &#x3D; null;System.out.println(arr1[0]);</code></pre><p>&#x2F;&#x2F;情况二：</p><pre class="line-numbers language-none"><code class="language-none">int[][] arr2 &#x3D; new int[4][];System.out.println(arr2[0][0]);</code></pre><p>&#x2F;&#x2F;情况三：</p><pre class="line-numbers language-none"><code class="language-none">String[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;arr3[0] &#x3D; null;System.out.println(arr3[0].toString());</code></pre><p>小知识：一旦程序出现异常，未处理时，就终止执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高频面试题总结</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-抽象类与接口的区别"><a href="#1-抽象类与接口的区别" class="headerlink" title="1.抽象类与接口的区别"></a>1.抽象类与接口的区别</h1><ul><li>接口中除了static、final变量以外不能有其他变量，而抽象类不一定</li><li>一个类可以实现多个接口但是实现一个抽象类，接口本身可以通过extends关键字扩展多个接口</li><li>接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供实现，抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法</li><li>接口中不能有构造器，抽象类中可以(用于子类调用完成抽象类的初始化操作)</li></ul><h1 id="2-final、static、synchronized"><a href="#2-final、static、synchronized" class="headerlink" title="2.final、static、synchronized"></a>2.final、static、synchronized</h1><p>final：</p><ul><li>被final修饰的类不能被继承</li><li>被final修饰的方法不可用被重写</li><li>被final修饰的变量不可用被改变，如果修饰引用表示引用不可变，引用指向的内容可变</li><li>被final修饰的方法，jvm会尝试将其内联，以提高运行效率</li><li>被final修饰的常量，在编译阶段会存入常量池</li></ul><p>static：</p><ul><li>被static修饰的变量&#x2F;方法都属于类的静态资源，由类的实例所共享</li></ul><p>synchronized（同步锁）：</p><p>被sychronized修饰的代码块或方法只会有一个线程执行，已到达保证并发安全的效果</p><ul><li>修饰实例方法：作用于当前实例加锁</li><li>修饰静态方法：作用于当前类对象加锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁</li></ul><h1 id="3-String、StringBuilder、StringBuffer区别"><a href="#3-String、StringBuilder、StringBuffer区别" class="headerlink" title="3.String、StringBuilder、StringBuffer区别"></a>3.String、StringBuilder、StringBuffer区别</h1><p>String类中使用final关键字修饰字符数组来保存字符串，所以String是不可变的</p><p>StringBuilder和StringBuffer都是继承自AbstractStringBuilder 类，底层字符数组没有使用final修饰，所以可变</p><p>StringBuffer中对方法加了同步锁，所以线程安全，而StringBuilder则没有</p><p>总结：</p><p>操作少量数据时使用String</p><p>单线程操作字符串缓冲区下操作大量数据时使用StringBuilder</p><p>多线程操作字符串缓冲区下操作大量数据时使用StringBuffer</p><h1 id="4-equals与-x3D-x3D-的区别和使用场景"><a href="#4-equals与-x3D-x3D-的区别和使用场景" class="headerlink" title="4.equals与&#x3D;&#x3D;的区别和使用场景"></a>4.equals与&#x3D;&#x3D;的区别和使用场景</h1><p>如果是基本数据类型 &#x3D;&#x3D; 就是比较的值，引用数据类型&#x3D;&#x3D;比较的是内存地址</p><p>equals没有被重写时，比较的是内存地址，被重写则是比较值</p><h1 id="5-深拷贝和浅拷贝"><a href="#5-深拷贝和浅拷贝" class="headerlink" title="5.深拷贝和浅拷贝"></a>5.深拷贝和浅拷贝</h1><p><strong>浅拷贝</strong> ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块</p><p><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象</p><h1 id="6-Error和Exception"><a href="#6-Error和Exception" class="headerlink" title="6.Error和Exception"></a>6.Error和Exception</h1><ul><li>Exception 和 Error体现了java平台设计者对不同异常情况的分类, Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理.</li><li>Error 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获, 常见的OutOfMemoryError 是Error的子类.</li></ul><h1 id="7-反射的机制和应用场景"><a href="#7-反射的机制和应用场景" class="headerlink" title="7.反射的机制和应用场景"></a>7.反射的机制和应用场景</h1><p><strong>反射</strong>：动态获取信息或动态调用对象方法的机制，对于任何一个类都能知道他的所有属性和方法，对于任何对象，都可以获取对象的方法</p><p><strong>应用场景</strong>：</p><ul><li>通过配置信息调用类的方法</li><li>结合注解实现特殊功能</li><li>按需加载jar包或class</li></ul><h1 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h1><pre class="line-numbers language-none"><code class="language-none">谈谈List,Set,Map的区别？谈谈ArrayList和LinkedList的区别？请说一下HashMap与HashTable的区别谈一谈ArrayList的扩容机制？HashMap 的实现原理？请简述 LinkedHashMap 的工作原理和使用方式？谈谈对于ConcurrentHashMap的理解?</code></pre><pre class="line-numbers language-none"><code class="language-none">Java 中使用多线程的方式有哪些？说一下线程的几种状态？如何实现多线程中的同步？谈谈线程死锁，如何有效的避免线程死锁？谈谈线程阻塞的原因？请谈谈 Thread 中 run() 与 start()的区别？synchronized和volatile关键字的区别？如何保证线程安全？谈谈ThreadLocal用法和原理？Java 线程中notify 和 notifyAll有什么区别？synchronized和volatile关键字的区别？</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux.html</url>
      
        <content type="html"><![CDATA[<p>Linux</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatis.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatisPlus.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MyBatisPlus.html</url>
      
        <content type="html"><![CDATA[<p>MyBatisPlus</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Maven.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Maven.html</url>
      
        <content type="html"><![CDATA[<p>Maven</p>]]></content>
      
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL.html</url>
      
        <content type="html"><![CDATA[<p>MySQL</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbtiMQ学习笔记</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ.html</url>
      
        <content type="html"><![CDATA[<p>RabbitMQ</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nginx.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nginx.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章认识Nginx"><a href="#第一章认识Nginx" class="headerlink" title="第一章认识Nginx"></a>第一章认识Nginx</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis6</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis6.html</url>
      
        <content type="html"><![CDATA[<p>Redis6</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%20Security.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%20Security.html</url>
      
        <content type="html"><![CDATA[<p>Spring Security</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SSM%E6%95%B4%E5%90%88.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SSM%E6%95%B4%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<p>SSM整合</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring5.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring5.html</url>
      
        <content type="html"><![CDATA[<p>Spring5</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot2.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot2.html</url>
      
        <content type="html"><![CDATA[<p>SpringBoot2</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC.html</url>
      
        <content type="html"><![CDATA[<p>SpringMVC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>数据结构与算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<p>操作系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringCloud.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringCloud.html</url>
      
        <content type="html"><![CDATA[<h4 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h4><p>🤤基础篇</p><ul><li>认识微服务</li><li>服务拆分</li><li>远程调用</li><li>Eureka</li><li>Ribbon</li><li>Nacos</li><li>Feign</li><li>Gateway</li><li>RabbitMQ</li><li>Elasticsearch</li></ul><p>💻高级篇</p><ul><li>JMeter</li><li>Sentinel</li><li>Seata</li><li>Redis</li><li>。。。</li></ul><h4 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h4><h5 id="单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署"><a href="#单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署" class="headerlink" title="单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署"></a>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901083809.png" alt="img"></p><p>优点：架构简单，部署成本较低</p><p>缺点：耦合度高（维护困难、升级困难）</p><h5 id="分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务"><a href="#分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务" class="headerlink" title="分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务"></a>分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901092921.png" alt="img"></p><p>优点：降低服务耦合，有利于服务升级和拓展</p><p>缺点：调用服务关系错综复杂</p><p>分布式架构虽然降低了服务耦合，但是服务拆分时也会有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>所以需要一套行之有效的标准来约束分布式架构</p><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>微服务的架构特征：</p><ul><li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</p></li><li><p>自治：团队独立、技术独立、数据独立，独立部署和交付</p></li><li><p>面向服务：服务提供统一标准的接口，与语言和技术无关</p></li><li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p><p><img src="https://cdn.xn2001.com/img/2022/202205162352847.png" alt="img"></p></li></ul><p>微服务的上述特征其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><h5 id="因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法"><a href="#因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法" class="headerlink" title="因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法"></a>因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法</h5><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901083717.png" alt="img"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901084050.png" alt="img"></p><h4 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h4><p><img src="https://cdn.xn2001.com/img/2021/20210901092925.png" alt="需要学习的微服务知识内容"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901084131.png" alt="技术栈"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901090737.png" alt="自动化部署"></p><h4 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h4><p><img src="https://cdn.xn2001.com/img/2021/20210901090726.png" alt="img"></p><h4 id="服务拆分："><a href="#服务拆分：" class="headerlink" title="服务拆分："></a>服务拆分：</h4><pre class="line-numbers language-none"><code class="language-none">代码参考：Gitee：https:&#x2F;&#x2F;gitee.com&#x2F;xn2001&#x2F;cloudcode&#x2F;tree&#x2F;master&#x2F;01-cloud-demo</code></pre><p><strong>服务拆分注意事项</strong></p><p>单一职责：不同微服务，不要重复开发相同业务</p><p>数据独立：不要访问其它微服务的数据库</p><p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090745.png" alt="img"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li><li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li><li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li></ul><p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615132840054.png" alt="image-20220615132840054"></p><p>启动完成后，访问 <a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901090757.png" alt="img"></p><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><p>正如上面的服务拆分要求中所提到，</p><pre class="line-numbers language-none"><code class="language-none">订单服务如果需要查询用户信息，**只能调用用户服务的 Restful 接口**，不能查询用户数据库</code></pre><p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615133219788.png" alt="image-20220615133219788"></p><p>发送请求，自动序列化为 Java 对象。</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615133314248.png" alt="image-20220615133314248"></p><p>启动完成后，访问：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615132930294.png" alt="image-20220615132930294"></p><p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用关系</p><ul><li>服务提供者：暴露接口给其它微服务调用</li><li>服务消费者：调用其它微服务提供的接口</li></ul><p>服务调用中可能出现的问题</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615134720536.png" alt="image-20220615134720536"></p><h4 id="Eureka的作用："><a href="#Eureka的作用：" class="headerlink" title="Eureka的作用："></a>Eureka的作用：</h4><p>提供一个注册中心，将所有的服务进行注册，需要时动态调用，每30秒检测一次服务是否正常</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090919.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901090919.png"><img src="https://cdn.xn2001.com/img/2021/20210901090919.png" alt="img"></a></p><p><strong>order-service 如何得知 user-service 实例地址？</strong></p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li></ul><p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p><p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p><p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><p>接下来我们动手实践的步骤包括</p><p><img src="https://cdn.xn2001.com/img/2021/20210901090932.png" alt="img"></p><h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p>搭建 eureka-server</p><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>编写启动类</strong></p><p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class,args);    &#125;&#125;</code></pre><p><strong>编写配置文件</strong></p><p>编写一个 application.yml 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka</code></pre><p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p><p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615144833798.png" alt="image-20220615144833798"></p><p>到这 服务注册中心就搭建完成了</p><p>服务注册</p><pre><code>将 user-service、order-service 都注册到 eureka</code></pre><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 client</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">在启动类上添加注解：@EnableEurekaClient</code></pre><p>在 application.yml 文件，添加下面的配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:  application:      #name：orderservice    name: userserviceeureka:  client:    service-url:       defaultZone: http:127.0.0.1:10086&#x2F;eureka</code></pre><p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615151100786.png" alt="image-20220615151100786"></p><p>可以看到eureka本身和另外两个服务都注册成功</p><p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091005.png" alt="img"></p><p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615151554375.png"></p><h5 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h5><pre class="line-numbers language-none"><code class="language-none">在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</code></pre><p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean@LoadBalancedpublic RestTemplate restTemplate()&#123;    return new RestTemplate();&#125;</code></pre><p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615175754571.png" alt="image-20220615175754571"></p><p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p><h5 id="SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。"><a href="#SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。" class="headerlink" title="SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。"></a>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</h5><p><img src="https://cdn.xn2001.com/img/2021/20210901091242.png" alt="img"></p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>进入源码跟踪查看底层原理：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091323.png" alt="img"></p><p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，即 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p><p>继续跟入 <code>execute()</code> 方法：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091330.png" alt="img"></p><ul><li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li><li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li></ul><p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091345.png" alt="img"></p><p>我们继续跟入：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091355.png" alt="img"></p><p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091414.png" alt="img"></p><p>我们看看这个 <code>rule</code> 是谁：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091432.png" alt="img"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091442.png" alt="img"></p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p><p>基本流程如下：</p><ul><li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><p><img src="https://cdn.xn2001.com/img/2021/20210901091755.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901091755.png"><img src="https://cdn.xn2001.com/img/2021/20210901091755.png" alt="img"></a></p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091811.png" alt="img"></p><p>不同规则的含义如下：</p><table><thead><tr><th align="left"><strong>内置负载均衡规则类</strong></th><th align="left"><strong>规则描述</strong></th></tr></thead><tbody><tr><td align="left">RoundRobinRule</td><td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule  规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td align="left">WeightedResponseTimeRule</td><td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td align="left"><strong>ZoneAvoidanceRule</strong></td><td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td align="left">BestAvailableRule</td><td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td align="left">RandomRule</td><td align="left">随机选择一个可用的服务器。</td></tr><tr><td align="left">RetryRule</td><td align="left">重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p><h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220615193912474.png" alt="image-20220615193912474"></p><p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">userservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre><p><strong>注意</strong>：一般情况下都采用默认的负载均衡规则，不做修改。</p><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091850.png" alt="img"></p><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">ribbon:  eager-load:    enabled: true    clients:     -userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;-&quot;隔开</code></pre><h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，功能相对eureka会有提升</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091857.png" alt="img"></p><p>解压启动 Nacos，详细请看 安装指南</p><p>由于nacos默认采用集群启动， 所以需要使用如下命令进行单机启动</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd -m standalone</code></pre><p>访问：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a> 就可以看到nocas管理界面了</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091904.png" alt="img"></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。<strong>引入依赖</strong></p><p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p><p>如果之前引入过eureka的依赖，需要注释掉~</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.6.RELEASE&lt;&#x2F;version&gt;    &lt;type&gt;pom&lt;&#x2F;type&gt;    &lt;scope&gt;import&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre><p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>配置nacos地址</strong></p><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: 127.0.0.1:8848</code></pre><p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091918.png" alt="img"></p><p>浏览器访问：<a href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p><h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091928.png" alt="img"></p><p><a href="https://cdn.xn2001.com/img/2021/20210901091928.png"><img src="https://cdn.xn2001.com/img/2021/20210901091928.png" alt="img"></a></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091937.png" alt="img"></p><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称 HZ杭州</code></pre><p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p><pre class="line-numbers language-none"><code class="language-none">-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH</code></pre><p><img src="https://cdn.xn2001.com/img/2021/20210901091947.png" alt="img"></p><p>查看 nacos 控制台</p><p><img src="https://cdn.xn2001.com/img/2021/20210901091957.png" alt="img"></p><h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic IRule iRule()&#123;    &#x2F;&#x2F;默认为轮询规则，这里自定义为随机规则    return new NacosRule();&#125;</code></pre><p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">userservice:  ribbon:    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则</code></pre><p>然后，再对 orderservice 配置集群。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称</code></pre><p>现在我启动了四个服务，分别是：</p><ul><li>orderservice - HZ</li><li>userservice - HZ</li><li>userservice1 - HZ</li><li>userservice2 - SH</li></ul><p>访问地址：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p><p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p><p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092012.png" alt="img"></p><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p><p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092020.png" alt="img"></p><p>在弹出的编辑窗口，修改权重</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092026.png" alt="img"></p><p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到  0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li><p>Nacos 中可以有多个 namespace</p></li><li><p>namespace 下可以有 group、service 等</p></li><li><p>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</p></li><li><h2 id="环境隔离-1"><a href="#环境隔离-1" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li></ul></li></ul><p><img src="https://cdn.xn2001.com/img/2021/20210901092032.png" alt="img"></p><h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092038.png" alt="img"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092050.png" alt="img"></p><p>然后，填写表单：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092059.png" alt="img"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092114.png" alt="img"></p><h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID</code></pre><p>重启 order-service 后，访问控制台。</p><p><strong>public</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092143.png" alt="img"></p><p><strong>dev</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092130.png" alt="img"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092138.png" alt="img"></p><h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p><ul><li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li></ul><p>配置一个服务实例为永久实例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      discovery:        ephemeral: false # 设置为非临时实例</code></pre><p>另外，Nacos 集群**默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p><h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092150.png" alt="img"></p><p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p><h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092159.png" alt="img"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092206.png" alt="img"></p><p><strong>注意</strong>：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。</p><h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092215.png" alt="img"></p><p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092223.png" alt="img"></p><p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p><p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092228.png" alt="img"></p><p><strong>引入 nacos-config 依赖</strong></p><p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>添加 bootstrap.yml</strong></p><p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yaml # 文件后缀名</code></pre><p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092237.png" alt="img"></p><p>使用代码来验证是否拉取成功</p><p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)private String dateformat;@GetMapping(&quot;now&quot;)public String now()&#123;    &#x2F;&#x2F;格式化时间    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));&#125;</code></pre><p><img src="https://cdn.xn2001.com/img/2021/20210901092243.png" alt="img"></p><p>启动服务后，访问：<a href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092251.png" alt="img"></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p><h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092258.png" alt="img"></p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p><p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@Component@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)public class PatternProperties &#123;    public String dateformat;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate PatternProperties patternProperties;@GetMapping(&quot;now2&quot;)public String now2()&#123;    &#x2F;&#x2F;格式化时间    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));&#125;</code></pre><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p><p><strong>添加一个环境共享配置</strong></p><p>我们在 nacos 中添加一个 userservice.yaml 文件：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092323.png" alt="img"></p><p><strong>在 user-service 中读取共享配置</strong></p><p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092314.png" alt="img"></p><p>在 user-service 服务中，修改 UserController，添加一个方法：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092331.png" alt="img"></p><p><strong>运行两个 UserApplication，使用不同的profile</strong></p><p>修改 UserApplication2 这个启动项，改变其profile值：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092345.png" alt="img"></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092338.png" alt="img"></p><p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p><p>启动 UserApplication 和 UserApplication2</p><p>访问地址：<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092400.png" alt="img"></p><p>访问地址：<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://cdn.xn2001.com/img/2021/20210901092419.png" alt="img"></p><p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p><p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p><p>通过下面的两种方式来指定：</p><ul><li>extension-configs</li><li>shared-configs</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:   cloud:    nacos:      config:        file-extension: yaml # 文件后缀名        extends-configs: # 多微服务间共享的配置列表          - dataId: common.yaml # 要共享的配置文件id</code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:   cloud:    nacos:      config:        file-extension: yaml # 文件后缀名        shared-configs: # 多微服务间共享的配置列表          - dataId: common.yaml # 要共享的配置文件id</code></pre><h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092501.png" alt="img"></p><p>更细致的配置</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092520.png" alt="img"></p><h1 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h1><h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p><img src="https://cdn.xn2001.com/img/2021/202108181959897.png" alt="img"></p><p>其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。</p><p><img src="https://cdn.xn2001.com/img/2021/202108182000220.png" alt="img"></p><p>三个 Nacos 节点的地址</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。</p><p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;config_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) DEFAULT NULL,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;c_desc&#96; varchar(256) DEFAULT NULL,  &#96;c_use&#96; varchar(64) DEFAULT NULL,  &#96;effect&#96; varchar(64) DEFAULT NULL,  &#96;type&#96; varchar(64) DEFAULT NULL,  &#96;c_schema&#96; text,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_aggr&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_beta&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_tag&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_tags_relation&#96; (  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;nid&#96;),  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;group_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;his_config_info&#96; (  &#96;id&#96; bigint(64) unsigned NOT NULL,  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,  &#96;data_id&#96; varchar(255) NOT NULL,  &#96;group_id&#96; varchar(128) NOT NULL,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL,  &#96;md5&#96; varchar(32) DEFAULT NULL,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;src_user&#96; text,  &#96;src_ip&#96; varchar(50) DEFAULT NULL,  &#96;op_type&#96; char(10) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;nid&#96;),  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),  KEY &#96;idx_did&#96; (&#96;data_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;tenant_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;CREATE TABLE &#96;tenant_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;CREATE TABLE &#96;users&#96; (&#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,&#96;password&#96; varchar(500) NOT NULL,&#96;enabled&#96; boolean NOT NULL);CREATE TABLE &#96;roles&#96; (&#96;username&#96; varchar(50) NOT NULL,&#96;role&#96; varchar(50) NOT NULL,UNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE);CREATE TABLE &#96;permissions&#96; (    &#96;role&#96; varchar(50) NOT NULL,    &#96;resource&#96; varchar(255) NOT NULL,    &#96;action&#96; varchar(8) NOT NULL,    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE);INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);</code></pre><h2 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h2><p>进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p><p><img src="https://cdn.xn2001.com/img/2021/202108182004564.png" alt="img"></p><p>添加内容</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:8845127.0.0.1.8846127.0.0.1.8847</code></pre><p>然后修改 application.properties 文件，添加数据库配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.datasource.platform&#x3D;mysqldb.num&#x3D;1db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTCdb.user.0&#x3D;rootdb.password.0&#x3D;123456</code></pre><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"></code></pre><p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://cdn.xn2001.com/img/2021/202108182004103.png" alt="img"></p><p>然后分别修改三个文件夹中的 application.properties，</p><p>nacos1</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8845</code></pre><p>nacos2</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8846</code></pre><p>nacos3</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8847</code></pre><p>然后分别启动三个 nacos</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd</code></pre><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">upstream nacos-cluster &#123;    server 127.0.0.1:8845;server 127.0.0.1:8846;server 127.0.0.1:8847;&#125;server &#123;    listen       80;    server_name  localhost;    location &#x2F;nacos &#123;        proxy_pass http:&#x2F;&#x2F;nacos-cluster;    &#125;&#125;</code></pre><p>启动 nginx，在浏览器访问：<a href="http://localhost/nacos">http://localhost/nacos</a></p><p>在代码中的 application.yml 文件配置改为如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:80 # Nacos地址</code></pre><p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。</p><h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092616.png" alt="img"></p><ul><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ul><p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092639.png" alt="img"></p><h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p><p>我们在 order-service 引入 feign 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>添加注解</strong></p><p>在 order-service 启动类添加注解开启 Feign</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220710135442258.png" alt="image-20220710135442258"></p><p><strong>请求接口</strong></p><p>在 order-service 中新建一个接口，内容如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.order.clients;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p><p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p><p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p><p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p><p><strong>测试</strong></p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate UserClient userClient;public Order queryOrderById(Long orderId) &#123;    &#x2F;&#x2F; 1.查询订单    Order order &#x3D; orderMapper.findById(orderId);    &#x2F;&#x2F; 2.用feign进行远程调用，替代之前的RestTemplate    User user &#x3D; userClient.findById(order.getUserId());    order.setUser(user);    &#x2F;&#x2F; 4.返回    return order;&#125;</code></pre><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign.Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p><p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:    client:    config:       userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别 </code></pre><p><strong>也可以针对所有服务</strong>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:    client:    config:       default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别</code></pre><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul><p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DefaultFeignConfiguration  &#123;    @Bean    public Logger.Level feignLogLevel()&#123;        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC    &#125;&#125;</code></pre><p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) </code></pre><p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) </code></pre><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p><ul><li><strong>URLConnection</strong>：默认实现，不支持连接池</li><li><strong>Apache HttpClient</strong> ：支持连接池</li><li><strong>OKHttp</strong>：支持连接池</li></ul><p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p><p>另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。</p><p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p><p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>配置连接池</strong></p><p>在 order-service 的 application.yml 中添加配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数</code></pre><p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p><p><img src="C:\Users\63194\AppData\Roaming\Typora\typora-user-images\image-20220712153433953.png" alt="image-20220712153433953"></p><p>Debug 方式启动 order-service  服务，可以看到这里的 client，底层就是 HttpClient</p><p><img src="https://cdn.xn2001.com/img/2021/20210901092737.png" alt="img"></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p><p>2）Feign 客户端、Controller 都集成该接口</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092803.png"><img src="https://cdn.xn2001.com/img/2021/20210901092803.png" alt="img"></a></p><p>优点</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li></ul><h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092811.png"><img src="https://cdn.xn2001.com/img/2021/20210901092811.png" alt="img"></a></p><p>接下来我们就用该方法在代码中实现</p><p><strong>首先创建一个 module，命名为 feign-api</strong></p><p><a href="https://cdn.xn2001.com/img/2021/20210901092835.png"><img src="https://cdn.xn2001.com/img/2021/20210901092835.png" alt="img"></a></p><p>在 feign-api 中然后引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>order-service中 的 UserClient、User 都复制到 feign-api 项目中</p><p><a href="https://cdn.xn2001.com/img/2021/20210901092848.png"><img src="https://cdn.xn2001.com/img/2021/20210901092848.png" alt="img"></a></p><p>接下来在 order-service 中使用 feign-api</p><p>由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service  中引入 feign-api</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;com.xn2001.feign&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p><strong>修改注解</strong></p><p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p><p>修改 order-service 启动类上的 <code>@EnableFeignClients</code> 注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableFeignClients(basePackages &#x3D; &quot;com.xn2001.feign.clients&quot;)</code></pre><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>代码参考：</p><p>Gitee：<a href="https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway">https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway</a></p><p>GitHub：<a href="https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway">https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway</a></p></blockquote><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring  Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API  路由管理方式。</p><p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p><a href="https://cdn.xn2001.com/img/2021/20210901092857.png"><img src="https://cdn.xn2001.com/img/2021/20210901092857.png" alt="img"></a></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在 SpringCloud 中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol><li>创建 SpringBoot 工程 gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><p>创建 application.yml 文件，内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求</code></pre><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p><p>重启网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href="http://userservice/user/1">http://userservice/user/1</a></p><p><a href="https://cdn.xn2001.com/img/2021/202108220125749.png"><img src="https://cdn.xn2001.com/img/2021/202108220125749.png" alt="img"></a></p><p>多个 predicates 的话，要同时满足规则，下文有例子。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><a href="https://cdn.xn2001.com/img/2021/202108220127419.png"><img src="https://cdn.xn2001.com/img/2021/202108220127419.png" alt="img"></a></p><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p><p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p></blockquote><p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">predicates:  - Path&#x3D;&#x2F;order&#x2F;**  - After&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</code></pre><p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><a href="https://cdn.xn2001.com/img/2021/202108220133487.png"><img src="https://cdn.xn2001.com/img/2021/202108220133487.png" alt="img"></a></p><p>Spring提供了31种不同的路由过滤器工厂。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p></blockquote><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><p>下面我们以 AddRequestHeader 为例：</p><p><a href="https://cdn.xn2001.com/img/2021/202108220139913.png"><img src="https://cdn.xn2001.com/img/2021/202108220139913.png" alt="img"></a></p><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p><p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求          filters:            - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre><p>如何验证，我们修改 userservice 中的一个接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value &#x3D; &quot;sign&quot;, required &#x3D; false) String sign) &#123;    log.warn(sign);    return userService.queryById(id);&#125;</code></pre><p>重启两个服务，访问：<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p><p>可以看到控制台打印出了这个请求头</p><p><a href="https://cdn.xn2001.com/img/2021/202108220145565.png"><img src="https://cdn.xn2001.com/img/2021/202108220145565.png" alt="img"></a></p><p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      default-filters:        - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p><p><strong>需求</strong>：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p><ul><li>参数中是否有 authorization</li><li>authorization 参数值是否为 admin</li></ul><p>如果同时满足则放行，否则拦截。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class AuthorizeFilter implements GlobalFilter, Ordered &#123;    &#x2F;&#x2F; 测试：http:&#x2F;&#x2F;localhost:10010&#x2F;order&#x2F;101?authorization&#x3D;admin    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        &#x2F;&#x2F; 获取第一个 authorization 参数        String authorization &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;authorization&quot;);        if (&quot;admin&quot;.equals(authorization))&#123;            &#x2F;&#x2F; 放行            return chain.filter(exchange);        &#125;        &#x2F;&#x2F; 设置拦截状态码信息        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);        &#x2F;&#x2F; 设置拦截        return exchange.getResponse().setComplete();    &#125;    &#x2F;&#x2F; 设置过滤器优先级，值越低优先级越高    &#x2F;&#x2F; 也可以使用 @Order 注解    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;</code></pre><h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p><p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p><p><a href="https://cdn.xn2001.com/img/2021/202108230002747.png"><img src="https://cdn.xn2001.com/img/2021/202108230002747.png" alt="img"></a></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li><li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li><li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#39;[&#x2F;**]&#39;:            allowedOrigins: # 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91.html"/>
      <url>//post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91.html</url>
      
        <content type="html"><![CDATA[<p>计网</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
