[{"id":"a00b2defe973fe8d6ab3038de496d7b1","title":"JDBC","content":"JDBC\n","slug":"学习笔记/JDBC","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"2753f6a9ea9a9250d658dda483e2dec3","title":"ActiveMQ学习笔记","content":"ActiveMQ\n","slug":"学习笔记/ActiveMQ","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"中间件","author_index":"Aurora"},{"id":"3aaacfb1c55b27ab574dbc9688ad81da","title":"ElasticSearch学习笔记","content":"Elasticsearch\n","slug":"学习笔记/Elasticsearch","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"搜索引擎","author_index":"Aurora"},{"id":"221a7ad001c03569112f684b2dfdc120","title":"Git","content":"","slug":"学习笔记/Git","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"版本控制","author_index":"Aurora"},{"id":"0b1381c4a63c09e41167c5168339035a","title":"JVM","content":"JVM\n","slug":"学习笔记/JVM","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"第一章Java基本语法1.1关键字与标识符1.1.1java关键字的使用定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）\n特点：关键字中所字母都为小写\n具体哪些关键字：\n\n*\n1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。具体哪些保留字：goto 、const\n注意：自己命名标识符时要避免使用这些保留字\n1.1.3.标识符的使用定义：凡是自己可以起名字的地方都叫标识符。\n涉及到的结构：\n包名、类名、接口名、变量名、方法名、常量名\n规则：(必须要遵守。否则，编译不通过)\n\n规范：（可以不遵守，不影响编译和运行。但是要求遵守）\n\n注意点：\n在起名字时，为了提高阅读性，要尽量意义，“见名知意”。\n1.2变量的使用1.2.1变量的分类按数据类型分类\n\n1.2.2定义变量的格式数据类型 变量名 &#x3D; 变量值;\n或\n数据类型 变量名;\n变量名 &#x3D; 变量值;\n1.2.3变量使用的注意点① 变量必须先声明，后使用\n② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了\n③ 同一个作用域内，不可以声明两个同名的变量\n1.2.4基本数据类型变量间运算规则\n涉及到的基本数据类型：除了boolean之外的其他7种\n\n自动类型转换(只涉及7种基本数据类型）\n\n\n结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。\nbyte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double\n特别的：当byte、char、short三种类型的变量做运算时，结果为int型\n说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量\n\n强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。\n\n\n需要使用强转符：()\n注意点：强制类型转换，可能导致精度损失。\n\n\nString与8种基本数据类型间的运算\n\n\nString属于引用数据类型,翻译为：字符串\n声明String类型变量时，使用一对””\nString可以和8种基本数据类型变量做运算，且运算只能是连接运算：+\n运算的结果仍然是String类型\n\n避免：\nString s &#x3D; 123;&#x2F;&#x2F;编译错误\nString s1 &#x3D; “123”;\nint i &#x3D; (int)s1;&#x2F;&#x2F;编译错误\n1.3进制1.3.1编程中涉及的进制及表示方式：\n1.3.2二进制的使用说明：\n计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。\n二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。\n原码、反码、补码的说明：\n\n正数：三码合一\n负数：\n\n1.3.3进制间的互相转换\n图示：\n\n\n图示二进制转换为十进制：\n\n\n\n\n\n\n图示十进制转换为二进制：\n\n\n\n二进制与八进制、十六进制间的转换\n\n\n\n1.4运算符1.4.1算术运算符算术运算符： + - + - * &#x2F; % (前)++ (后)++ (前)– (后)– +\n除号：&#x2F;\n%:取余运算\n(前)++ :先自增1，后运算\n(后)++ :先运算，后自增1\n(前)– :先自减1，后运算\n(后)– :先运算，后自减1\n连接符：+：只能使用在String与其他数据类型变量之间使用。\n1.4.2赋值运算符赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;\n1.4.3比较运算符比较运算符（关系运算符）: &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; instanceof\n比较运算符的结果是boolean类型\n&lt; &gt; &gt;&#x3D; &lt;&#x3D; :只能使用在数值类型的数据之间。\n&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。\n1.4.4逻辑运算符&amp; &amp;&amp; | || ! ^\n区分&amp; 与 &amp;&amp;\n相同点1：&amp; 与 &amp;&amp; 的运算结果相同\n相同点2：当符号左边是true时，二者都会执行符号右边的运算\n不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。\n区分：| 与 ||\n相同点1：| 与 || 的运算结果相同\n相同点2：当符号左边是false时，二者都会执行符号右边的运算\n不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算\n逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型\n1.4.5位运算符&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~\n一个&amp;时，参加运算的两个数据，按二进制位进行“与”运算。运算规则：同1为一，其余为0。\n一个 | 时，参加运算的两个对象，按二进制位进行“或”运算。运算规则：同0为0，有1为1。另外，负数按补码形式参加按位或运算。\n位异或（^）：\n参与运算的两个数据，按二进制位进行“异或”运算。运算规则：相同为0，不同为1。\n非位（~）：\n按位取反操作会翻转其每一位。运算规则：0变为1，1变为0。\n左移（&lt;&lt;）：\n符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：高位丢弃，低位补0。\n右移（&gt;&gt;）：\n符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：正数左补0，负数左补1.\n无符号右移（&gt;&gt;&gt;）：\n即右移之后，无论该数为正还是为负，右移之后左补0。\n1.4.6三元运算符(条件表达式)? 表达式1 : 表达式2\n\n说明\n\n① 条件表达式的结果为boolean类型\n② 根据条件表达式真或假，决定执行表达式1，还是表达式2.\n如果表达式为true，则执行表达式1。\n如果表达式为false，则执行表达式2。\n\n凡是可以使用三元运算符的地方，都可以改写为if-else\n\n如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。\n\n\n1.5流程控制1.5.1分支结构if-else条件判断结构\n结构一：\nif(条件表达式)&#123;\n执行表达式\n&#125;\n\n结构二：二选一\nif(条件表达式)&#123;\n执行表达式1\n&#125;else&#123;\n执行表达式2\n&#125;\n\n结构三：n选一\nif(条件表达式)&#123;\n执行表达式1\n&#125;else if(条件表达式)&#123;\n执行表达式2\n&#125;else if(条件表达式)&#123;\n执行表达式3\n&#125;\n...\nelse&#123;\n执行表达式n\n&#125;\n\n说明：\n\nelse 结构是可选的。\n\n针对于条件表达式：\n&gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。\n&gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。\n&gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了\n\nif-else结构是可以相互嵌套的。\n\n如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。\n\n\nswitch-case选择结构\nswitch(表达式)&#123;\ncase 常量1:\n执行语句1;\n&#x2F;&#x2F;break;\ncase 常量2:\n执行语句2;\n&#x2F;&#x2F;break;\n...\ndefault:\n执行语句n;\n&#x2F;&#x2F;break;\n&#125;\n\n说明：\n① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。\n当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。\n② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构\n③ switch结构中的表达式，只能是如下的6种数据类型之一：\nbyte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)\n④ case 之后只能声明常量。不能声明范围。\n⑤ break关键字是可选的。\n⑥ default:相当于if-else结构中的else.\ndefault结构是可选的，而且位置是灵活的。\n\n如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。\n\nbreak在switch-case中是可选的\n\n\n1.5.2循环结构1.循环结构的四要素\n① 初始化条件\n② 循环条件 —&gt;是boolean类型\n③ 循环体\n④ 迭代条件\n说明：通常情况下，循环结束都是因为②中循环条件返回false了。\n2.循环的三种结构\n2.1 for循环结构\nfor(①;②;④)&#123;\n③\n&#125;\n\n执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②\n2.2 while循环结构\n①\nwhile(②)&#123;\n③;\n④;\n&#125;\n\n执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②\n说明：\n写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！\nfor和while循环总结：\n\n开发中，基本上我们都会从for、while中进行选择，实现循环结构。\nfor循环和while循环是可以相互转换的！\n区别：for循环和while循环的初始化条件部分的作用范围不同。\n我们写程序，要避免出现死循环。\n\n2.3 do-while循环结构\n①\ndo&#123;\n③;\n④;\n&#125;while(②);\n\n执行过程：① - ③ - ④ - ② - ③ - ④ - … - ②\n说明：\n\ndo-while循环至少会执行一次循环体！\n开发中，使用for和while更多一些。较少使用do-while\n\n3.“无限循环”结构: while(true) 或 for(;;)\n总结：如何结束一个循环结构？\n方式一：当循环条件是false时\n方式二：在循环体中，执行break\n4.嵌套循环\n1.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环\n内层循环：循环结构A\n外层循环：循环结构B\n2.说明：\n① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次\n② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次\n③ 外层循环控制行数，内层循环控制列数\n补充:衡量一个功能代码的优劣：\n1.正确性\n2.可读性\n3.健壮性\n4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）\n1.5.3break和continue1.break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。\n注意：（1）只能在循环体内和switch语句体内使用break。（2）不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。（3）当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。\n2.continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。\n注意：（1）continue语句并没有使整个循环终止。（2）continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。\n第二章数组2.1一维数组1.一维数组的声明与初始化\n正确的方式：\nint num;&#x2F;&#x2F;声明\nnum &#x3D; 10;&#x2F;&#x2F;初始化\nint id &#x3D; 1001;&#x2F;&#x2F;声明 + 初始化\n\nint[] ids;&#x2F;&#x2F;声明\n1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行\nids &#x3D; new int[]&#123;1001,1002,1003,1004&#125;;\n1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行\nString[] names &#x3D; new String[5];\n\n\n\n2.一维数组元素的引用：通过角标的方式调用。\n&#x2F;&#x2F;数组的角标（或索引从0开始的，到数组的长度-1结束。\nnames[0] &#x3D; &quot;王铭&quot;;\nnames[1] &#x3D; &quot;王赫&quot;;\nnames[2] &#x3D; &quot;张学良&quot;;\nnames[3] &#x3D; &quot;孙居龙&quot;;\nnames[4] &#x3D; &quot;王宏志&quot;;&#x2F;&#x2F;charAt(0)\n\n3.数组的属性：length\nSystem.out.println(names.length);&#x2F;&#x2F;5\nSystem.out.println(ids.length);\n\n说明：\n数组一旦初始化，其长度就是确定的。arr.length\n数组长度一旦确定，就不可修改。\n4.一维数组的遍历\nfor(int i &#x3D; 0;i &lt; names.length;i++)&#123;\nSystem.out.println(names[i]);\n&#125;\n\n5.一维数组元素的默认初始化值\n数组元素是整型：0\n数组元素是浮点型：0.0\n数组元素是char型：0或’\\u0000’，而非’0’\n数组元素是boolean型：false\n2.2二维数组1.如何理解二维数组？\n\n数组属于引用数据类型\n数组的元素也可以是引用数据类型\n一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。\n\n2.二维数组的声明与初始化\n正确的方式：\nint[] arr &#x3D; new int[]&#123;1,2,3&#125;;&#x2F;&#x2F;一维数组\n&#x2F;&#x2F;静态初始化 二维数组\nint[][] arr1 &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;\n&#x2F;&#x2F;动态初始化1\nString[][] arr2 &#x3D; new String[3][2];\n&#x2F;&#x2F;动态初始化2\nString[][] arr3 &#x3D; new String[3][];\n&#x2F;&#x2F;也是正确的写法：\nint[] arr4[] &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;\n\nint[] arr5[] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;类型推断\n\n3.如何调用二维数组元素:\nSystem.out.println(arr1[0][1]);&#x2F;&#x2F;2\nSystem.out.println(arr2[1][1]);&#x2F;&#x2F;null\n\n4.二维数组的属性：\nSystem.out.println(arr4.length);&#x2F;&#x2F;3\nSystem.out.println(arr4[0].length);&#x2F;&#x2F;3\nSystem.out.println(arr4[1].length);&#x2F;&#x2F;4\n\n5.遍历二维数组元素\nfor(int i &#x3D; 0;i &lt; arr4.length;i++)&#123;\n\tfor(int j &#x3D; 0;j &lt; arr4[i].length;j++)&#123;\n\tSystem.out.print(arr4[i][j] + &quot; &quot;);\n\t&#125;\n\tSystem.out.println();\n&#125;\n\n6.二维数组元素的默认初始化值\n规定：二维数组分为外层数组的元素，内层数组的元素\nint[][] arr &#x3D; new int[4][3];\n外层元素：arr[0],arr[1]等\n内层元素：arr[0][0],arr[1][2]等\n2.3数组常见算法1.数组的创建与元素赋值：\n杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。\n2.针对于数值型的数组：\n最大值、最小值、总和、平均数等\n3.数组的赋值与复制\nint[] array1,array2;\narray1 &#x3D; new int[]{1,2,3,4};\n3.1 赋值：\narray2 &#x3D; array1;\n如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。\n3.2 复制：\narray2 &#x3D; new int[array1.length];\nfor(int i &#x3D; 0;i &lt; array2.length;i++)&#123;\n\tarray2[i] &#x3D; array1[i];\n&#125;\n\n如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。\n4.数组元素的反转\n&#x2F;&#x2F;方法一：\nfor(int i &#x3D; 0;i &lt; arr.length &#x2F; 2;i++)&#123;\n\tString temp &#x3D; arr[i];\n\tarr[i] &#x3D; arr[arr.length - i -1];\n\tarr[arr.length - i -1] &#x3D; temp;\n&#125;\n\n\n\n&#x2F;&#x2F;方法二：\nfor(int i &#x3D; 0,j &#x3D; arr.length - 1;i &lt; j;i++,j--)&#123;\n\tString temp &#x3D; arr[i];\n\tarr[i] &#x3D; arr[j];\n\tarr[j] &#x3D; temp;\n&#125; \n\n5.数组中指定元素的查找：搜索、检索\n5.1 线性查找：\n实现思路：通过遍历的方式，一个一个的数据进行比较、查找。\n适用性：具有普遍适用性。\n5.2 二分法查找：\n实现思路：每次比较中间值，折半的方式检索。\n适用性：（前提：数组必须有序）\n6.数组的排序算法\n理解：\n1）衡量排序算法的优劣：\n时间复杂度、空间复杂度、稳定性\n2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）\n3）不同排序算法的时间复杂度\n4）手写冒泡排序\nint[] arr &#x3D; new int[]{43,32,76,-98,0,64,33,-21,32,99};\n&#x2F;&#x2F;冒泡排序\nfor(int i &#x3D; 0;i &lt; arr.length - 1;i++)&#123;\n\tfor(int j &#x3D; 0;j &lt; arr.length - 1 - i;j++)&#123;\n\t\tif(arr[j] &gt; arr[j + 1])&#123;\n\t\tint temp &#x3D; arr[j];\n\t\tarr[j] &#x3D; arr[j + 1];\n\t\tarr[j + 1] &#x3D; temp;\n\t\t&#125;\n\t&#125;\n&#125;        \n\n2.4Arrays工具类1.理解：\n① 定义在java.util包下。\n② Arrays:提供了很多操作数组的方法。\n2.使用：\n&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。\nint[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;\nint[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;\nboolean isEquals &#x3D; Arrays.equals(arr1, arr2);\nSystem.out.println(isEquals);\n\n&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。\nSystem.out.println(Arrays.toString(arr1));\n\n&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。\nArrays.fill(arr1,10);\nSystem.out.println(Arrays.toString(arr1));\n\n&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。\nArrays.sort(arr2);\nSystem.out.println(Arrays.toString(arr2));\n\n&#x2F;&#x2F;5.int binarySearch(int[] a,int key)\nint[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;\nint index &#x3D; Arrays.binarySearch(arr3, 210);\nif(index &gt;&#x3D; 0)&#123;\nSystem.out.println(index);\n&#125;else&#123;\nSystem.out.println(&quot;未找到&quot;);\n&#125;\n\n2.5数组的常见异常1.数组角标越界异常：ArrayIndexOutOfBoundsException\nint[] arr &#x3D; new int[]{1,2,3,4,5};\nfor(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;\n\tSystem.out.println(arr[i]);\n&#125;\n\nSystem.out.println(arr[-2]);\nSystem.out.println(&quot;hello&quot;);\n\n2.空指针异常：NullPointerException\n&#x2F;&#x2F;情况一：\nint[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;\narr1 &#x3D; null;\nSystem.out.println(arr1[0]);\n\n&#x2F;&#x2F;情况二：\nint[][] arr2 &#x3D; new int[4][];\nSystem.out.println(arr2[0][0]);\n\n&#x2F;&#x2F;情况三：\nString[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;\narr3[0] &#x3D; null;\nSystem.out.println(arr3[0].toString());\n\n小知识：一旦程序出现异常，未处理时，就终止执行。\n","slug":"学习笔记/JavaSE","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"942bb69cff6f2eb67f0b841ccb267414","title":"Java高频面试题总结","content":"1.抽象类与接口的区别\n接口中除了static、final变量以外不能有其他变量，而抽象类不一定\n一个类可以实现多个接口但是实现一个抽象类，接口本身可以通过extends关键字扩展多个接口\n接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供实现，抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法\n接口中不能有构造器，抽象类中可以(用于子类调用完成抽象类的初始化操作)\n\n2.final、static、synchronizedfinal：\n\n被final修饰的类不能被继承\n被final修饰的方法不可用被重写\n被final修饰的变量不可用被改变，如果修饰引用表示引用不可变，引用指向的内容可变\n被final修饰的方法，jvm会尝试将其内联，以提高运行效率\n被final修饰的常量，在编译阶段会存入常量池\n\nstatic：\n\n被static修饰的变量&#x2F;方法都属于类的静态资源，由类的实例所共享\n\nsynchronized（同步锁）：\n被sychronized修饰的代码块或方法只会有一个线程执行，已到达保证并发安全的效果\n\n修饰实例方法：作用于当前实例加锁\n修饰静态方法：作用于当前类对象加锁\n修饰代码块：指定加锁对象，对给定对象加锁\n\n3.String、StringBuilder、StringBuffer区别String类中使用final关键字修饰字符数组来保存字符串，所以String是不可变的\nStringBuilder和StringBuffer都是继承自AbstractStringBuilder 类，底层字符数组没有使用final修饰，所以可变\nStringBuffer中对方法加了同步锁，所以线程安全，而StringBuilder则没有\n总结：\n操作少量数据时使用String\n单线程操作字符串缓冲区下操作大量数据时使用StringBuilder\n多线程操作字符串缓冲区下操作大量数据时使用StringBuffer\n4.equals与&#x3D;&#x3D;的区别和使用场景如果是基本数据类型 &#x3D;&#x3D; 就是比较的值，引用数据类型&#x3D;&#x3D;比较的是内存地址\nequals没有被重写时，比较的是内存地址，被重写则是比较值\n5.深拷贝和浅拷贝浅拷贝 ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块\n深拷贝：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象\n6.Error和Exception\nException 和 Error体现了java平台设计者对不同异常情况的分类, Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理.\nError 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获, 常见的OutOfMemoryError 是Error的子类.\n\n7.反射的机制和应用场景反射：动态获取信息或动态调用对象方法的机制，对于任何一个类都能知道他的所有属性和方法，对于任何对象，都可以获取对象的方法\n应用场景：\n\n通过配置信息调用类的方法\n结合注解实现特殊功能\n按需加载jar包或class\n\n8.谈谈List,Set,Map的区别？\n谈谈ArrayList和LinkedList的区别？\n请说一下HashMap与HashTable的区别\n谈一谈ArrayList的扩容机制？\nHashMap 的实现原理？\n请简述 LinkedHashMap 的工作原理和使用方式？\n谈谈对于ConcurrentHashMap的理解?\n\nJava 中使用多线程的方式有哪些？\n说一下线程的几种状态？\n如何实现多线程中的同步？\n谈谈线程死锁，如何有效的避免线程死锁？\n谈谈线程阻塞的原因？\n请谈谈 Thread 中 run() 与 start()的区别？\nsynchronized和volatile关键字的区别？\n如何保证线程安全？\n谈谈ThreadLocal用法和原理？\nJava 线程中notify 和 notifyAll有什么区别？\nsynchronized和volatile关键字的区别？\n","slug":"学习笔记/Java高频面试题","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"面试","author_index":"Aurora"},{"id":"2174f5d6204b80063f7ff0e3c82666fd","title":"JavaWeb","content":"JavaWeb\n","slug":"学习笔记/JavaWeb","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"3fe1ee3f3830128bf539e5f4ed9fbbe9","title":"Linux","content":"Linux\n","slug":"学习笔记/Linux","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"操作系统","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"Maven\n","slug":"学习笔记/Maven","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"版本控制","author_index":"Aurora"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"MyBatis\n","slug":"学习笔记/MyBatis","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"a29e07a1f79a3f2735cebc4555df7972","title":"MyBatisPlus","content":"MyBatisPlus\n","slug":"学习笔记/MyBatisPlus","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"838ae74e3a76757d637de803a615bfd9","title":"MySQL","content":"MySQL\n","slug":"学习笔记/MySQL","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"数据库","author_index":"Aurora"},{"id":"af6a277a1f79cc7652a602f9f57ed64f","title":"Nginx","content":"第一章认识Nginx1.1什么是NginxNginx (engine x)  是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。\n1.2为什么需要Nginx在简单环境中，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。\n\n但是当项目持续迭代后，平台的用户快速增长，并发了增大，这时候一台服务器就无法满足需求了。\n\n于是我们需要横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。\n\n我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。\n1.3Nginx的作用Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。\n正向代理：\n\n反向代理：\n\nNginx提供了两种负载均衡策略，内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。\n\n轮询\n\n加权轮询\n\niphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n\n动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。\n\n\n目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！\n具体操作配置参考：https://blog.csdn.net/S_ZaiJiangHu/article/details/126838279\n","slug":"学习笔记/Nginx","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"ee30ef9a588d2ac3314205f5348312b8","title":"RabbtiMQ学习笔记","content":"RabbitMQ\n","slug":"学习笔记/RabbitMQ","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"中间件","author_index":"Aurora"},{"id":"b26b54b0cb74df6cb29813cfb88d3e9d","title":"SSM框架整合","content":"SSM整合\n","slug":"学习笔记/SSM整合","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"00f7272b819970a0b81a0a2ebb098979","title":"Redis6","content":"Redis6\n","slug":"学习笔记/Redis6","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"数据库","author_index":"Aurora"},{"id":"fceed54d2b78e915f81cbddb878dcc7f","title":"SpringSecurity","content":"Spring Security\n","slug":"学习笔记/Spring Security","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"d6ae9949d97b7b62e8df1871093bd77d","title":"Spring5","content":"Spring5\n","slug":"学习笔记/Spring5","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"2fdfe1e1ace8a4912a23a4cbc1c92824","title":"SpringCloud","content":"微服务技术栈🤤基础篇\n\n认识微服务\n服务拆分\n远程调用\nEureka\nRibbon\nNacos\nFeign\nGateway\nRabbitMQ\nElasticsearch\n\n💻高级篇\n\nJMeter\nSentinel\nSeata\nRedis\n。。。\n\n认识微服务单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署\n优点：架构简单，部署成本较低\n缺点：耦合度高（维护困难、升级困难）\n分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务\n优点：降低服务耦合，有利于服务升级和拓展\n缺点：调用服务关系错综复杂\n分布式架构虽然降低了服务耦合，但是服务拆分时也会有很多问题需要思考：\n\n服务拆分的粒度如何界定？\n服务之间如何调用？\n服务的调用关系如何管理？\n\n所以需要一套行之有效的标准来约束分布式架构\n微服务微服务的架构特征：\n\n单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n\n自治：团队独立、技术独立、数据独立，独立部署和交付\n\n面向服务：服务提供统一标准的接口，与语言和技术无关\n\n隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n\n\n微服务的上述特征其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。\n因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法其中在Java领域最引人注目的就是SpringCloud提供的方案了\nSpringCloudSpringCloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。\nSpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。\n其中常见的组件包括：\n\n另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：\n\n内容知识\n\n\n技术栈对比\n服务拆分：代码参考：\nGitee：https:&#x2F;&#x2F;gitee.com&#x2F;xn2001&#x2F;cloudcode&#x2F;tree&#x2F;master&#x2F;01-cloud-demo\n\n服务拆分注意事项\n单一职责：不同微服务，不要重复开发相同业务\n数据独立：不要访问其它微服务的数据库\n面向服务：将自己的业务暴露为接口，供其它微服务调用\n\ncloud-demo：父工程，管理依赖\n\norder-service：订单微服务，负责订单相关业务\nuser-service：用户微服务，负责用户相关业务\n\n要求：\n\n订单微服务和用户微服务都必须有各自的数据库，相互独立\n订单服务和用户服务都对外暴露 Restful 的接口\n订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库\n\n微服务项目下，打开 idea 中的 Service，可以很方便的启动。\n\n启动完成后，访问 http://localhost:8080/order/101\n\n远程调用正如上面的服务拆分要求中所提到，\n订单服务如果需要查询用户信息，**只能调用用户服务的 Restful 接口**，不能查询用户数据库\n\n因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）\n\n发送请求，自动序列化为 Java 对象。\n\n启动完成后，访问：http://localhost:8080/order/101\n\n在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要服务注册中心（Eureka）来帮我们解决这个事情。\nEureka注册中心服务调用关系\n\n服务提供者：暴露接口给其它微服务调用\n服务消费者：调用其它微服务提供的接口\n\n服务调用中可能出现的问题\n\nEureka的作用：提供一个注册中心，将所有的服务进行注册，需要时动态调用，每30秒检测一次服务是否正常\n\n\norder-service 如何得知 user-service 实例地址？\n\nuser-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做服务注册\neureka-server 保存服务名称到服务实例地址列表的映射关系\norder-service 根据服务名称，拉取实例地址列表，这个叫服务发现或服务拉取\n\norder-service 如何从多个 user-service 实例中选择具体的实例？\norder-service从实例列表中利用负载均衡算法选中一个实例地址，向该实例地址发起远程调用\norder-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？\n\nuser-service 会每隔一段时间(默认30秒)向 eureka-server 发起请求，报告自己状态，称为心跳\n当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除\norder-service 拉取服务时，就能将故障实例排除了\n\n接下来我们动手实践的步骤包括\n\n搭建注册中心搭建 eureka-server\n引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 server\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n编写启动类\n注意要添加一个 @EnableEurekaServer 注解，开启 eureka 的注册中心功能\npackage cn.itcast.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(EurekaApplication.class,args);\n    &#125;\n&#125;\n\n编写配置文件\n编写一个 application.yml 文件，内容如下：\nserver:\n  port: 10086\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka\n\n其中 default-zone 是因为前面配置类开启了注册中心所需要配置的 eureka 的地址信息，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka 集群时，这里就可以填写多个，使用 “,” 隔开。\n启动完成后，访问 http://localhost:10086/\n\n到这 服务注册中心就搭建完成了\n服务注册\n将 user-service、order-service 都注册到 eureka\n\n引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 client\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n在启动类上添加注解：@EnableEurekaClient\n\n在 application.yml 文件，添加下面的配置：\nspring:\n  application:\n      #name：orderservice\n    name: userservice\neureka:\n  client:\n    service-url: \n      defaultZone: http:127.0.0.1:10086&#x2F;eureka\n\n3个项目启动后，访问 http://localhost:10086/\n\n可以看到eureka本身和另外两个服务都注册成功\n这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。\n\n4个项目启动后，访问 http://localhost:10086/\n\n服务拉取在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用\n\n下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。\n首先给 RestTemplate 这个 Bean 添加一个 @LoadBalanced 注解，用于开启负载均衡。（后面会讲）\n@Bean\n@LoadBalanced\npublic RestTemplate restTemplate()&#123;\n    return new RestTemplate();\n&#125;\n\n修改 OrderService 访问的url路径，用服务名代替ip、端口：\n\nspring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。\nRibbon负载均衡我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？\nSpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。\n源码跟踪为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。\n进入源码跟踪查看底层原理：\n\n这里的 intercept() 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：\n\nrequest.getURI()：获取请求uri，即 http://user-service/user/8\noriginalUri.getHost()：获取uri路径的主机名，其实就是服务id user-service\nthis.loadBalancer.execute()：处理服务id，和用户请求\n\n这里的 this.loadBalancer 是 LoadBalancerClient 类型\n继续跟入 execute() 方法：\n\n\ngetLoadBalancer(serviceId)：根据服务id获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表。\ngetServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。在图中可以看到获取了8082端口的服务\n\n可以看到获取服务时，通过一个 getServer() 方法来做负载均衡:\n\n我们继续跟入：\n\n继续跟踪源码 chooseServer() 方法，发现这么一段代码：\n\n我们看看这个 rule 是谁：\n\n这里的 rule 默认值是一个 RoundRobinRule ，看类的介绍：\n\n流程总结SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。\n基本流程如下：\n\n拦截我们的 RestTemplate 请求 http://userservice/user/1\nRibbonLoadBalancerClient 会从请求url中获取服务名称，也就是 user-service\nDynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表\neureka 返回列表，localhost:8081、localhost:8082\nIRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081\nRibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 http://localhost:8081/user/1，发起真实请求\n\n\n\n负载均衡策略负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：\n\n不同规则的含义如下：\n\n\n\n内置负载均衡规则类\n规则描述\n\n\n\nRoundRobinRule\n简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。\n\n\nAvailabilityFilteringRule\n对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule  规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。\n\n\nWeightedResponseTimeRule\n为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。\n\n\nZoneAvoidanceRule\n以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。\n\n\nBestAvailableRule\n忽略那些短路的服务器，并选择并发数较低的服务器。\n\n\nRandomRule\n随机选择一个可用的服务器。\n\n\nRetryRule\n重试机制的选择逻辑\n\n\n默认的实现就是 ZoneAvoidanceRule，是一种轮询方案。\n自定义策略通过定义 IRule 实现可以修改负载均衡规则，有两种方式：\n1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：\n\n2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：\nuserservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n\n注意：一般情况下都采用默认的负载均衡规则，不做修改。\n饥饿加载当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。\n\nRibbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。\n而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：\nribbon:\n  eager-load:\n    enabled: true\n    clients: \n    \t-userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;-&quot;隔开\n\nNacos注册中心SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，功能相对eureka会有提升\n\n解压启动 Nacos，详细请看 安装指南\n由于nacos默认采用集群启动， 所以需要使用如下命令进行单机启动\nstartup.cmd -m standalone\n\n访问：http://localhost:8848/nacos/ 就可以看到nocas管理界面了\n\n服务注册这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。引入依赖\n在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：\n如果之前引入过eureka的依赖，需要注释掉~\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.6.RELEASE&lt;&#x2F;version&gt;\n    &lt;type&gt;pom&lt;&#x2F;type&gt;\n    &lt;scope&gt;import&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置nacos地址\n在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：\nspring:\n  cloud:\n    nacos:\n      server-addr: 127.0.0.1:8848\n\n项目重新启动后，可以看到三个服务都被注册进了 Nacos\n\n浏览器访问：http://localhost:8080/order/101，正常访问，同时负载均衡也正常。\n分级存储模型一个服务可以有多个实例，例如我们的 user-service，可以有:\n\n127.0.0.1:8081\n127.0.0.1:8082\n127.0.0.1:8083\n\n假如这些实例分布于全国各地的不同机房，例如：\n\n127.0.0.1:8081，在上海机房\n127.0.0.1:8082，在上海机房\n127.0.0.1:8083，在杭州机房\n\nNacos就将同一机房内的实例，划分为一个集群。\n\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。\n\n配置集群接下来我们给 user-service 配置集群\n修改 user-service 的 application.yml 文件，添加集群配置：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称 HZ杭州\n\n重启两个 user-service 实例后，我们再去启动一个上海集群的实例。\n-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH\n\n\n查看 nacos 控制台\n\nNacosRuleRibbon的默认实现 ZoneAvoidanceRule 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 NacosRule 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。\n@Bean\npublic IRule iRule()&#123;\n    &#x2F;&#x2F;默认为轮询规则，这里自定义为随机规则\n    return new NacosRule();\n&#125;\n\n另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。\nuserservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则\n\n然后，再对 orderservice 配置集群。\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n\n现在我启动了四个服务，分别是：\n\norderservice - HZ\nuserservice - HZ\nuserservice1 - HZ\nuserservice2 - SH\n\n访问地址：http://localhost:8080/order/101\n在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。\n我们试着把 userservice、userservice2 停掉。依旧可以访问。\n在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。\n\n权重配置实际部署中会出现这样的场景：\n服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。\n因此，Nacos 提供了权重配置来控制访问频率，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。\n在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。\n\n在弹出的编辑窗口，修改权重\n\n另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到  0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。\n环境隔离Nacos 提供了 namespace 来实现环境隔离功能。\n\nNacos 中可以有多个 namespace\n\nnamespace 下可以有 group、service 等\n\n不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见\n\n环境隔离Nacos 提供了 namespace 来实现环境隔离功能。\n\nNacos 中可以有多个 namespace\nnamespace 下可以有 group、service 等\n不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见\n\n\n\n\n创建namespace默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)\n\n我们可以点击页面新增按钮，添加一个 namespace：\n\n然后，填写表单：\n\n就能在页面看到一个新的 namespace：\n\n配置namespace给微服务配置 namespace 只能通过修改配置来实现。\n例如，修改 order-service 的 application.yml 文件：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ\n        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID\n\n重启 order-service 后，访问控制台。\npublic\n\ndev\n\n此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：\n\n临时实例Nacos 的服务实例分为两种类型：\n\n临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。\n非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\nspring:\n  cloud:\n    nacos:\n      discovery:\n        ephemeral: false # 设置为非临时实例\n\n另外，Nacos 集群**默认采用AP方式(可用性)，当集群中存在非临时实例时，采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）\nNacos配置中心Nacos除了可以做注册中心，同样可以做配置管理来使用。\n当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\nNacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n创建配置在 Nacos 控制面板中添加配置文件\n\n然后在弹出的表单中，填写配置信息：\n\n注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。\n拉取配置首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：\n\n加入 Nacos 配置，它的读取是在 application.yml 之前的：\n\n这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，Nacos 就无法根据地址去获取配置了。\n因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。\n\n引入 nacos-config 依赖\n首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：\n&lt;!--nacos配置管理依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n添加 bootstrap.yml\n然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：\nspring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev \n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n\n根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;作为文件id，来读取配置。\n在这个例子例中，就是去读取 userservice-dev.yaml\n\n使用代码来验证是否拉取成功\n在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：\n@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)\nprivate String dateformat;\n\n@GetMapping(&quot;now&quot;)\npublic String now()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n&#125;\n\n\n启动服务后，访问：http://localhost:8081/user/now\n\n配置热更新我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。\n有两种方式：1. 用 @value 读取配置时，搭配 @RefreshScope；2. 直接用 @ConfigurationProperties 读取配置\n@RefreshScope方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope\n\n@ConfigurationProperties方式二：使用 @ConfigurationProperties 注解读取配置文件，就不需要加 @RefreshScope 注解。\n在 user-service 服务中，添加一个 PatternProperties 类，读取 patterrn.dateformat 属性\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)\npublic class PatternProperties &#123;\n    public String dateformat;\n&#125;\n\n@Autowired\nprivate PatternProperties patternProperties;\n\n@GetMapping(&quot;now2&quot;)\npublic String now2()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));\n&#125;\n\n配置共享其实在服务启动时，nacos 会读取多个配置文件，例如：\n\n[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml\n[spring.application.name].yaml，例如：userservice.yaml\n\n这里的 [spring.application.name].yaml 不包含环境，因此可以被多个环境共享。\n添加一个环境共享配置\n我们在 nacos 中添加一个 userservice.yaml 文件：\n\n在 user-service 中读取共享配置\n在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：\n\n在 user-service 服务中，修改 UserController，添加一个方法：\n\n运行两个 UserApplication，使用不同的profile\n修改 UserApplication2 这个启动项，改变其profile值：\n\n\n这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test\n启动 UserApplication 和 UserApplication2\n访问地址：http://localhost:8081/user/prop，结果：\n\n访问地址：http://localhost:8082/user/prop，结果：\n\n可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。\n上面的都是同一个微服务下，那么不同微服务之间可以环境共享吗？\n通过下面的两种方式来指定：\n\nextension-configs\nshared-configs\n\nspring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        extends-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id\n\nspring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        shared-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id\n\n配置优先级当 nacos、服务本地同时出现相同属性时，优先级有高低之分。\n\n更细致的配置\n\nNacos集群架构介绍\n其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。\n\n三个 Nacos 节点的地址\n\n\n\n节点\nip\nport\n\n\n\nnacos1\n192.168.150.1\n8845\n\n\nnacos2\n192.168.150.1\n8846\n\n\nnacos3\n192.168.150.1\n8847\n\n\n初始化数据库Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。\n首先新建一个数据库，命名为 nacos，而后导入下面的 SQL\nCREATE TABLE &#96;config_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) DEFAULT NULL,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  &#96;c_desc&#96; varchar(256) DEFAULT NULL,\n  &#96;c_use&#96; varchar(64) DEFAULT NULL,\n  &#96;effect&#96; varchar(64) DEFAULT NULL,\n  &#96;type&#96; varchar(64) DEFAULT NULL,\n  &#96;c_schema&#96; text,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_aggr&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_beta&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_tag&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_tags_relation&#96; (\n  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,\n  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,\n  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (&#96;nid&#96;),\n  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;group_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;his_config_info&#96; (\n  &#96;id&#96; bigint(64) unsigned NOT NULL,\n  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  &#96;data_id&#96; varchar(255) NOT NULL,\n  &#96;group_id&#96; varchar(128) NOT NULL,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL,\n  &#96;md5&#96; varchar(32) DEFAULT NULL,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;src_user&#96; text,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL,\n  &#96;op_type&#96; char(10) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;nid&#96;),\n  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),\n  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),\n  KEY &#96;idx_did&#96; (&#96;data_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;tenant_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;\n\n\nCREATE TABLE &#96;tenant_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,\n  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,\n  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,\n  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,\n  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;\n\nCREATE TABLE &#96;users&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,\n\t&#96;password&#96; varchar(500) NOT NULL,\n\t&#96;enabled&#96; boolean NOT NULL\n);\n\nCREATE TABLE &#96;roles&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL,\n\t&#96;role&#96; varchar(50) NOT NULL,\n\tUNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE\n);\n\nCREATE TABLE &#96;permissions&#96; (\n    &#96;role&#96; varchar(50) NOT NULL,\n    &#96;resource&#96; varchar(255) NOT NULL,\n    &#96;action&#96; varchar(8) NOT NULL,\n    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE\n);\n\nINSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);\n\nINSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);\n\n配置Nacos进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf\n\n添加内容\n127.0.0.1:8845\n127.0.0.1.8846\n127.0.0.1.8847\n\n然后修改 application.properties 文件，添加数据库配置\nspring.datasource.platform&#x3D;mysql\ndb.num&#x3D;1\ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC\ndb.user.0&#x3D;root\ndb.password.0&#x3D;123456\n\n\n\n将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\n\n然后分别修改三个文件夹中的 application.properties，\nnacos1\nserver.port&#x3D;8845\n\nnacos2\nserver.port&#x3D;8846\n\nnacos3\nserver.port&#x3D;8847\n\n然后分别启动三个 nacos\nstartup.cmd\n\nNginx反向代理修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下\nupstream nacos-cluster &#123;\n    server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n&#125;\n\nserver &#123;\n    listen       80;\n    server_name  localhost;\n\n    location &#x2F;nacos &#123;\n        proxy_pass http:&#x2F;&#x2F;nacos-cluster;\n    &#125;\n&#125;\n\n启动 nginx，在浏览器访问：http://localhost/nacos\n在代码中的 application.yml 文件配置改为如下：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n\n实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。\nFeign远程调用我们以前利用 RestTemplate 发起远程调用的代码：\n\n\n代码可读性差，编程体验不统一\n参数复杂URL难以维护\n\nFeign 是一个声明式的 http 客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。\n\nFeign使用引入依赖\n我们在 order-service 引入 feign 依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n添加注解\n在 order-service 启动类添加注解开启 Feign\n\n请求接口\n在 order-service 中新建一个接口，内容如下\npackage cn.itcast.order.clients;\n\nimport cn.itcast.order.pojo.User;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(&quot;userservice&quot;)\npublic interface UserClient &#123;\n    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\n    User findById(@PathVariable(&quot;id&quot;) Long id);\n&#125;\n\n@FeignClient(&quot;userservice&quot;)：其中参数填写的是微服务名\n@GetMapping(&quot;/user/&#123;id&#125;&quot;)：其中参数填写的是请求路径\n这个客户端主要是基于 SpringMVC 的注解 @GetMapping 来声明远程调用的信息\nFeign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。\n测试\n@Autowired\nprivate UserClient userClient;\n\npublic Order queryOrderById(Long orderId) &#123;\n    &#x2F;&#x2F; 1.查询订单\n    Order order &#x3D; orderMapper.findById(orderId);\n    &#x2F;&#x2F; 2.用feign进行远程调用，替代之前的RestTemplate\n    User user &#x3D; userClient.findById(order.getUserId());\n    order.setUser(user);\n    &#x2F;&#x2F; 4.返回\n    return order;\n&#125;\n\n自定义配置Feign 可以支持很多的自定义配置，如下表所示：\n\n\n\n类型\n作用\n说明\n\n\n\nfeign.Logger.Level\n修改日志级别\n包含四种不同的级别：NONE、BASIC、HEADERS、FULL\n\n\nfeign.codec.Decoder\n响应结果的解析器\nhttp远程调用的结果做解析，例如解析json字符串为java对象\n\n\nfeign.codec.Encoder\n请求参数编码\n将请求参数编码，便于通过http请求发送\n\n\nfeign.Contract\n支持的注解格式\n默认是SpringMVC的注解\n\n\nfeign.Retryer\n失败重试机制\n请求失败的重试机制，默认是没有，不过会使用Ribbon的重试\n\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。\n基于配置文件修改 feign 的日志级别可以针对单个服务：\nfeign:  \n  client:\n    config: \n      userservice: # 针对某个微服务的配置\n        loggerLevel: FULL #  日志级别 \n\n也可以针对所有服务：\nfeign:  \n  client:\n    config: \n      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n        loggerLevel: FULL #  日志级别\n\n而日志的级别分为四种：\n\nNONE：不记录任何日志信息，这是默认值。\nBASIC：仅记录请求的方法，URL以及响应状态码和执行时间\nHEADERS：在BASIC的基础上，额外记录了请求和响应的头信息\nFULL：记录所有请求和响应的明细，包括头信息、请求体、元数据\n\n也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象\npublic class DefaultFeignConfiguration  &#123;\n    @Bean\n    public Logger.Level feignLogLevel()&#123;\n        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC\n    &#125;\n&#125;\n\n如果要全局生效，将其放到启动类的 @EnableFeignClients 这个注解中：\n@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) \n\n如果是局部生效，则把它放到对应的 @FeignClient 这个注解中：\n@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) \n\n性能优化Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：\n\nURLConnection：默认实现，不支持连接池\nApache HttpClient ：支持连接池\nOKHttp：支持连接池\n\n因此提高 Feign 性能的主要手段就是使用连接池代替默认的 URLConnection\n另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。\n这里我们用 Apache 的HttpClient来演示连接池。\n在 order-service 的 pom 文件中引入 HttpClient 依赖\n&lt;!--httpClient的依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置连接池\n在 order-service 的 application.yml 中添加配置\nfeign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n\n在 FeignClientFactoryBean 中的 loadBalance 方法中打断点\n\nDebug 方式启动 order-service  服务，可以看到这里的 client，底层就是 HttpClient\n\n最佳实践继承方式一样的代码可以通过继承来共享：\n1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明\n2）Feign 客户端、Controller 都集成该接口\n\n优点\n\n简单\n实现了代码共享\n\n缺点\n\n服务提供方、服务消费方紧耦合\n参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解\n\n抽取方式将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。\n例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。\n\n接下来我们就用该方法在代码中实现\n首先创建一个 module，命名为 feign-api\n\n在 feign-api 中然后引入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\norder-service中 的 UserClient、User 都复制到 feign-api 项目中\n\n接下来在 order-service 中使用 feign-api\n由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service  中引入 feign-api\n&lt;dependency&gt;\n    &lt;groupId&gt;com.xn2001.feign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n修改注解\n当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。\n修改 order-service 启动类上的 @EnableFeignClients 注解\n@EnableFeignClients(basePackages &#x3D; &quot;com.xn2001.feign.clients&quot;)\n\nGateway网关\n\n\n\n\n\n\n\n\n代码参考：\nGitee：https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway\nGitHub：https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway\nSpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring  Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API  路由管理方式。\nGateway 网关是我们服务的守门神，所有微服务的统一入口。\n网关的核心功能特性：\n\n请求路由\n权限控制\n限流\n\n\n权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n在 SpringCloud 中网关的实现包括两种：\n\ngateway\nzuul\n\nZuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。\n入门使用\n创建 SpringBoot 工程 gateway，引入网关依赖\n编写启动类\n编写基础配置和路由规则\n启动网关服务进行测试\n\n&lt;!--网关--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--nacos服务发现依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n创建 application.yml 文件，内容如下：\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求\n\n我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。\n上面的例子中，我们将 /user/** 开头的请求，代理到 lb://userservice，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。\n重启网关，访问 http://localhost:10010/user/1 时，符合 /user/** 规则，请求转发到 uri：http://userservice/user/1\n\n多个 predicates 的话，要同时满足规则，下文有例子。\n流程图\n路由配置包括：\n\n路由id：路由的唯一标示\n路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡\n路由断言（predicates）：判断路由的规则\n路由过滤器（filters）：对请求或响应做处理\n\n断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。\n例如 Path=/user/** 是按照路径匹配，这个规则是由\norg.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个\n\n\n\n名称\n说明\n示例\n\n\n\nAfter\n是某个时间点后的请求\n-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nBefore\n是某个时间点之前的请求\n-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n\nBetween\n是某两个时间点之前的请求\n-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nCookie\n请求必须包含某些cookie\n- Cookie&#x3D;chocolate, ch.p\n\n\nHeader\n请求必须包含某些header\n- Header&#x3D;X-Request-Id, \\d+\n\n\nHost\n请求必须是访问某个host（域名）\n-  Host&#x3D;**.somehost.org, **.anotherhost.org\n\n\nMethod\n请求方式必须是指定方式\n- Method&#x3D;GET,POST\n\n\nPath\n请求路径必须符合指定规则\n- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**\n\n\nQuery\n请求参数必须包含指定参数\n- Query&#x3D;name, Jack或者-  Query&#x3D;name\n\n\nRemoteAddr\n请求者的ip必须是指定范围\n- RemoteAddr&#x3D;192.168.1.1&#x2F;24\n\n\nWeight\n权重处理\n\n\n\n\n\n\n\n\n\n\n\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\n一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。\npredicates:\n  - Path&#x3D;&#x2F;order&#x2F;**\n  - After&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。\n过滤器工厂GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。\n\nSpring提供了31种不同的路由过滤器工厂。\n\n\n\n\n\n\n\n\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories\n\n\n\n名称\n说明\n\n\n\nAddRequestHeader\n给当前请求添加一个请求头\n\n\nRemoveRequestHeader\n移除请求中的一个请求头\n\n\nAddResponseHeader\n给响应结果中添加一个响应头\n\n\nRemoveResponseHeader\n从响应结果中移除有一个响应头\n\n\nRequestRateLimiter\n限制请求的流量\n\n\n下面我们以 AddRequestHeader 为例：\n\n需求：给所有进入 userservice 的请求添加一个请求头：sign=xn2001.com is eternal\n只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。\nspring:\n  cloud:\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求\n          filters:\n            - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头\n\n如何验证，我们修改 userservice 中的一个接口\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value &#x3D; &quot;sign&quot;, required &#x3D; false) String sign) &#123;\n    log.warn(sign);\n    return userService.queryById(id);\n&#125;\n\n重启两个服务，访问：http://localhost:10010/user/1\n可以看到控制台打印出了这个请求头\n\n当然，Gateway 也是有全局过滤器的，如果要对所有的路由都生效，则可以将过滤器工厂写到 default-filters 下：\nspring:\n  cloud:\n    gateway:\n      default-filters:\n        - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头\n\n全局过滤器上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GlobalFilter 的逻辑可以写代码来自定义规则；而 GatewayFilter 通过配置定义，处理逻辑是固定的。\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件\n\n参数中是否有 authorization\nauthorization 参数值是否为 admin\n\n如果同时满足则放行，否则拦截。\n@Component\npublic class AuthorizeFilter implements GlobalFilter, Ordered &#123;\n\n    &#x2F;&#x2F; 测试：http:&#x2F;&#x2F;localhost:10010&#x2F;order&#x2F;101?authorization&#x3D;admin\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;\n        &#x2F;&#x2F; 获取第一个 authorization 参数\n        String authorization &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;authorization&quot;);\n        if (&quot;admin&quot;.equals(authorization))&#123;\n            &#x2F;&#x2F; 放行\n            return chain.filter(exchange);\n        &#125;\n        &#x2F;&#x2F; 设置拦截状态码信息\n        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n        &#x2F;&#x2F; 设置拦截\n        return exchange.getResponse().setComplete();\n    &#125;\n\n    &#x2F;&#x2F; 设置过滤器优先级，值越低优先级越高\n    &#x2F;&#x2F; 也可以使用 @Order 注解\n    @Override\n    public int getOrder() &#123;\n        return 0;\n    &#125;\n&#125;\n\n过滤器顺序请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；\n请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.\n\n排序的规则是什么呢？\n\n每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。\nGlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。\n路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。\n当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。\n\n跨域问题不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。\nspring:\n  cloud:\n    gateway:\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          &#39;[&#x2F;**]&#39;:\n            allowedOrigins: # 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站\n              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - &quot;GET&quot;\n              - &quot;POST&quot;\n              - &quot;DELETE&quot;\n              - &quot;PUT&quot;\n              - &quot;OPTIONS&quot;\n            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n","slug":"学习笔记/SpringCloud","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"8c6c59136f9c0c8c29b87ea646eed9d1","title":"操作系统","content":"操作系统\n","slug":"学习笔记/操作系统","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"},{"id":"11c0f2fa5655c019aeb2222b34a90ab0","title":"数据结构与算法","content":"数据结构与算法\n","slug":"学习笔记/数据结构与算法","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"计网\n","slug":"学习笔记/计网","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"SpringMVC笔记MVC架构SSM : Spring+SpringMVC+Mybatis    (JavaWeb做项目)\n重点：\n\n\n\n\n\n\n\n\n\nSpringMVC的执行流程\nSSM框架的整合\n\n**MVC : 模型(dao,service)    视图(jsp)    控制器(Servlet)**，是一种软件设计规范。（Servlet重点 : 转发，重定向）\n是将业务逻辑、数据、显示分离的方法来组织代码。\nMVC主要作用是降低了视图与业务逻辑间的双向偶合。\nMVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。\n\n\n\n\n\n\n\n\n\n\nModel（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n\nJSP : 本质就是一个Servlet\nModel1时代\n在web早期的开发中，通常采用的都是Model1。\nModel1中，主要分为两层，视图层和模型层。\n\n\n\n\n\n\n\n\n\n\n\nModel1优点：架构简单，比较适合小型项目开发；\nModel1缺点：JSP职责不单一，职责过重，不便于维护；\nModel2时代Model2把一个项目分成三部分，包括视图、控制、模型。\n\n\n\n\n\n\n\n\n\n\n\n用户发请求\nServlet接收请求数据，并调用对应的业务逻辑方法\n业务处理完毕，返回更新后的数据给servlet\nservlet转向到JSP，由JSP来渲染页面\n响应给前端更新后的页面\n\n职责分析 : \nController：控制器\n\n\n\n\n\n\n\n\n\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：模型\n\n\n\n\n\n\n\n\n\n\n业务逻辑\n保存数据的状态\n\nView：视图\n\n\n\n\n\n\n\n\n\n\n显示页面\n\nModel2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model  1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\nServlet新建一个Maven工程当做父工程！ pom依赖！\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.12&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.5&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.2&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！\n\n导入servlet 和 jsp 的 jar 依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n编写一个Servlet类，用来处理用户的请求\npackage com.lc.servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\npublic class HelloServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        &#x2F;&#x2F;1.获取前端参数\n        String method &#x3D; req.getParameter(&quot;method&quot;);\n        if (method.equals(&quot;add&quot;))&#123;\n            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);\n        &#125;\n        if (method.equals(&quot;delete&quot;))&#123;\n            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);\n        &#125;\n        &#x2F;&#x2F;2.调用业务层\n        &#x2F;&#x2F;3.视图转发或者重定向\n        req.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;).forward(req,resp);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        doGet(req,resp);\n    &#125;\n&#125;\n\n编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n$&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n在web.xml中注册Servlet\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;com.lc.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n    &lt;session-config&gt;\n        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;\n    &lt;&#x2F;session-config&gt;\n    &lt;welcome-file-list&gt;\n        &lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;\n    &lt;&#x2F;welcome-file-list&gt;\n&lt;&#x2F;web-app&gt;\n\n配置Tomcat，并启动测试即可\n\nlocalhost:8080&#x2F;user?method&#x3D;add\nlocalhost:8080&#x2F;user?method&#x3D;delete\n\nMVC框架要做哪些事情\n\n\n\n\n\n\n\n\n\n将url映射到java类或java类的方法 .\n封装用户提交的数据 .\n处理请求—调用相关的业务处理—封装响应数据 .\n将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .\n\n认识SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\n为什么学习SpringMVCSpring MVC的特点：\n\n\n\n\n\n\n\n\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) ,  使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .\n**最重要的一点还是用的人多 , 使用的公司多 **\n中心控制器​    Spring的web框架围绕DispatcherServlet设计。  DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java  5或者以上版本的用户可以采用基于注解的controller声明方式。\n​     Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。\n\n​    当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n\nSpringMVC执行原理\n简要分析执行流程\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\n\n\n\n\n\n\n\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\nHandler让具体的Controller执行。\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n最终视图呈现给用户。\n基于注解开发SpringMVC新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！\n建立包结构 com.kuang.controller\n由于Maven可能存在资源过滤的问题，我们将配置完善\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！\n\n配置web.xml注意点：\n\n注意web.xml版本问题，要最新版！\n注册DispatcherServlet\n关联SpringMVC的配置文件\n启动级别为1\n映射路径为 &#x2F; 【不要用&#x2F;*，会404】\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;!--1.注册servlet--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;!--所有请求都会被springmvc拦截 --&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n&#x2F; 和 &#x2F;* 的区别：\n\n\n\n\n\n\n\n\n\n&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 会匹配* .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。\n添加Spring MVC配置文件\n让IOC的注解生效\n静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..\nMVC的注解驱动\n配置视图解析器\n\n在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;\n    &lt;!-- 让Spring MVC不处理静态资源 --&gt;\n    &lt;mvc:default-servlet-handler &#x2F;&gt;\n    &lt;!--\n    支持mvc注解驱动\n        在spring中一般采用@RequestMapping注解来完成映射关系\n        要想使@RequestMapping注解生效\n        必须向上下文中注册DefaultAnnotationHandlerMapping\n        和一个AnnotationMethodHandlerAdapter实例\n        这两个实例分别在类级别和方法级别处理。\n        而annotation-driven配置帮助我们自动完成上述两个实例的注入。\n     --&gt;\n    &lt;mvc:annotation-driven &#x2F;&gt;\n    &lt;!-- 视图解析器 --&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;\n          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!-- 前缀 --&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;\n        &lt;!-- 后缀 --&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。\n创建Controller编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范\npackage com.kuang.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\n@RequestMapping(&quot;&#x2F;HelloController&quot;)\npublic class HelloController &#123;\n    &#x2F;&#x2F;真实访问地址 : 项目名&#x2F;HelloController&#x2F;hello\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String sayHello(Model model)&#123;\n        &#x2F;&#x2F;向模型中添加属性msg与值，可以在JSP页面中取出并渲染\n        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;);\n        &#x2F;&#x2F;web-inf&#x2F;jsp&#x2F;hello.jsp\n        return &quot;hello&quot;;\n    &#125;\n&#125;\n\n\n@Controller是为了让Spring IOC容器初始化时自动扫描到；\n@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是&#x2F;HelloController&#x2F;hello；\n方法中声明Model类型的参数是为了把Action中的数据带到视图中；\n方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF&#x2F;jsp&#x2F;hello.jsp。\n\n创建视图层在WEB-INF&#x2F; jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；\n可以通过EL表示取出Model中存放的值，或者对象；\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;SpringMVC&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    $&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n配置Tomcat运行配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！\n\n总结实现步骤其实非常的简单：\n\n新建一个web项目\n导入相关jar包\n编写web.xml , 注册DispatcherServlet\n编写springmvc配置文件\n接下来就是去创建对应的控制类 , controller\n最后完善前端视图和controller之间的对应\n测试运行调试.\n\n使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\nController控制器Controller\n控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。\n控制器负责解析用户的请求并将其转换为一个模型。\n在Spring MVC中一个控制器类可以包含多个方法\n在Spring MVC中，对于Controller的配置方式有很多种\n\nController的配置方式实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；\n&#x2F;&#x2F;实现该接口的类获得控制器功能\npublic interface Controller &#123;\n    &#x2F;&#x2F;处理请求且返回一个模型与视图对象\n    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;\n&#125;\n\n测试\nweb.xml : \n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;!--1.配置DispatcherServlet--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\nspringmvc-servlet.xml :\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n    &lt;!--&lt;context:component-scan base-package&#x3D;&quot;com.lc.controller&quot; &#x2F;&gt;--&gt;\n    &lt;!--&lt;mvc:default-servlet-handler &#x2F;&gt;--&gt;\n    &lt;!--&lt;mvc:annotation-driven &#x2F;&gt;--&gt;\n    &lt;!-- 视图解析器 --&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;\n          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!-- 前缀 --&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;\n        &lt;!-- 后缀 --&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n编写一个Controller类，ControllerTest1 :\n&#x2F;&#x2F;定义控制器\n&#x2F;&#x2F;注意点：不要导错包，实现Controller接口，重写方法；\npublic class ControllerTest1 implements Controller &#123;\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        &#x2F;&#x2F;返回一个模型视图对象\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);\n        mv.setViewName(&quot;test&quot;);\n        return mv;\n    &#125;\n&#125;\n\n编写完毕后，去Spring配置文件springmvc-servlet.xml中注册请求的bean；name对应请求路径，class对应处理请求的类 :\n&lt;bean name&#x3D;&quot;&#x2F;t1&quot; class&#x3D;&quot;com.kuang.controller.ControllerTest1&quot;&#x2F;&gt;\n\n编写前端test.jsp，注意在WEB-INF&#x2F;jsp目录下编写，对应我们的视图解析器 :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    Welcome to $&#123;msg&#125; !\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n编写前端test.jsp，注意在WEB-INF&#x2F;jsp目录下编写，对应我们的视图解析器 :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    Welcome to $&#123;msg&#125; !\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n配置Tomcat运行测试 :\n\n说明 :\n\n实现接口Controller定义控制器是较老的办法\n缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；\n\n使用注解@Controller@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；(@Component、@Repository、@Service、@Controller )\nSpring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。\n&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;\n\n增加一个ControllerTest2类，使用注解实现 : \n&#x2F;&#x2F;@Controller注解的类会自动添加到Spring上下文中\n@Controller &#x2F;&#x2F;代表这个类会被Spring接管，被这个注解的类中的方法，如果返回值为String，并且有页面可以跳转，就会被视图解析器解析\npublic class ControllerTest2&#123;\n    &#x2F;&#x2F;映射访问路径\n    @RequestMapping(&quot;&#x2F;t2&quot;)\n    public String index(Model model)&#123;\n        &#x2F;&#x2F;Spring MVC会自动实例化一个Model对象用于向视图中传值\n        model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);\n        &#x2F;&#x2F;返回视图位置\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n运行tomcat测试 :\n\n可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。\nRequestMapping@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类，表示类中所有响应请求的方法都以该地址作为父路径。\n只注解在方法上面 :\n@Controller\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;h1&quot;)\n    public String test()&#123;\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n访问路径：http://localhost:8080 &#x2F; 项目名 &#x2F; h1\n同时注解类与方法 :\n@Controller\n@RequestMapping(&quot;&#x2F;admin&quot;)\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;h1&quot;)\n    public String test()&#123;\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n访问路径：http://localhost:8080 &#x2F; 项目名&#x2F; admin &#x2F;h1 , 需要先指定类的路径再指定方法的路径；\nRestFul风格概念\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能\n\n\n\n\n\n\n\n\n\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n\n\n\n\n\n\n\n\n\nhttp://127.0.0.1/item/queryItem.action?id=1      查询,GET\nhttp://127.0.0.1/item/saveItem.action                 新增,POST\nhttp://127.0.0.1/item/updateItem.action            更新,POST\nhttp://127.0.0.1/item/deleteItem.action?id=1    删除,GET或POST\n使用RestFul操作资源 ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n\n\n\n\n\n\n\n\n\n http://127.0.0.1/item/1         查询,GET http://127.0.0.1/item            新增,POST http://127.0.0.1/item            更新,PUT http://127.0.0.1/item/1        删除,DELETE\n传统方法新建RestFulController :\npackage com.lc.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\npublic class RestFulController &#123;\n    @RequestMapping(&quot;&#x2F;add&quot;)\n    public String test1(int a, int b, Model model)&#123;\n        int res &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n进行访问 :\n\n需要使用?a&#x3D;X&amp;b&#x3D;X传参\nRestFul操作资源方法使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。\n@Controller\npublic class RestFulController &#123;\n    @RequestMapping(&quot;&#x2F;add&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;)\n    public String test1(@PathVariable int a,@PathVariable int b, Model model)&#123;\n        int res &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n进行访问 :\n\n设置了访问路径为add&#x2F;{a}&#x2F;{b}即可\n需要传入指定的参数类型，若传入的参数类型错误则会报400错误 !\nmethod指定请求类型使用method属性指定请求类型 :\n 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等\n 映射访问路径设为POST请求\n@RequestMapping(value &#x3D; &quot;&#x2F;add&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;,method &#x3D; RequestMethod.POST)\n    public String test1(@PathVariable int a,@PathVariable int b, Model model)&#123;\n        int res &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);\n        return &quot;test&quot;;\n    &#125;\n\n我们使用浏览器地址栏进行访问默认是Get请求，会报错405 ：\n\n如果将POST修改为GET则可以正常访问了 :\n@RequestMapping(value &#x3D; &quot;&#x2F;add&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;,method &#x3D; RequestMethod.GET)\n    public String test1(@PathVariable int a,@PathVariable int b, Model model)&#123;\n        int res &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);\n        return &quot;test&quot;;\n    &#125;\n\n\n小结：\nSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\n使用注解指定请求类型\n\n\n\n\n\n\n\n\n@GetMapping  &#x3D;  @RequestMapping(method &#x3D;RequestMethod.GET) \n@PostMapping   &#x3D;  @RequestMapping(method &#x3D;RequestMethod.POST) \n@PutMapping  &#x3D; @RequestMapping(method &#x3D;RequestMethod.PUT) \n@DeleteMapping  &#x3D; @RequestMapping(method &#x3D;RequestMethod.DELETE) \n@PatchMapping  &#x3D; @RequestMapping(method &#x3D;RequestMethod.PATCH) \n修改Controller\n@PostMapping(&quot;&#x2F;add&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;)\npublic String test1(@PathVariable int a,@PathVariable int b, Model model)&#123;\n    int res &#x3D; a+b;\n    model.addAttribute(&quot;msg&quot;,&quot;结果1为&quot;+res);\n    return &quot;test&quot;;\n&#125;\n@GetMapping(&quot;&#x2F;add&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;)\npublic String test2(@PathVariable int a,@PathVariable int b, Model model)&#123;\n    int res &#x3D; a+b;\n    model.addAttribute(&quot;msg&quot;,&quot;结果2为&quot;+res);\n    return &quot;test&quot;;\n&#125;\n\n添加a.jsp，表单为提交请求 :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n &lt;form action&#x3D;&quot;&#x2F;add&#x2F;1&#x2F;6&quot; method&#x3D;&quot;post&quot;&gt;\n     &lt;input type&#x3D;&quot;submit&quot;&gt;\n &lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n运行 :\n通过状态栏访问为get操作，跳转结果2（@GetMapping）:\n\n访问a.jsp，点击提交跳转，跳转结果1（@PostMapping）:\n\n\n使用路径变量的好处简洁、高效、安全\n\n\n\n\n\n\n\n\n\n使路径变得更加简洁；\n获得参数更加方便，框架会自动进行类型转换。\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是&#x2F;commit&#x2F;1&#x2F;a，则路径与方法不匹配，而不会是参数转换失败。\n安全，不会暴露变量名\n结果跳转方式ModelAndView页面 : {视图解析器前缀} + viewName +{视图解析器后缀}\n&lt;!-- 视图解析器 --&gt;\n&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;\n      id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n    &lt;!-- 前缀 --&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;\n    &lt;!-- 后缀 --&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n对应的controller类 :\npublic class ControllerTest1 implements Controller &#123;\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        &#x2F;&#x2F;返回一个模型视图对象\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);\n        mv.setViewName(&quot;test&quot;);\n        return mv;\n    &#125;\n&#125;\n\n\n\n重定向和转发无视图解析器通过SpringMVC来实现转发和重定向 - 无需视图解析器；\n删除视图解析器，编写Controller代码 :\n@Controller\npublic class ResultSpringMVC &#123;\n    @RequestMapping(&quot;&#x2F;m1&#x2F;t1&quot;)\n    public String test(Model model)&#123;\n        &#x2F;&#x2F;转发\n        model.addAttribute(&quot;msg&quot;,&quot;ModelTest&quot;);\n        return &quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;m1&#x2F;t2&quot;)\n    public String test2(Model model)&#123;\n        &#x2F;&#x2F;转发二\n        model.addAttribute(&quot;msg&quot;,&quot;ModelTest&quot;);\n        return &quot;forward:&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;m1&#x2F;t3&quot;)\n    public String test3(Model model)&#123;\n        &#x2F;&#x2F;重定向\n        return &quot;redirect:&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;;\n    &#125;\n&#125;\n\n有视图解析器通过SpringMVC来实现转发和重定向 - 有视图解析器；\n重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.\n可以重定向到另外一个请求实现 . 直接返回redirect:+路径文件即可。\n@Controller\npublic class ResultSpringMVC2 &#123;\n    @RequestMapping(&quot;&#x2F;rsm2&#x2F;t1&quot;)\n    public String test1()&#123;\n        &#x2F;&#x2F;转发\n        return &quot;test&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;rsm2&#x2F;t2&quot;)\n    public String test2()&#123;\n        &#x2F;&#x2F;重定向\n        return &quot;redirect:&#x2F;index.jsp&quot;;\n        &#x2F;&#x2F;return &quot;redirect:hello.do&quot;; &#x2F;&#x2F;hello.do为另一个请求&#x2F;\n    &#125;\n&#125;\n\n\n\n数据处理处理提交数据1.提交的域名称和处理方法参数名一致提交数据 : http://localhost:8080/hello?name=kuangshen\n处理方法 :\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic String hello(String name)&#123;\n    System.out.println(name);\n    return &quot;hello&quot;;\n&#125;\n\n2、提交的域名称和处理方法参数名不一致提交数据 : @RequestParam注解 括号内存入提交的域名称) :\n&#x2F;&#x2F;@RequestParam(&quot;username&quot;) : username提交的域的名称 .\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic String hello(@RequestParam(&quot;username&quot;) String name)&#123;\n    System.out.println(name);\n    return &quot;hello&quot;;\n&#125;\n\n3、提交的是一个对象要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n实体类 ：\npublic class User &#123;\n    private int id;\n    private String name;\n    private int age;\n    &#x2F;&#x2F;构造\n    &#x2F;&#x2F;get&#x2F;set\n    &#x2F;&#x2F;tostring()\n&#125;\n\n提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15\n处理方法：\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic String user(User user)&#123;\n    System.out.println(user);\n    return &quot;hello&quot;;\n&#125;\n\n后台输出 : User { id&#x3D;1, name&#x3D;’kuangshen’, age&#x3D;15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端通过ModelAndViewpublic class ControllerTest1 implements Controller &#123;\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        &#x2F;&#x2F;返回一个模型视图对象\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);\n        mv.setViewName(&quot;test&quot;);\n        return mv;\n    &#125;\n&#125;\n\n通过ModelMap@RequestMapping(&quot;&#x2F;hello&quot;)\npublic String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;\n    &#x2F;&#x2F;封装要显示到视图中的数据\n    &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name);\n    model.addAttribute(&quot;name&quot;,name);\n    System.out.println(name);\n    return &quot;hello&quot;;\n&#125;\n\n通过Model@RequestMapping(&quot;&#x2F;ct2&#x2F;hello&quot;)\npublic String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;\n    &#x2F;&#x2F;封装要显示到视图中的数据\n    &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name);\n    model.addAttribute(&quot;msg&quot;,name);\n    System.out.println(name);\n    return &quot;test&quot;;\n&#125;\n\n对比\n\n\n\n\n\n\n\n\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；\nModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；\nModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n乱码问题解决当我们在前端显示中文时，可能会出现乱码情况\nJavaWeb过滤器解决编写过滤器代码 :\npackage com.lc.filter;\nimport javax.servlet.*;\nimport java.io.IOException;\npublic class EncodingFilter implements Filter &#123;\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#125;\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);\n        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    &#125;\n    public void destroy() &#123;\n    &#125;\n&#125;\n\n在web.xml中配置 :\n&lt;filter&gt;\n    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;com.lc.filter.EncodingFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n配置SpringMVC的乱码过滤修改了xml文件 : \n&lt;filter&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n\n有些极端情况下.这个过滤器对get的支持不好 .\n其他方法修改tomcat配置文件service.xml ： 设置编码！\n&lt;Connector URIEncoding&#x3D;&quot;utf-8&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;\n           connectionTimeout&#x3D;&quot;20000&quot;\n           redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;\n\n自定义过滤器，然后在web.xml中配置过滤器\npackage com.kuang.filter;\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\n&#x2F;**\n * 解决get和post请求 全部乱码的过滤器\n *&#x2F;\npublic class GenericEncodingFilter implements Filter &#123;\n    @Override\n    public void destroy() &#123;\n    &#125;\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        &#x2F;&#x2F;处理response的字符编码\n        HttpServletResponse myResponse&#x3D;(HttpServletResponse) response;\n        myResponse.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n        &#x2F;&#x2F; 转型为与协议相关对象\n        HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) request;\n        &#x2F;&#x2F; 对request包装增强\n        HttpServletRequest myrequest &#x3D; new MyRequest(httpServletRequest);\n        chain.doFilter(myrequest, response);\n    &#125;\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#125;\n&#125;\n&#x2F;&#x2F;自定义request对象，HttpServletRequest的包装类\nclass MyRequest extends HttpServletRequestWrapper &#123;\n    private HttpServletRequest request;\n    &#x2F;&#x2F;是否编码的标记\n    private boolean hasEncode;\n    &#x2F;&#x2F;定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰\n    public MyRequest(HttpServletRequest request) &#123;\n        super(request);&#x2F;&#x2F; super必须写\n        this.request &#x3D; request;\n    &#125;\n    &#x2F;&#x2F; 对需要增强方法 进行覆盖\n    @Override\n    public Map getParameterMap() &#123;\n        &#x2F;&#x2F; 先获得请求方式\n        String method &#x3D; request.getMethod();\n        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;\n            &#x2F;&#x2F; post请求\n            try &#123;\n                &#x2F;&#x2F; 处理post乱码\n                request.setCharacterEncoding(&quot;utf-8&quot;);\n                return request.getParameterMap();\n            &#125; catch (UnsupportedEncodingException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;\n            &#x2F;&#x2F; get请求\n            Map&lt;String, String[]&gt; parameterMap &#x3D; request.getParameterMap();\n            if (!hasEncode) &#123; &#x2F;&#x2F; 确保get手动编码逻辑只运行一次\n                for (String parameterName : parameterMap.keySet()) &#123;\n                    String[] values &#x3D; parameterMap.get(parameterName);\n                    if (values !&#x3D; null) &#123;\n                        for (int i &#x3D; 0; i &lt; values.length; i++) &#123;\n                            try &#123;\n                                &#x2F;&#x2F; 处理get乱码\n                                values[i] &#x3D; new String(values[i]\n                                        .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);\n                            &#125; catch (UnsupportedEncodingException e) &#123;\n                                e.printStackTrace();\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n                hasEncode &#x3D; true;\n            &#125;\n            return parameterMap;\n        &#125;\n        return super.getParameterMap();\n    &#125;\n    &#x2F;&#x2F;取一个值\n    @Override\n    public String getParameter(String name) &#123;\n        Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();\n        String[] values &#x3D; parameterMap.get(name);\n        if (values &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        return values[0]; &#x2F;&#x2F; 取回参数的第一个值\n    &#125;\n    &#x2F;&#x2F;取所有值\n    @Override\n    public String[] getParameterValues(String name) &#123;\n        Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();\n        String[] values &#x3D; parameterMap.get(name);\n        return values;\n    &#125;\n&#125;\n\n网上大神所写，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！\nJSON什么是JSON\n\n\n\n\n\n\n\n\n JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。\n 采用完全独立于编程语言的文本格式来存储和表示数据。\n 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。\n 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都能通过 JSON来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：\n\n\n\n\n\n\n\n\n\n对象表示为键值对，数据由逗号分隔\n花括号保存对象\n方括号保存数组\nJSON键值对是保存 JavaScript对象的一种方式,和 JavaScript 对象的写法大同小异，键&#x2F;值对组合中的键名写在前并用双引号“”包裹，用冒号:分隔，然后紧接着值：\n\n&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;\n\n&#123;&quot;age&quot;: &quot;3&quot;&#125;\n\n&#123;&quot;sex&quot;: &quot;男&quot;&#125;\nJSON 和 JavaScript 对象的关系 ：\n\n\n​    JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\nvar obj &#x3D; &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;; &#x2F;&#x2F;这是一个对象，注意键名也是可以使用引号包裹的\nvar json &#x3D; &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;; &#x2F;&#x2F;这是一个 JSON 字符串，本质是一个字符串\n\nJSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\nJSON 和 JavaScript 对象互转\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\n\n要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\nvar json &#x3D; JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);\n&#x2F;&#x2F;结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;\n\n代码测试新建一个module ，springmvc-05-json ， 添加web的支持\n在web目录下新建一个 json.html ， 编写测试内容\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n        &#x2F;&#x2F;编写一个JavaScript对象\n        var user &#x3D; &#123;\n            name: &quot;张三&quot;,\n            age: 18,\n            sex: &quot;男&quot;\n        &#125;\n        &#x2F;&#x2F;将js对象转换为JSON对象\n        var json &#x3D; JSON.stringify(user);\n        console.log(json)   &#x2F;&#x2F;输出到控制台\n        console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#x2F;&#x2F;将JSON对象转换为JavaScript对象\n        var obj &#x3D; JSON.parse(json);\n        console.log(obj)   &#x2F;&#x2F;输出到控制台\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\nAjax\nAJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\nAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\nAjax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。\nGoogle Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。\n\n\n\n\n\n\n\n\n\n\n传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。\n使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。\n使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。\n伪造Ajax我们可以使用前端的iframe标签标签来伪造一个ajax的样子。\n​    新建一个module ： sspringmvc-06-ajax ， 导入web支持！\n​    编写一个 html 使用 iframe 测试，感受下效果\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;iframe测试体验页面无刷新&lt;&#x2F;title&gt;\n    &lt;script&gt;\n        function go() &#123;\n            &#x2F;&#x2F;所有的值变量，提前获取\n            var url &#x3D; document.getElementById(&quot;url&quot;).value;\n            document.getElementById(&quot;iframe1&quot;).src&#x3D;url;\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;p&gt;请输入地址 :&lt;&#x2F;p&gt;\n    &lt;p&gt;\n        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;url&quot; value&#x3D;&quot;https:&#x2F;&#x2F;www.taobao.com&quot;&gt;\n        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;go()&quot;&gt;\n    &lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n&lt;div&gt;\n    &lt;iframe id&#x3D;&quot;iframe1&quot; style&#x3D;&quot;width:100%;height: 500px;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n实现输入网址点击跳转，iframe中的内容变为该网址。\n使用Ajax可以：\n\n\n\n\n\n\n\n\n\n注册时，输入用户名自动检测用户是否已经存在。\n登陆时，提示用户名密码错误\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。\n….等等\njQuery.ajax纯JS原生实现Ajax不去讲解，直接使用jquery提供的，方便学习和使用.\n\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。\njQuery 提供多个与 AJAX 有关的方法。\n通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。\njQuery 不是生产者，而是大自然搬运工。\njQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！\n\njQuery.ajax(...)\n       部分参数：\n              url：请求地址\n             type：请求方式，GET、POST（1.9.0之后用method）\n          headers：请求头\n             data：要发送的数据\n      contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)\n            async：是否异步\n          timeout：设置请求超时时间（毫秒）\n       beforeSend：发送请求前执行的函数(全局)\n         complete：完成之后执行的回调函数(全局)\n          success：成功之后执行的回调函数(全局)\n            error：失败之后执行的回调函数(全局)\n          accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型\n         dataType：将服务器端返回的数据转换成指定类型\n            &quot;xml&quot;: 将服务器端返回的内容转换成xml格式\n           &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式\n           &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n         &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式\n           &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象\n          &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\n配置web.xml 和 springmvc的配置文件【记得静态资源过滤和注解驱动配置上】\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;\n    &lt;!--静态资源过滤--&gt;\n    &lt;mvc:default-servlet-handler &#x2F;&gt;\n    &lt;mvc:annotation-driven &#x2F;&gt;\n    &lt;!-- 视图解析器 --&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;\n          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;!-- 前缀 --&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;\n        &lt;!-- 后缀 --&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n编写AjaxController中的方法 :\npackage com.lc.controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n@RestController\npublic class AjaxController &#123;\n    @RequestMapping(&quot;&#x2F;t1&quot;)\n    public String test()&#123;\n        return &quot;hello&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;a1&quot;)\n    public void a1(String name, HttpServletResponse response) throws IOException &#123;\n        System.out.println(&quot;a1.param &#x3D;&#x3D;&gt; &quot;+name);\n        if(&quot;zhangsan&quot;.equals(name))&#123;\n            response.getWriter().println(&quot;true&quot;);\n        &#125;else &#123;\n            response.getWriter().println(&quot;false&quot;);\n        &#125;\n    &#125;\n&#125;\n\n修改index.jsp :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Ajax异步&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.6.3.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n      function a()&#123;\n        $.post(&#123;\n          url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a1&quot;,\n          data:&#123;\n            &quot;name&quot;:$(&quot;#username&quot;).val()\n          &#125;,\n          success:function (data) &#123;\n            alert(data);\n            console.log(&quot;data &#x3D;&gt; &quot;+data);\n            console.log(&quot;status &#x3D;&gt; &quot;+status); &#x2F;&#x2F;200 成功,300 重定向&#x2F;转发,400 客户端错误,500 服务器错误\n          &#125;\n        &#125;)\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n  &lt;%--失去焦点的时候，发送一个请求到后台--%&gt;\n  用户名：&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; onblur&#x3D;&quot;a()&quot;&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n启动tomcat测试。 打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！\nAjax加载数据编写实体类User :\npackage com.lc.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private String name;\n    private int age;\n    private String sex;\n&#125;\n\n在UserController中新增方法 :\n@RequestMapping(&quot;&#x2F;a2&quot;)\npublic List&lt;User&gt; a2()&#123;\n    List&lt;User&gt; userList &#x3D; new ArrayList&lt;User&gt;();\n    &#x2F;&#x2F;添加数据\n    userList.add(new User(&quot;张三&quot;,18,&quot;男&quot;));\n    userList.add(new User(&quot;李四&quot;,18,&quot;男&quot;));\n    userList.add(new User(&quot;王五&quot;,18,&quot;女&quot;));\n    return userList;\n&#125;\n\n新建test2.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.6.3.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n        $(function () &#123;\n            $(&quot;#btn&quot;).click(function ()&#123;\n                &#x2F;*\n                $.post(url,param[可以省略],success)\n                *&#x2F;\n                $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123;\n                    console.log(data);\n                    var html &#x3D; &quot;&quot;;\n                    for(let i&#x3D;0;i&lt; data.length;i++)&#123;\n                        html +&#x3D; &quot;&lt;tr&gt;&quot;+\n                            &quot;&lt;td&gt;&quot;+data[i].name +&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;td&gt;&quot;+data[i].age +&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;td&gt;&quot;+data[i].sex +&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;&#x2F;tr&gt;&quot;\n                    &#125;\n                    $(&quot;#context&quot;).html(html);\n                &#125;);\n            &#125;)\n        &#125;);\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;加载数据&quot; id&#x3D;&quot;btn&quot;&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;td&gt;姓名&lt;&#x2F;td&gt;\n            &lt;td&gt;年龄&lt;&#x2F;td&gt;\n            &lt;td&gt;性别&lt;&#x2F;td&gt;\n        &lt;&#x2F;tr&gt;\n        &lt;tbody id&#x3D;&quot;context&quot;&gt;\n        &lt;%--数据:后台--%&gt;\n        &lt;&#x2F;tbody&gt;\n    &lt;&#x2F;table&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n运行,点击按钮局部刷新，显示数据 :\n\nAjax验证登陆在AjaxController中添加一个方法 :\n@RequestMapping(&quot;&#x2F;a3&quot;)\npublic String a3(String name,String pwd)&#123;\n    String msg &#x3D; &quot;&quot;;\n    if(name!&#x3D;null)&#123;\n        &#x2F;&#x2F;账号应在数据库中查找，此处省略，用admin代替\n        if(&quot;admin&quot;.equals(name))&#123;\n            msg &#x3D; &quot;OK&quot;;\n        &#125;else &#123;\n            msg &#x3D; &quot;用户名有误!&quot;;\n        &#125;\n    &#125;\n    if(pwd!&#x3D;null)&#123;\n        if(&quot;123456&quot;.equals(pwd))&#123;\n            msg &#x3D; &quot;OK&quot;;\n        &#125;else &#123;\n            msg &#x3D; &quot;密码有误!&quot;;\n        &#125;\n    &#125;\n    return msg;\n&#125;\n\n新建一个前端页面login.jsp :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;登陆界面&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.6.3.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n        function a1() &#123;\n            $.post(&#123;\n                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,\n                data:&#123;&quot;name&quot;:$(&quot;#name&quot;).val()&#125;,\n                success:function (data) &#123;\n                    if(data.toString()&#x3D;&#x3D;&#x3D;&#39;OK&#39;)&#123;\n                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);\n                    &#125;\n                    else &#123;\n                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);\n                    &#125;\n                    $(&quot;#userInfo&quot;).html(data);\n                &#125;\n            &#125;)\n        &#125;\n        function a2() &#123;\n            $.post(&#123;\n                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,\n                data:&#123;&quot;pwd&quot;:$(&quot;#pwd&quot;).val()&#125;,\n                success:function (data) &#123;\n                    if(data.toString()&#x3D;&#x3D;&#x3D;&#39;OK&#39;)&#123;\n                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);\n                    &#125;\n                    else &#123;\n                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);\n                    &#125;\n                    $(&quot;#pwdInfo&quot;).html(data);\n                &#125;\n            &#125;)\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;p&gt;\n    用户名 : &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&gt;\n    &lt;span id&#x3D;&quot;userInfo&quot;&gt;&lt;&#x2F;span&gt;\n&lt;&#x2F;p&gt;\n&lt;p&gt;\n    密码 : &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&gt;\n    &lt;span id&#x3D;&quot;pwdInfo&quot;&gt;&lt;&#x2F;span&gt;\n&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n运行后实现检测账号密码正确性并局部刷新 :\n\n\n拦截器概况SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n过滤器与拦截器的区别：拦截器是AOP思想的具体应用。\n过滤器\n\n\n\n\n\n\n\n\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了&#x2F;*之后，可以对所有要访问的资源进行拦截\n拦截器\n\n\n\n\n\n\n\n\n\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp&#x2F;html&#x2F;css&#x2F;image&#x2F;js是不会进行拦截的\n自定义拦截器想要自定义拦截器，必须实现 HandlerInterceptor 接口。\n新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持，配置web.xml 和 springmvc-servlet.xml 文件\n编写一个拦截器\npackage com.lc.config;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\npublic class MyInterceptor implements HandlerInterceptor &#123;\n    &#x2F;&#x2F;return true; 执行下一个拦截器，放行\n    &#x2F;&#x2F;return false; 不执行下一个拦截器，放行\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;处理前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        return true;\n    &#125;\n    &#x2F;&#x2F;拦截日志\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;处理后&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;清理&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;\n\n编写一个TestController :\npackage com.lc.controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;t1&quot;)\n    public String test()&#123;\n        System.out.println(&quot;TestController &#x3D;&#x3D;&gt; test()执行了!&quot;);\n        return &quot;OK&quot;;\n    &#125;\n&#125;\n\n运行，由于return true，成功访问成功，控制台输出如下 :\n\n登陆判断验证\n\n\n\n\n\n\n\n\n有一个登陆页面，需要写一个controller访问页面。\n登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。\n拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面\n编写一个登陆页面 login.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;登陆页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;%--在WEB-INF下的所有页面或资源，只能通过controller,或者servlet进行访问--%&gt;\n&lt;h1&gt;登陆页面&lt;&#x2F;h1&gt;\n&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt;\n    用户名 ： &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n    密码 ： &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n编写一个Controller处理请求\npackage com.lc.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport javax.servlet.http.HttpSession;\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class LoginController &#123;\n    @RequestMapping(&quot;&#x2F;login&quot;)\n    public String login(HttpSession session, String username, String password, Model model)&#123;\n        &#x2F;&#x2F;把用户的信息存入session中\n        session.setAttribute(&quot;userLoginInfo&quot;,username);\n        model.addAttribute(&quot;username&quot;,username);\n        return &quot;main&quot;;  &#x2F;&#x2F;登陆成功\n    &#125;\n    @RequestMapping(&quot;&#x2F;goLogin&quot;)\n    public String goLogin()&#123;\n        return &quot;login&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;main&quot;)\n    public String main()&#123;\n        return &quot;main&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;goOut&quot;)\n    public String goOut(HttpSession session)&#123;\n        &#x2F;&#x2F;销毁session : session.invalidate();\n        &#x2F;&#x2F;把用户的信息移出session中\n        session.removeAttribute(&quot;userLoginInfo&quot;);\n        return &quot;main&quot;;  &#x2F;&#x2F;登陆成功\n    &#125;\n&#125;\n\n写一个首页页面main.jsp :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;首页&lt;&#x2F;h1&gt;\n&lt;span&gt;$&#123;sessionScope.userLoginInfo&#125;&lt;&#x2F;span&gt;\n&lt;p&gt;\n    &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;goOut&quot;&gt;注销&lt;&#x2F;a&gt;\n&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n修改index.jsp :\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;$Title$&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n  &lt;h1&gt;&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;goLogin&quot;&gt;登陆页面&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;main&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n此时未登录也能访问首页。\n编写用户登录拦截器LoginInterceptor : \npackage com.lc.config;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\npublic class LoginInterceptor implements HandlerInterceptor &#123;\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        HttpSession session &#x3D; request.getSession();\n        &#x2F;&#x2F;放行 : 判断什么情况下登录\n        &#x2F;&#x2F;登陆页面也放行\n        if(request.getRequestURI().contains(&quot;goLogin&quot;))&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;说明我在提交登陆\n        if(request.getRequestURI().contains(&quot;login&quot;))&#123;\n            return true;\n        &#125;\n        if(session.getAttribute(&quot;userLoginInfo&quot;)!&#x3D;null)&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;判断什么情况下没登陆\n        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;login.jsp&quot;).forward(request,response);\n        return false;\n    &#125;\n&#125;\n\n在Springmvc的配置文件中注册拦截器\n&lt;mvc:interceptor&gt;\n            &lt;!--&#x2F;user下面的所有请求--&gt;\n            &lt;mvc:mapping path&#x3D;&quot;&#x2F;user&#x2F;**&quot;&#x2F;&gt;\n            &lt;bean class&#x3D;&quot;com.lc.config.LoginInterceptor&quot; &#x2F;&gt;\n        &lt;&#x2F;mvc:interceptor&gt;\n\n运行 ，未登录无法访问首页，跳转到登陆页面。\n","slug":"学习笔记/SpringMVC","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"SpringBoot学习笔记SpringBoot官方文档：https://spring.io/projects/spring-boot\n什么是SpringSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。\nSpring是为了解决企业级应用开发的复杂性而创建的，简化开发。\nSpring如何简化Java开发为了降低Java开发的复杂性，Spring采用了以下4种关键策略：\n基于POJO的轻量级和最小侵入性编程，所有东西都是bean；\n通过IOC，依赖注入（DI）和面向接口实现松耦合；\n基于切面（AOP）和惯例进行声明式编程；\n通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；\n\n什么是SpringBoot就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。\nSpring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。\nSpringBoot优点\n为所有Spring开发者更快的入门\n开箱即用，提供各种默认配置来简化项目配置\n内嵌式容器简化Web项目\n没有冗余代码生成和XML配置的要求\n\n微服务什么是微服务 微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合；可以通过http的方式进行互通，要说微服务架构，先得说说过去的单体应用架构。\n单体应用架构 所谓单体应用架构(all in one)是指，我们将一个应用中的所有应用服务都封装在一个应用中。 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问，等等各个功能放在一个war包内。\n\n这么做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需把war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。\n单体应用架构缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里，我们如何维护、如何分工合作都是问题。\n\n微服务架构 all in one 的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。\n 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。\n这样做的好处 ：\n\n节省了调用资源\n每个功能元素的服务都是一个可替换的、可独立升级的软件代码。\n\n如何构建微服务架构 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。​ 但是这种庞大的系统架构给部署和运维带来很大的难度。于是，spring为我们带来了构建大型分布式微服务的全套、全程产品:\n\n构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用\n大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式\n在分布式中间，进行流式数据计算、批处理，我们有spring cloud data flow。\nspring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。\n\n第一个SpringBoot项目环境准备：\n\njdk1.8\nMaven-3.6.3\nSpringBoot 2.7.8\n\n开发工具：\n\nIDEA\n\nSpring官方提供了非常方便的工具让我们快速构建应用\nSpring Initializr：https://start.spring.io/\n项目创建方式一使用Spring Initializr 的 Web页面创建项目\n1、打开 https://start.spring.io/\n2、填写项目信息\n3、点击”Generate Project“按钮生成项目；下载此项目\n4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。\n5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。\n项目创建方式二使用 IDEA 直接创建项目\n1、创建一个新项目\n2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现\n3、填写项目信息\n4、选择初始化的组件（初学勾选 Web 即可）\n5、填写项目路径\n6、等待项目构建成功\npom.xml分析打开pom.xml，看看Spring Boot项目的依赖：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;!--有父项目--&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.7.8&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;groupId&gt;com.lc&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;helloworld&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;helloworld&lt;&#x2F;name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n    &lt;&#x2F;properties&gt;\n    &lt;dependencies&gt;\n        &lt;!--web依赖:tomcat,dispatcherServlet,xml--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!--spring-boot-start所有的springboot依赖都是使用这个开头--&gt;\n        &lt;!--单元测试--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n    &lt;build&gt;\n        &lt;!--打jar包插件--&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n&lt;&#x2F;project&gt;\n\n编写http接口在主程序的同级目录下，新建一个controller包，一定要在启动类同级目录下，否则识别不到\n在包中新建一个HelloController类 :\npackage com.lc.helloworld.controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n&#x2F;&#x2F;自动装配\n@RestController\npublic class HelloController &#123;\n    &#x2F;&#x2F;接口：http:&#x2F;&#x2F;localhost:8080&#x2F;hello\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String hello()&#123;\n        &#x2F;&#x2F;调用业务，接收前端参数\n        return &quot;hello,World&quot;;\n    &#125;\n&#125;\n\n编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！\n\n这样一个web接口的开发就完成了\n将项目打成jar包点击右侧Maven Projectc工具栏中的package 即可将项目打包成一个jar包，如果打包成功，则会在target目录下生成一个 jar 包，打成了jar包后，就可以在任何地方运行了！\n更改项目端口号在配置文件中修改server.port\n#更改项目端口号\nserver.port&#x3D;8081\n\n更改启动时banner图案到项目下的 resources 目录下新建一个banner.txt 即可:\n图案可以到网站 https://www.bootschool.net/ascii 生成，拷贝到文件中即可！\nSpringBoot运行原理父依赖其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;\n    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;&#x2F;parent&gt;\n\n点进去，发现还有一个父依赖\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;\n    &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;\n&lt;&#x2F;parent&gt;\n\n这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；\n以后我们导入依赖默认是不需要写版本，因为有这些版本仓库；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；\n启动器 spring-boot-starter&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nspringboot-boot-starter-xxx：就是spring-boot的场景启动器\nspring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件；\nSpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；\n主启动类默认的主启动类\npackage com.lc;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n&#x2F;&#x2F;@SpringBootApplication 来标注一个主程序类\n&#x2F;&#x2F;说明这是一个Spring Boot应用\n@SpringBootApplication\npublic class Springboot01HellowroldApplication &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;以为是启动了一个方法，没想到启动了一个服务\n        SpringApplication.run(Springboot01HellowroldApplication.class, args);\n    &#125;\n&#125;\n\n注解：\n@SpringBootApplication : 标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\t@@SpringBootConfiguration : Spring配置类，标注在某个类上，表示这是一个SpringBoot的配置类；\n\t@Configuration : 说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；\n\t@Component : 说明启动类本身也是Spring中的一个组件而已，负责启动应用！\n\t@ComponentScan : 这个注解在Spring中很重要 ,它对应XML配置中的元素，扫码当前主启动类同级的包。\n作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中\n\n@EnableAutoConfiguration : 开启自动配置功能\n\tAutoConfigurationPackage : 自动配置包\n\t@Import(&#123;Registrar.class&#125;) : 自动配置 ‘包组件’\n\t\tSpring底层注解@import ， 给容器中导入一个组件\n\t\tRegistrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器\n\t@Import(&#123;AutoConfigurationImportSelector.class&#125;) : 给容器导入组件\nAutoConfigurationImportSelector ：自动配置导入选择器\n\nspring.factories我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！所有的自动配置类都在这里。\n所以，自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n总结：\nSpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值\n将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\nSpringBoot所有自动配置都是在启动的时候扫描并加载: spring.factories所有的自动配置类都在这里面，但是不一定生效。要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功!\nSpringApplication@SpringBootApplication\npublic class SpringbootApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringbootApplication.class, args);\n    &#125;\n&#125;\n\nSpringApplication.run分析\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication这个类主要做了以下四件事情：\n1、推断应用的类型是普通的项目还是Web项目\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n3、找出所有的应用程序监听器，设置到listeners属性中\n4、推断并设置main方法的定义类，找到运行的主类\n查看构造器：\npublic SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;\n    &#x2F;&#x2F; ......\n    this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();\n    this.setInitializers(this.getSpringFactoriesInstances();\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();\n&#125;\n\nrun方法流程\nyaml语法配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\n\napplication.properties\n​\t语法结构 ：key&#x3D;value\n\napplication.yml\n​\t语法结构 ：key：空格 value\n\n\n配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；\n比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！\nserver.port&#x3D;8081\nyaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）\n这种语言以数据作为中心，而不是以标记语言为重点！\n以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml\n传统xml配置：\n&lt;server&gt;    \n\t&lt;port&gt;8081&lt;port&gt;\n&lt;&#x2F;server&gt;\n\nyaml配置：\nserver:\n\tprot: 8080\n\nyaml基础语法说明：语法要求严格！\n\n空格不能省略\n以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。\n属性和值的大小写都是十分敏感的。\n\n字面量：普通的值 [ 数字，布尔值，字符串 ]\n字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；\n\n\n\n\n\n\n\n\n\nk: v\n注意：\n\n“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；\n比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen\n\n‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出\n比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen\n\n\n对象、Map（键值对）\n#对象、Map格式\nk:     \n\tv1:\n\tv2:\n\n在下一行来写对象的属性和值得关系，注意缩进；比如：\nstudent: \n\t\t name: qinjiang\n\t\t age: 3\n\n行内写法\nstudent: &#123;name: qinjiang,age: 3&#125;\n\n数组（ List、set ）\n用 - 值表示数组中的一个元素,比如：\npets: \n\t  - cat\n\t  - dog\n\t  - pig\n\n行内写法\npets: [cat,dog,pig]\n\n修改SpringBoot的默认端口号\n配置文件中添加，端口号的参数，就可以切换端口；\nserver: \n\tport: 8082\n\n给属性赋值yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！\nyaml注入配置文件\n在springboot项目中的resources目录下新建一个文件 application.yml\n编写一个实体类 Dog，原来使用@Value给bean注入属性值 :\npackage com.kuang.springboot.pojo;\n@Component  &#x2F;&#x2F;注册bean到容器中\npublic class Dog &#123;\n    @Value(&quot;旺财&quot;)    &#x2F;&#x2F;注入属性值\n    private String name;\n    @Value(&quot;3&quot;)\n    private Integer age;\n    &#x2F;&#x2F;有参无参构造、get、set方法、toString()方法  \n&#125;\n\n在SpringBoot的测试类下注入狗狗输出一下 :\n@SpringBootTest\nclass DemoApplicationTests &#123;\n    @Autowired &#x2F;&#x2F;将狗狗自动注入进来\n    private Dog dog;\n    @Test\n    public void contextLoads() &#123;\n        System.out.println(dog); &#x2F;&#x2F;打印看下狗狗对象\n    &#125;\n&#125;\n\n结果成功输出，@Value注入成功\n指定配置文件\n@PropertySource：加载指定的配置文件；\n@configurationProperties：默认从全局配置文件中获取值；\n在resources目录下新建一个person.properties文件\nname&#x3D;lisi\n\n然后代码中指定加载person.properties文件\n@Component  &#x2F;&#x2F;注册bean\n&#x2F;&#x2F;@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n&#x2F;&#x2F;加载指定的配置文件@PropertySource(value &#x3D; &quot;classpath:lisi.properties&quot;)\npublic class Person &#123;\n\t&#x2F;&#x2F;SPEL表达式取出配置文件的值\n\t@Value(&quot;$&#123;name&#125;&quot;)\n\tprivate String name;\n\t……\n&#125;\n\n输出测试，指定配置文件绑定成功！\n配置文件占位符配置文件还可以编写占位符生成随机数\nperson:\n    name: 张三$&#123;random.uuid&#125; # 随机uuid\n    age: $&#123;random.int&#125;  # 随机int\n    happy: false\n    birth: 2000&#x2F;01&#x2F;01\n    maps: &#123;k1: v1,k2: v2&#125;\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: $&#123;person.hello:other&#125;_旺财\n      age: 1\n\n总结：配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；\n如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；\n如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接configurationProperties\nJSR303校验Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。这里写个注解让我们的name只能支持Email格式；\n添加依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n@Component &#x2F;&#x2F;注册bean\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n@Validated  &#x2F;&#x2F;数据校验\npublic class Person &#123;\n    @Email(message&#x3D;&quot;邮箱格式错误&quot;) &#x2F;&#x2F;name必须是邮箱格式\n    private String name;\n&#125;\n\n运行结果 ：default message [不是一个合法的电子邮件地址];\n\n使用数据校验，可以保证数据的正确性；\n常见校验参数\n@NotNull(message&#x3D;&quot;名字不能为空&quot;)\nprivate String userName;\n@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)\nprivate int age;\n@Email(message&#x3D;&quot;邮箱格式错误&quot;)\nprivate String email;\n空检查\n@Null       验证对象是否为null\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\nBooelan检查\n@AssertTrue     验证 Boolean 对象是否为 true  \n@AssertFalse    验证 Boolean 对象是否为 false  \n长度检查\n@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  \n@Length(min&#x3D;, max&#x3D;) string is between min and max included.\n日期检查\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前  \n@Future     验证 Date 和 Calendar 对象是否在当前时间之后  \n@Pattern    验证 String 对象是否符合正则表达式的规则\n.......等等\n除此以外，我们还可以自定义一些数据校验规则\n\n\n\n多环境装配profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；\n多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties&#x2F;yml , 用来指定多个环境版本；\n例如：\napplication-test.properties 代表测试环境配置\napplication-dev.properties 代表开发环境配置\n但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件。\n我们需要通过一个配置来选择需要激活的环境：\n#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；\n#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；\nspring.profiles.active&#x3D;dev\n\nyaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !\nserver:\n  port: 8081\n#选择要激活那个环境块\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev #配置环境的名称\n---\nserver:\n  port: 8084\nspring:\n  profiles: prod  #配置环境的名称\n\n注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！\n配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！\n官方外部配置文件说明参考文档\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\n优先级1：项目路径下的config文件夹配置文件\n优先级2：项目路径下配置文件\n优先级3：资源路径下的config文件夹配置文件\n优先级4：资源路径下配置文件\n优先级由高到低，高优先级的配置会覆盖低优先级的配置\nSpringBoot会从这四个位置全部加载主配置文件；互补配置；\n我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；\n#配置项目的访问路径\nserver.servlet.context-path&#x3D;&#x2F;kuang\n\n扩展，运维小技巧指定位置加载配置文件\n我们还可以通过spring.config.location来改变默认的配置文件位置\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高\njava -jar spring-boot-config.jar --spring.config.location&#x3D;F:&#x2F;application.properties\n\n\n\n自动配置原理分析自动配置原理以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；\n&#x2F;&#x2F;表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；\n@Configuration \n&#x2F;&#x2F;启动指定类的ConfigurationProperties功能；\n  &#x2F;&#x2F;进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；\n  &#x2F;&#x2F;并把HttpProperties加入到ioc容器中\n@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) \n&#x2F;&#x2F;Spring底层@Conditional注解\n  &#x2F;&#x2F;根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；\n  &#x2F;&#x2F;这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效\n@ConditionalOnWebApplication(\n    type &#x3D; Type.SERVLET\n)\n&#x2F;&#x2F;判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\n@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)\n&#x2F;&#x2F;判断配置文件中是否存在某个配置：spring.http.encoding.enabled；\n  &#x2F;&#x2F;如果不存在，判断也是成立的\n  &#x2F;&#x2F;即使我们配置文件中不配置pring.http.encoding.enabled&#x3D;true，也是默认生效的；\n@ConditionalOnProperty(\n    prefix &#x3D; &quot;spring.http.encoding&quot;,\n    value &#x3D; &#123;&quot;enabled&quot;&#125;,\n    matchIfMissing &#x3D; true\n)\npublic class HttpEncodingAutoConfiguration &#123;\n    &#x2F;&#x2F;他已经和SpringBoot的配置文件映射了\n    private final Encoding properties;\n    &#x2F;&#x2F;只有一个有参构造器的情况下，参数的值就会从容器中拿\n    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;\n        this.properties &#x3D; properties.getEncoding();\n    &#125;\n    &#x2F;&#x2F;给容器中添加一个组件，这个组件的某些值需要从properties中获取\n    @Bean\n    @ConditionalOnMissingBean &#x2F;&#x2F;判断容器没有这个组件？\n    public CharacterEncodingFilter characterEncodingFilter() &#123;\n        CharacterEncodingFilter filter &#x3D; new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));\n        return filter;\n    &#125;\n    &#x2F;&#x2F;......\n&#125;\n\n一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！\n\n一但这个配置类生效；这个配置类就会给容器中添加各种组件；\n这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；\n配置文件能配置什么就可以参照某个功能对应的这个属性类\n\n&#x2F;&#x2F;从配置文件中获取指定的值和bean的属性进行绑定\n@ConfigurationProperties(prefix &#x3D; &quot;spring.http&quot;) \npublic class HttpProperties &#123;\n    &#x2F;&#x2F; .....\n&#125;\n\n这就是自动装配的原理！\n精髓1、SpringBoot启动会加载大量的自动配置类\n2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；\n3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）\n4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\nxxxxAutoConfigurartion：自动配置类；给容器中添加组件\nxxxxProperties:封装配置文件中相关属性；\n了解：@Conditionl：\n了解完自动装配的原理后，关注一个细节问题，自动配置类必须在一定的条件下才能生效；\n@Conditional派生注解（Spring注解版原生的@Conditional作用）\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。\n我们怎么知道哪些自动配置类生效？\n我们可以通过启用 debug&#x3D;true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；\n#开启springboot的调试类\ndebug&#x3D;true\n\nPositive matches:（自动配置类启用的：正匹配）\nNegative matches:（没有启动，没有匹配成功的自动配置类：负匹配）\nUnconditional classes: （没有条件的类）\nSpringBoot Web开发使用SpringBoot的步骤：\n1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好\n2、手动在配置文件中配置部分配置项目就可以运行起来了\n3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。\n要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！\n比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？\n\n向容器中自动配置组件 ：Autoconfiguration\n自动配置类，封装配置文件的内容：Properties\n\n要解决的问题\n导入静态资源\n首页\njsp，模板引擎Thymeleaf\n装配扩展SpringMVC\n增删改查\n拦截器\n国际化\n\n静态资源处理SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；\n我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；\n有一个方法：addResourceHandlers 添加资源处理\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    if (!this.resourceProperties.isAddMappings()) &#123;\n        &#x2F;&#x2F; 已禁用默认资源处理\n        logger.debug(&quot;Default resource handling disabled&quot;);\n        return;\n    &#125;\n    &#x2F;&#x2F; 缓存控制\n    Duration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod();\n    CacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n    &#x2F;&#x2F; webjars 配置\n    if (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;\n        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)\n                                             .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    &#125;\n    &#x2F;&#x2F; 静态资源配置\n    String staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();\n    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    &#125;\n&#125;\n\n读一下源代码：比如所有的 &#x2F;webjars&#x2F;** ， 都需要去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找对应的资源；\n1.webjars方式引入Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。\n使用SpringBoot需要使用Webjars，我们可以去搜索一下：\n网站：https://www.webjars.org\n要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！\n&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源\n我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n\n2.静态资源映射规则我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；\n我们去找staticPathPattern发现第二种映射规则 ：&#x2F;** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：\n&#x2F;&#x2F; 进入方法\npublic String[] getStaticLocations() &#123;\n    return this.staticLocations;\n&#125;\n&#x2F;&#x2F; 找到对应的值\nprivate String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;\n&#x2F;&#x2F; 找到路径\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; \n    &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,\n  &quot;classpath:&#x2F;resources&#x2F;&quot;, \n    &quot;classpath:&#x2F;static&#x2F;&quot;, \n    &quot;classpath:&#x2F;public&#x2F;&quot; \n&#125;;\n\nResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。\n所以得出结论，以下四个目录存放的静态资源可以被我们识别：\n“classpath:&#x2F;META-INF&#x2F;resources&#x2F;“\n“classpath:&#x2F;resources&#x2F;“\n“classpath:&#x2F;static&#x2F;“\n“classpath:&#x2F;public&#x2F;“\n\n我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；\n比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件；\n3.自定义静态资源路径我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；\nspring.resources.static-locations&#x3D;classpath:&#x2F;coding&#x2F;,classpath:&#x2F;kuang&#x2F;\n\n注意：一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！\n首页和图标定制继续向下看源码，可以看到一个欢迎页的映射，就是我们的首页！\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n                                                           FormattingConversionService mvcConversionService,\n                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;\n    WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(\n        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), &#x2F;&#x2F; getWelcomePage 获得欢迎页\n        this.mvcProperties.getStaticPathPattern());\n    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n    return welcomePageHandlerMapping;\n&#125;\n\n点进去继续看\nprivate Optional&lt;Resource&gt; getWelcomePage() &#123;\n    String[] locations &#x3D; getResourceLocations(this.resourceProperties.getStaticLocations());\n    &#x2F;&#x2F; ::是java8 中新引入的运算符\n    &#x2F;&#x2F; Class::function的时候function是属于Class的，应该是静态方法。\n    &#x2F;&#x2F; this::function的funtion是属于这个对象的。\n    &#x2F;&#x2F; 简而言之，就是一种语法糖而已，是一种简写\n    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();\n&#125;\n&#x2F;&#x2F; 欢迎页就是一个location下的的 index.html 而已\nprivate Resource getIndexHtml(String location) &#123;\n    return this.resourceLoader.getResource(location + &quot;index.html&quot;);\n&#125;\n\n欢迎页，静态资源文件夹下的所有 index.html 页面；被 &#x2F;** 映射。\n比如我访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html\n新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 http://localhost:8080/ 看结果！\n网站图标与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。\n1、关闭SpringBoot默认图标\n#关闭默认图标\nspring.mvc.favicon.enabled&#x3D;false\n\n2、自己放一个图标在静态资源目录下，我放在 public 目录下\n3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！\n\n新版将 favicon.ico图片放入static目录即可。\nthymeleaf模板引擎前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。\njsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。\n那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦\nSpringBoot推荐你可以来使用模板引擎：\n模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的\n\n模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且功能更强大。\n引入ThymeleafThymeleaf 官网：https://www.thymeleaf.org/\nThymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf\nSpring官方文档：找到我们对应的版本\nhttps://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter\n找到对应的pom依赖：可以适当点进源码看下本来的包！\n&lt;!--thymeleaf--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nMaven会自动下载jar包，我们可以去看下下载的东西；\n\nThymeleaf分析前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？\n我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。\n我们去找一下Thymeleaf的自动配置类：ThymeleafProperties\n@ConfigurationProperties(\n    prefix &#x3D; &quot;spring.thymeleaf&quot;\n)\npublic class ThymeleafProperties &#123;\n    private static final Charset DEFAULT_ENCODING;\n    public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n    public static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;\n    private boolean checkTemplate &#x3D; true;\n    private boolean checkTemplateLocation &#x3D; true;\n    private String prefix &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n    private String suffix &#x3D; &quot;.html&quot;;\n    private String mode &#x3D; &quot;HTML&quot;;\n    private Charset encoding;\n&#125;\n\n我们可以在其中看到默认的前缀和后缀！\n我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。\n使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！\nThymeleaf语法学习修改测试请求，增加数据传输；\n@RequestMapping(&quot;&#x2F;t1&quot;)\npublic String test1(Model model)&#123;\n    &#x2F;&#x2F;存入数据\n    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);\n    &#x2F;&#x2F;classpath:&#x2F;templates&#x2F;test.html\n    return &quot;test&quot;;\n&#125;\n\n要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。可以去官方文档的#3中看一下命名空间拿来过来：\nxmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;\n\n去编写下前端页面\n&lt;!DOCTYPE html&gt;\n&lt;!--使用http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;thymeleaf-extras-spring,红色下划线消失--&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;测试页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Test&lt;&#x2F;h1&gt;\n&lt;!--th:text就是将div中的内容设置为它指定的值--&gt;\n&lt;div th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n提取公共页面可以将导航栏、侧边栏、底部栏等放入一个html文件中，在第一句标签上加上th:fragment&#x3D;”XXXX”。\n在其它html文件中调用只需:\n&lt;div th:insert&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--插入--&gt;\n&lt;div th:replace&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--替换--&gt;\n\n如果要传递参数，直接在XXXX后面用(参数名&#x3D;参数值)传参。\n(接收可以th:class&#x3D;”${参数名&#x3D;&#x3D;参数值?”正确就执行的属性”:”不正确执行的属性”}”)\n日期转义th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)\n\nMVC配置在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。\n只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！\n地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration\nSpringBoot Web项目练习登录实现在LoginController中编写登陆方法 :\npackage com.lc.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.thymeleaf.util.StringUtils;\nimport javax.servlet.http.HttpSession;\n@Controller\npublic class LoginController &#123;\n    @RequestMapping(&quot;&#x2F;user&#x2F;login&quot;)\n    public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model model, HttpSession session)&#123;\n        &#x2F;&#x2F;具体业务\n        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password))&#123;\n            session.setAttribute(&quot;loginUser&quot;,username);\n            return &quot;redirect:&#x2F;main.html &quot;;\n        &#125;else &#123;\n            &#x2F;&#x2F;告知用户登陆失败\n            model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误!&quot;);\n            return &quot;login&quot;;\n        &#125;\n    &#125;\n&#125;\n\n在MyMvcConfig中添加跳转视图控制 :\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F;添加视图控制\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;访问&#x2F;前往登录页\n        registry.addViewController(&quot;&#x2F;login.html&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;前往登录页\n        registry.addViewController(&quot;&#x2F;main.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页\n        registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页\n    &#125;\n    &#x2F;&#x2F;自定义的国际化组件就生效了\n    @Bean\n    public LocaleResolver localeResolver()&#123;\n        return new MyLocaleResolver();\n    &#125;\n&#125;\n\n在templates中编写登陆页面login.html :\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;amazeui.min.css&#125;&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;admin.css&#125;&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;app.css&#125;&quot;&gt;\n    &lt;title&gt;登陆页面&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        div.set_center&#123;\n            margin-left: auto;\n            margin-right: auto;\n            width: 450px;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body class&#x3D;&quot;am-text-center&quot;&gt;\n    &lt;form class&#x3D;&quot;&quot; th:action&#x3D;&quot;@&#123;&#x2F;user&#x2F;login&#125;&quot;&gt;\n        &lt;div class&#x3D;&quot;set_center&quot;&gt;\n            &lt;h1 th:text&#x3D;&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;&#x2F;h1&gt;\n            &lt;!--如果msg为空则不显示--&gt;\n            &lt;p style&#x3D;&quot;color: red&quot; th:text&#x3D;&quot;$&#123;msg&#125;&quot; th:if&#x3D;&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n            &lt;label&gt;Username:&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;username&quot; th:placeholder&#x3D;&quot;#&#123;login.username&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;&lt;br&gt;\n            &lt;label&gt;Password:&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; th:placeholder&#x3D;&quot;#&#123;login.password&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;\n            &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;remember-me&quot; th:text&#x3D;&quot;#&#123;login.remember&#125;&quot;&gt;&lt;br&gt;\n            &lt;button class&#x3D;&quot;btn-box&quot; th:text&#x3D;&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;&#x2F;button&gt;\n            &lt;!-- 这里传入参数不需要使用 ？使用 （key&#x3D;value）--&gt;&lt;br&gt;\n            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;&#x2F;a&gt;&amp;nbsp;&amp;nbsp;\n            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;en_US&#39;)&#125;&quot;&gt;English&lt;&#x2F;a&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n运行，输入任意账号和123456密码成功登陆:\n\n登录拦截器新建LoginHandlerInterceptor继承HandlerInterceptor方法实现拦截器 \npackage com.lc.config;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\npublic class LoginHandlerInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        &#x2F;&#x2F;登录成功后，应该有用户的session\n        Object loginUser &#x3D; request.getSession().getAttribute(&quot;loginUser&quot;);\n        if(loginUser &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;没有登陆\n            request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;);\n            request.getRequestDispatcher(&quot;&#x2F;login.html&quot;).forward(request,response);\n            return false;\n        &#125;else&#123;\n            return true;\n        &#125;\n    &#125;\n&#125;\n\n在MyMvcConfig中添加自定义拦截器\n&#x2F;&#x2F;自定义拦截器\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    &#x2F;&#x2F;拦截所有页面除了登陆页面和静态资源\n    registry.addInterceptor(new LoginHandlerInterceptor())\n            .addPathPatterns(&quot;&#x2F;**&quot;)\n            .excludePathPatterns(&quot;&#x2F;login.html&quot;,&quot;&#x2F;&quot;,&quot;&#x2F;user&#x2F;login&quot;,&quot;&#x2F;css&#x2F;*&quot;,&quot;&#x2F;js&#x2F;*&quot;);\n&#125;\n\n直接访问main.html拦截成功，转入登录页面 :\n\n展示员工列表在EmployeeController中写入员工列表代码 ,传入员工列表:\n@Controller\npublic class EmployeeController &#123;\n    @Autowired\n    EmployeeDao employeeDao;\n    @RequestMapping(&quot;&#x2F;emps&quot;)\n    public String list(Model model)&#123;\n        Collection&lt;Employee&gt; employees &#x3D; employeeDao.getAllEmployee();\n        model.addAttribute(&quot;emps&quot;,employees);\n        System.out.println(&quot;!!!!!!!!!!!!&quot;);\n        return &quot;emp&#x2F;user&quot;;\n    &#125;\n&#125;\n\n部分前端代码 :\n&lt;table class&#x3D;&quot;am-table am-table-striped am-table-hover table-main&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n    &lt;th class&#x3D;&quot;table-check&quot;&gt;\n        &lt;input id&#x3D;&quot;chkAll&quot; type&#x3D;&quot;checkbox&quot;&gt;\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-id&quot;&gt;\n        ID\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-title&quot;&gt;\n        姓名\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        性别\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        部门名称\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        邮箱\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        生日\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-set&quot;&gt;\n        操作\n    &lt;&#x2F;th&gt;\n&lt;&#x2F;tr&gt;\n&lt;&#x2F;thead&gt;\n&lt;tbody id&#x3D;&quot;tUser&quot;&gt;\n&lt;tr th:each&#x3D;&quot;emp:$&#123;emps&#125;&quot;&gt;\n    &lt;td&gt;&lt;input name&#x3D;&quot;ids&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getId()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getName()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getGander()&#x3D;&#x3D;0?&#39;女&#39;:&#39;男&#39;&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getDepartment().getDepartmentName()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getEmail()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td&gt;\n        &lt;div class&#x3D;&quot;am-btn-toolbar&quot;&gt;\n            &lt;div class&#x3D;&quot;am-btn-group am-btn-group-xs&quot;&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-secondary btnEdit&quot;&gt;&lt;span class&#x3D;&quot;am-icon-pencil-square-o&quot;&gt;&lt;&#x2F;span&gt; 编辑&lt;&#x2F;button&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-danger am-hide-sm-only&quot; onclick&#x3D;&quot;delUser(1,1)&quot;&gt;&lt;span class&#x3D;&quot;am-icon-trash-o&quot;&gt;&lt;&#x2F;span&gt; 删除&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&lt;&#x2F;tbody&gt;\n&lt;&#x2F;table&gt;\n\n添加员工在EmployeeController中添加方法 :\n&#x2F;&#x2F;跳转到addUser页面\n@GetMapping(&quot;&#x2F;add&quot;)\npublic String toAddUser(Model model)&#123;\n    Collection&lt;Department&gt; departments &#x3D; departmentDao.getDepartment();\n    model.addAttribute(&quot;departs&quot;,departments);\n    return &quot;emp&#x2F;addUser&quot;;\n&#125;\n&#x2F;&#x2F;添加员工\n@RequestMapping(&quot;&#x2F;addEmp&quot;)\npublic String addEmp(Employee employee)&#123;\n    employeeDao.addEmployee(employee);\n    System.out.println(&quot;employee++&gt;&quot;+employee);\n    return &quot;redirect:&#x2F;emps&quot;;\n&#125;\n\n部分前端代码 :\n&lt;form class&#x3D;&quot;am-form am-form-horizontal&quot; th:action&#x3D;&quot;@&#123;&#x2F;addEmp&#125;&quot; method&#x3D;&quot;post&quot; style&#x3D;&quot;padding-top: 30px;&quot;&gt;\n&lt;input name&#x3D;&quot;id&quot; type&#x3D;&quot;hidden&quot;&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n    姓名\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入姓名&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small&gt;请输入姓名。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n    邮箱\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入邮箱&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;email&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small &gt;请输入邮箱。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n            性别 &#x2F; sex\n        &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot; style&#x3D;&quot;line-height: 30px;&quot;&gt;\n        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;man&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n        &lt;label for&#x3D;&quot;man&quot;&gt;\n                男\n            &lt;&#x2F;label&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\n        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;woman&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;\n        &lt;label for&#x3D;&quot;woman&quot;&gt;\n                女\n            &lt;&#x2F;label&gt;\n        &lt;br &#x2F;&gt;\n        &lt;small&gt;请选择性别&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n            部门\n        &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;select name&#x3D;&quot;department.id&quot; required&gt;\n            &lt;option th:each&#x3D;&quot;dept:$&#123;departs&#125;&quot; th:text&#x3D;&quot;$&#123;dept.getDepartmentName()&#125;&quot; th:value&#x3D;&quot;$&#123;dept.getId()&#125;&quot;&gt;&lt;&#x2F;option&gt;\n        &lt;&#x2F;select&gt;\n        &lt;small&gt;请选择部门&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n        生日\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入生日&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;birth&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small&gt;请输入生日。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9 am-u-sm-push-3&quot;&gt;\n        &lt;input class&#x3D;&quot;am-btn am-btn-success&quot; value&#x3D;&quot;添加&quot; type&#x3D;&quot;submit&quot;&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;form&gt;\n\n知识点:\n默认时间格式为y&#x2F;m&#x2F;d，可以在配置文件中修改为y-m-d:\n#时间日期格式化\nspring.mvc.date-format&#x3D;yyyy-MM-dd\n\n404错误页面在templates下新建error文件夹\n在里面建404.html，发生404自动使用该页面\n存入500.html，发生500错误则自动跳入。\n整合JDBCSpringDate对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。\nSpring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。\nSping Data 官网：https://spring.io/projects/spring-data\n数据库相关的启动器 ：可以参考官方文档：\nhttps://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter\n整合JDBC创建一个项目，引入 依赖\n\n项目建好之后，发现自动帮我们导入了如下的启动器：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n编写yaml配置文件连接数据库；\nspring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n配置完这一些东西后，就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下\n@SpringBootTest\nclass SpringbootDataJdbcApplicationTests &#123;\n    &#x2F;&#x2F;DI注入数据源\n    @Autowired\n    DataSource dataSource;\n    @Test\n    public void contextLoads() throws SQLException &#123;\n        &#x2F;&#x2F;看一下默认数据源    com.zaxxer.hikari.HikariDataSource\n        System.out.println(dataSource.getClass());\n        &#x2F;&#x2F;获得连接\n        Connection connection &#x3D; dataSource.getConnection();\n        System.out.println(connection);\n        &#x2F;&#x2F;关闭连接\n        connection.close();\n    &#125;\n&#125;\n\n结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置\nHikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；\n有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate\nJDBC Template即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\n数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。\nSpring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用\nJdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类\nJdbcTemplate主要提供以下几类方法：\n\nexecute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\nupdate方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\nquery方法及queryForXXX方法：用于执行查询相关语句；\ncall方法：用于执行存储过程、函数相关语句。\n\n现在编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；\npackage com.lc.controller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n@RestController\n@RequestMapping(&quot;&#x2F;jdbc&quot;)\npublic class JdbcController &#123;\n    &#x2F;**\n     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate\n     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作\n     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接\n     *&#x2F;\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n    &#x2F;&#x2F;查询employee表中所有数据\n    &#x2F;&#x2F;List 中的1个 Map 对应数据库的 1行数据\n    &#x2F;&#x2F;Map 中的 key 对应数据库的字段名，value 对应数据库的字段值\n    @GetMapping(&quot;&#x2F;list&quot;)\n    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;\n        String sql &#x3D; &quot;select * from mybatis.user&quot;;\n        List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; jdbcTemplate.queryForList(sql);\n        return maps;\n    &#125;\n    &#x2F;&#x2F;新增一个用户\n    @GetMapping(&quot;&#x2F;add&quot;)\n    public String addUser()&#123;\n        &#x2F;&#x2F;插入语句，注意时间问题\n        String sql &#x3D; &quot;insert into mybatis.user(id, name, pwd) &quot; +\n                &quot; values (10,&#39;张三&#39;,&#39;123456&#39;)&quot;;\n        jdbcTemplate.update(sql);\n        &#x2F;&#x2F;查询\n        return &quot;addOk&quot;;\n    &#125;\n    &#x2F;&#x2F;修改用户信息\n    @GetMapping(&quot;&#x2F;update&#x2F;&#123;id&#125;&quot;)\n    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        &#x2F;&#x2F;插入语句\n        String sql &#x3D; &quot;update mybatis.user set name&#x3D;?,pwd&#x3D;? where id&#x3D;&quot;+id;\n        &#x2F;&#x2F;数据\n        Object[] objects &#x3D; new Object[2];\n        objects[0] &#x3D; &quot;修改名&quot;;\n        objects[1] &#x3D; &quot;AAAAAA&quot;;\n        jdbcTemplate.update(sql,objects);\n        &#x2F;&#x2F;查询\n        return &quot;updateOk&quot;;\n    &#125;\n    &#x2F;&#x2F;删除用户\n    @GetMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)\n    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        &#x2F;&#x2F;插入语句\n        String sql &#x3D; &quot;delete from mybatis.user where id&#x3D;?&quot;;\n        jdbcTemplate.update(sql,id);\n        &#x2F;&#x2F;查询\n        return &quot;deleteOk&quot;;\n    &#125;\n&#125;\n\n测试请求，结果正常；\n到此，CURD的基本操作，使用 JDBC 就搞定了。\n整合Druid数据源Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。\nDruid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。\nDruid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\nDruid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。\nSpring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。\nGithub地址：https://github.com/alibaba/druid/\n配置数据源添加上 Druid 数据源依赖。\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.1.21&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源\n\n数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；\n\n确定切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码\nspring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500\n\n导入Log4j 的依赖\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性\npackage com.kuang.config;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport javax.sql.DataSource;\n@Configuration\npublic class DruidConfig &#123;\n    &#x2F;*\n       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\n       @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)：作用就是将 全局配置文件中\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中\n     *&#x2F;\n    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druidDataSource() &#123;\n        return new DruidDataSource();\n    &#125;\n&#125;\n\n去测试类中测试一下；看是否成功！\n@SpringBootTest\nclass SpringbootDataJdbcApplicationTests &#123;\n    &#x2F;&#x2F;DI注入数据源\n    @Autowired\n    DataSource dataSource;\n    @Test\n    public void contextLoads() throws SQLException &#123;\n        &#x2F;&#x2F;看一下默认数据源\n        System.out.println(dataSource.getClass());\n        &#x2F;&#x2F;获得连接\n        Connection connection &#x3D;   dataSource.getConnection();\n        System.out.println(connection);\n        DruidDataSource druidDataSource &#x3D; (DruidDataSource) dataSource;\n        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());\n        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());\n        &#x2F;&#x2F;关闭连接\n        connection.close();\n    &#125;\n&#125;\n\n输出结果 ：可见配置参数已经生效！\n整合Mybatis官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\nMaven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1\n整合测试导入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n配置数据库连接信息（不变）\nspring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500\n\n测试数据库是否连接成功！\n创建实体类，导入 Lombok！\nUser.java\npackage com.xiao.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private String name;\n    private String pwd;\n&#125;\n\n创建mapper目录以及对应的 Mapper 接口\nUserMapper.java\npackage com.lc.mapper;\nimport com.lc.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.springframework.stereotype.Repository;\nimport java.util.List;\n&#x2F;&#x2F;这个注解表示这是一个Mybatis的mapper类\n@Mapper\n@Repository\npublic interface UserMapper &#123;\n    List&lt;User&gt; queryUserList();\n    User queryUserById(int id);\n    int addUser(User user);\n    int updateUser(User user);\n    int deleteUser(int id);\n&#125;\n\n对应的Mapper映射文件\nUserMapper.xml，建在resources&#x2F;mybatis&#x2F;mapper下\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper&gt;\n    &lt;select id&#x3D;&quot;queryUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n        select * from mybatis.user;\n    &lt;&#x2F;select&gt;\n    &lt;select id&#x3D;&quot;queryUserById&quot; resultType&#x3D;&quot;User&quot;&gt;\n        select * from mybatis.user where id &#x3D; #&#123;id&#125;\n    &lt;&#x2F;select&gt;\n    &lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n        insert into mybatis.user(id, name, pwd)\n        values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);\n    &lt;&#x2F;insert&gt;\n    &lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n        update mybatis.user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;update&gt;\n    &lt;delete id&#x3D;&quot;deleteUser&quot;parameterType&#x3D;&quot;int&quot;&gt;\n        delete from mybatis.user where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;delete&gt;\n&lt;&#x2F;mapper&gt;\n\n在配置文件application.yml中整合Mybatis :\n#整合Mybatis\n#别名\n#mapper地址\nmybatis:\n  type-aliases-package: com.lc.pojo\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml\n\n编写UserController 进行测试！\npackage com.lc.controller;\nimport com.lc.mapper.UserMapper;\nimport com.lc.pojo.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.List;\n@RestController\npublic class UserController &#123;\n    @Autowired\n    private UserMapper userMapper;\n    @RequestMapping(&quot;&#x2F;list&quot;)\n    public List&lt;User&gt; queryUserList()&#123;\n        List&lt;User&gt; list &#x3D; userMapper.queryUserList();\n        for (User user : list) &#123;\n            System.out.println(user);\n        &#125;\n        return list;\n    &#125;\n    @RequestMapping(&quot;&#x2F;queryUser&#x2F;&#123;id&#125;&quot;)\n    public User queryUserById(@PathVariable(&quot;id&quot;) int id)&#123;\n        return userMapper.queryUserById(id);\n    &#125;\n    @RequestMapping(&quot;&#x2F;addUser&quot;)\n    public String addUser()&#123;\n        int res &#x3D; userMapper.addUser(new User(10,&quot;增加&quot;,&quot;123456&quot;));\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)\n    public String deleteUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        int res &#x3D; userMapper.deleteUser(id);\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;updateUser&quot;)\n    public String updateUser()&#123;\n        int res &#x3D; userMapper.updateUser(new User(10,&quot;xxxx&quot;,&quot;111111&quot;));\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n&#125;\n\n启动项目访问进行测试！\nSpringSecurity(安全)在 Web  开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。\n市面上存在比较有名的：Shiro，Spring Security ！\nSpring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。\nSpring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求\nSpring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web  应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。\n对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security  框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP  等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control  List，ACL），可以对应用中的领域对象进行细粒度的控制。\n实战测试新建一个初始的springboot项目web模块，thymeleaf模块\n导入静态资源\ncontroller实现跳转 :\npackage com.kuang.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\npublic class RouterController &#123;\n   @RequestMapping(&#123;&quot;&#x2F;&quot;,&quot;&#x2F;index&quot;&#125;)\n   public String index()&#123;\n       return &quot;index&quot;;\n  &#125;\n   @RequestMapping(&quot;&#x2F;toLogin&quot;)\n   public String toLogin()&#123;\n       return &quot;views&#x2F;login&quot;;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level1&#x2F;&#123;id&#125;&quot;)\n   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level1&#x2F;&quot;+id;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level2&#x2F;&#123;id&#125;&quot;)\n   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level2&#x2F;&quot;+id;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level3&#x2F;&#123;id&#125;&quot;)\n   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level3&#x2F;&quot;+id;\n  &#125;\n&#125;\n\n认识SpringSecuritySpring Security  是针对Spring项目的安全框架，也是Spring  Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入  spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n记住几个类：\n\nWebSecurityConfigurerAdapter：自定义Security策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启WebSecurity模式\n\nSpring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。\n“认证”（Authentication）\n身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。\n身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。\n “授权” （Authorization）\n授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。\n这个概念是通用的，而不是只在Spring Security 中存在。\n认证和授权目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能\n引入 Spring Security 模块\n&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n编写 Spring Security 配置类\n参考官网：https://spring.io/projects/spring-security \n查看我们自己项目中的版本，找到对应的帮助文档：\nhttps://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5  #servlet-applications 8.16.4\n\n编写基础配置类\npackage com.kuang.config;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n@EnableWebSecurity &#x2F;&#x2F; 开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    &#x2F;&#x2F;授权\n   @Override\n   protected void configure(HttpSecurity http) throws Exception &#123;\n  &#125;\n&#125;\n\n定制请求的授权规则\n &#x2F;&#x2F;授权\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n   &#x2F;&#x2F; 定制请求的授权规则\n   &#x2F;&#x2F; 首页所有人可以访问\n   http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()\n  .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n  .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n  .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n&#125;\n\n测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！\n在configure()方法中加入以下配置，开启自动配置的登录功能！\n&#x2F;&#x2F; 开启自动配置的登录功能\n&#x2F;&#x2F; &#x2F;login 请求来到登录页\n&#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败\n&#x2F;&#x2F;没有权限默认到登陆页面，需要开启登陆页面\nhttp.formLogin();\n\n测试一下：发现，没有权限的时候，会跳转到登录的页面！\n查看刚才登录页的注释信息；\n我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法\n&#x2F;&#x2F;定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n   auth.inMemoryAuthentication()\n          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n&#125;\n\n测试，我们可以使用这些账号登录进行测试！发现会报错！\nThere is no PasswordEncoder mapped for the id “null”\n原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码\n&#x2F;&#x2F;定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n   &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n   &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n   &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。\n   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n&#125;\n\n测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定\n完整配置代码package com.kuang.config;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n   &#x2F;&#x2F;定制请求的授权规则\n   @Override\n   protected void configure(HttpSecurity http) throws Exception &#123;\n       http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()\n      .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n      .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n      .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n       &#x2F;&#x2F;开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！\n           &#x2F;&#x2F; &#x2F;login 请求来到登录页\n           &#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败\n       http.formLogin()\n          .usernameParameter(&quot;username&quot;)\n          .passwordParameter(&quot;password&quot;)\n          .loginPage(&quot;&#x2F;toLogin&quot;)\n          .loginProcessingUrl(&quot;&#x2F;login&quot;); &#x2F;&#x2F; 登陆表单提交请求\n       &#x2F;&#x2F;开启自动配置的注销的功能\n           &#x2F;&#x2F; &#x2F;logout 注销请求\n           &#x2F;&#x2F; .logoutSuccessUrl(&quot;&#x2F;&quot;); 注销成功来到首页\n       http.csrf().disable();&#x2F;&#x2F;关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求\n       http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);\n       &#x2F;&#x2F;记住我\n       http.rememberMe().rememberMeParameter(&quot;remember&quot;);\n  &#125;\n   &#x2F;&#x2F;定义认证规则\n   @Override\n   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n       &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n       &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n       &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n       &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。\n       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n              .and()\n              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n              .and()\n              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n  &#125;\n&#125;\n\n\n\nShiro什么是Shiro\nApache Shiro是一个Java的安全（权限）框架。\nShiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。\nShiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。\n下载地址: http://shiro.apache.org/\n\n功能\nAuthentication:身份认证、登录，验证用户是不是拥有相应的身份;\nAuthorization: 授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如:验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!\nSession Manager:会话管理，即用户登录后就是第一次会话，在没有退出之前，它的所有信息都在会话中;会话可以是普通的JavaSE环境，也可以是Web环境;\nCryptography:加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储;\nWeb Support: Web支持，可以非常容易的集成到Web环境;\nCaching:缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，这样可以提高效率\nConcurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去\nTesting:提供测试支持;\nRun As:允许一个用户假装为另一个用户(如果他们允许）的身份进行访问;\nRemember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了\n\n三大核心组件Shiro有三大核心组件，即Subject、SecurityManager和Realm\nSubject\n\n\n\n\n\n\n\n\n\n为认证主体。应用代码直接交互的对象是Subject,Subject代表了当前的用户。包含Principals和Credentials两个信息。\nPricipals:代表身份。可以是用户名、邮件、手机号码等等，用来标识一个登陆主题的身份。\nCredentials:代表凭证。常见的有密码、数字证书等等。\n也就是说两者代表了认证的内容，最常见就是用户名密码了。用Shiro进行身份认证，其中就包括主体认证。\nSecurityManager\n\n\n\n\n\n\n\n\n\n为安全管理员。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager, Subject相当于是一个门面，而SecurityManager才是真正的执行者。它负责与Shiro 的其他组件进行交互。\nRealm\n\n\n\n\n\n\n\n\n\n是一个域。充当了Shiro与应用安全数据间的“桥梁”。\nShiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能过进行，可以把Realm看成DataSource，即安全数据源。\n内部架构\nSubject: 主体，主体可以是任何可以与应用交互的“用户”\nSecurityManager: 是Shiro的核心，所有具体的交互都需通过SecurityManager进行，它管理所有的Subject，且负责进行认证授权，会话，及缓存的管理。\nAuthenticator:负责主体认证。当用户尝试登录时，该逻辑被Authenticatior执行。Authenticator知道如何与一个或多个Realm协调来存储相关的用户。从Realm中获得的数据被用来验证用户的身份来保证用户确实是他们所说的他们是谁。\nAutentication Strategy:如果不止一个Realm被配置，其会协调这些Realm来决定身份认证尝试成功或失败下的条件（比如，如果一个Realm成功，而其他的失败，是否该尝试成功？）\nAuthorizer:负责在应用程序中决定用户的访问控制。它是一种最终判定用户是否被允许做某事的机制。与Authenticator相似，Authorizer也知道如何协调多个后台数据源来访问角色恶化权限信息。Authorizer使用该信息来准确度的决定用户是否被允许执行给定的动作。\nSessionManager：知道如何去创建及管理用户Session生命周期来为所有环境下的用户提供一个强健的session体验。\nSessionDAO：代表SessionManager执行Session持久化操作。允许数据存储**入到会员管理的基础之中。\nCacheManager:创建并管理其他Shiro组件使用的Cache实例声明周期。因为Shiro能访问许多后台数据源，由于身份验证、授权和会话管理，缓存在框架中一直是一流 的架构功能，用来在通过还是使用这些数据源时提高性能。\nCryptograhy：是对企业安全框架的一个自然的补充。密码模块，shrio提高了一些常见的加密组件用于密码加密，解密等。\n\n依赖&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;\n    &lt;artifactid&gt;shiro-spring&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\nSwagger什么是Swagger\n号称世界上最流行的API框架\nRestful Api 文档在线自动生成器 &#x3D;&gt; API 文档 与API 定义同步更新\n直接运行，在线测试API\n支持多种语言 （如：Java，PHP等）\n官网：https://swagger.io/\n\n前后端分离\n\n前端 -&gt; 前端控制层、视图层\n后端 -&gt; 后端控制层、服务层、数据访问层\n前后端通过API进行交互\n前后端相对独立且松耦合\n\n产生的问题\n\n前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发\n\n解决方案\n\n首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险\n\nSpringboot集成Swagger需要如下两个jar包\n\nSpringfox-swagger2\nswagger-springmvc\n\n同时要求：jdk 1.8 + 否则swagger2无法运行\n步骤：\n1、新建一个SpringBoot-web项目\n2、添加Maven依赖\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n3、编写HelloController，测试确保运行成功！\n4、要使用Swagger，我们需要编写一个配置类 SwaggerConfig 来配置 Swagger\n@Configuration &#x2F;&#x2F;配置类\n@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置\npublic class SwaggerConfig &#123;  \n&#125;\n\n5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；\n\n常用注解Swagger的所有注解定义在io.swagger.annotations包下\n下面列一些经常用到的，未列举出来的可以另行查阅说明：\n\n\n\nSwagger注解\n简单说明\n\n\n\n@Api(tags &#x3D; “xxx模块说明”)\n作用在模块类上\n\n\n@ApiOperation(“xxx接口说明”)\n作用在接口方法上\n\n\n@ApiModel(“xxxPOJO说明”)\n作用在模型类上：如VO、BO\n\n\n@ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true)\n作用在类方法和属性上，hidden设置为true可以隐藏该属性\n\n\n@ApiParam(“xxx参数说明”)\n作用在参数、方法和字段上，类似@ApiModelProperty\n\n\n我们也可以给请求的接口配置一些注释\n@ApiOperation(&quot;xiao的接口&quot;)\n@PostMapping(&quot;&#x2F;xiao&quot;)\n@ResponseBody\npublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;\n   return username;\n&#125;\n\n这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！\n相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。\nSwagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。\nRPCRPC【Remote Procedure  Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n基本原理\n步骤解析：\n\nRPC两个核心模块：通讯，序列化。\n序列化：数据传输需要转换\n","slug":"学习笔记/springboot学习笔记","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"}]