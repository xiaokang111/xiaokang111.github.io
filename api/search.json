[{"id":"3aaacfb1c55b27ab574dbc9688ad81da","title":"ElasticSearch学习笔记","content":"Elasticsearch\n","slug":"学习笔记/Elasticsearch","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"搜索引擎","author_index":"Aurora"},{"id":"221a7ad001c03569112f684b2dfdc120","title":"Git","content":"Git\n","slug":"学习笔记/Git","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"版本控制","author_index":"Aurora"},{"id":"2753f6a9ea9a9250d658dda483e2dec3","title":"ActiveMQ学习笔记","content":"ActiveMQ\n","slug":"学习笔记/ActiveMQ","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"中间件","author_index":"Aurora"},{"id":"a00b2defe973fe8d6ab3038de496d7b1","title":"JDBC","content":"JDBC\n","slug":"学习笔记/JDBC","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"0b1381c4a63c09e41167c5168339035a","title":"JVM","content":"JVM\n","slug":"学习笔记/JVM","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"2174f5d6204b80063f7ff0e3c82666fd","title":"JavaWeb","content":"JavaWeb\n","slug":"学习笔记/JavaWeb","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"第一章Java基本语法1.1关键字与标识符1.1.1java关键字的使用定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）\n特点：关键字中所字母都为小写\n具体哪些关键字：\n\n\n1.1.2保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。具体哪些保留字：goto 、const\n注意：自己命名标识符时要避免使用这些保留字\n1.1.3.标识符的使用定义：凡是自己可以起名字的地方都叫标识符。\n涉及到的结构：\n包名、类名、接口名、变量名、方法名、常量名\n规则：(必须要遵守。否则，编译不通过)\n\n规范：（可以不遵守，不影响编译和运行。但是要求遵守）\n\n注意点：\n在起名字时，为了提高阅读性，要尽量意义，“见名知意”。\n1.2变量的使用1.2.1变量的分类按数据类型分类\n\n1.2.2定义变量的格式数据类型 变量名 &#x3D; 变量值;\n或\n数据类型 变量名;\n变量名 &#x3D; 变量值;\n1.2.3变量使用的注意点① 变量必须先声明，后使用\n② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了\n③ 同一个作用域内，不可以声明两个同名的变量\n1.2.4基本数据类型变量间运算规则\n涉及到的基本数据类型：除了boolean之外的其他7种\n\n自动类型转换(只涉及7种基本数据类型）\n\n\n结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。\nbyte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double\n特别的：当byte、char、short三种类型的变量做运算时，结果为int型\n说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量\n\n强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。\n\n\n需要使用强转符：()\n注意点：强制类型转换，可能导致精度损失。\n\n\nString与8种基本数据类型间的运算\n\n\nString属于引用数据类型,翻译为：字符串\n声明String类型变量时，使用一对””\nString可以和8种基本数据类型变量做运算，且运算只能是连接运算：+\n运算的结果仍然是String类型\n\n避免：\nString s &#x3D; 123;&#x2F;&#x2F;编译错误\nString s1 &#x3D; “123”;\nint i &#x3D; (int)s1;&#x2F;&#x2F;编译错误\n1.3进制1.3.1编程中涉及的进制及表示方式：\n1.3.2二进制的使用说明：\n计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。\n二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。\n原码、反码、补码的说明：\n\n正数：三码合一\n负数：\n\n1.3.3进制间的互相转换\n图示：\n\n\n图示二进制转换为十进制：\n\n\n\n\n\n\n图示十进制转换为二进制：\n\n\n\n二进制与八进制、十六进制间的转换\n\n\n\n1.4运算符1.4.1算术运算符算术运算符： + - + - * &#x2F; % (前)++ (后)++ (前)– (后)– +\n除号：&#x2F;\n%:取余运算\n(前)++ :先自增1，后运算\n(后)++ :先运算，后自增1\n(前)– :先自减1，后运算\n(后)– :先运算，后自减1\n连接符：+：只能使用在String与其他数据类型变量之间使用。\n1.4.2赋值运算符赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;\n1.4.3比较运算符比较运算符（关系运算符）: &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; instanceof\n比较运算符的结果是boolean类型\n&lt; &gt; &gt;&#x3D; &lt;&#x3D; :只能使用在数值类型的数据之间。\n&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。\n1.4.4逻辑运算符&amp; &amp;&amp; | || ! ^\n区分&amp; 与 &amp;&amp;\n相同点1：&amp; 与 &amp;&amp; 的运算结果相同\n相同点2：当符号左边是true时，二者都会执行符号右边的运算\n不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。\n区分：| 与 ||\n相同点1：| 与 || 的运算结果相同\n相同点2：当符号左边是false时，二者都会执行符号右边的运算\n不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算\n逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型\n1.4.5位运算符&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~\n一个&amp;时，参加运算的两个数据，按二进制位进行“与”运算。运算规则：同1为一，其余为0。\n一个 | 时，参加运算的两个对象，按二进制位进行“或”运算。运算规则：同0为0，有1为1。另外，负数按补码形式参加按位或运算。\n位异或（^）：\n参与运算的两个数据，按二进制位进行“异或”运算。运算规则：相同为0，不同为1。\n非位（~）：\n按位取反操作会翻转其每一位。运算规则：0变为1，1变为0。\n左移（&lt;&lt;）：\n符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：高位丢弃，低位补0。\n右移（&gt;&gt;）：\n符号左边是要进行左移运算的数，右边表示要移动的位数。运算规则：正数左补0，负数左补1.\n无符号右移（&gt;&gt;&gt;）：\n即右移之后，无论该数为正还是为负，右移之后左补0。\n1.4.6三元运算符(条件表达式)? 表达式1 : 表达式2\n\n说明\n\n① 条件表达式的结果为boolean类型\n② 根据条件表达式真或假，决定执行表达式1，还是表达式2.\n如果表达式为true，则执行表达式1。\n如果表达式为false，则执行表达式2。\n\n凡是可以使用三元运算符的地方，都可以改写为if-else\n\n如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。\n\n\n1.5流程控制1.5.1分支结构if-else条件判断结构\n结构一：\nif(条件表达式)&#123;\n执行表达式\n&#125;\n\n结构二：二选一\nif(条件表达式)&#123;\n执行表达式1\n&#125;else&#123;\n执行表达式2\n&#125;\n\n结构三：n选一\nif(条件表达式)&#123;\n执行表达式1\n&#125;else if(条件表达式)&#123;\n执行表达式2\n&#125;else if(条件表达式)&#123;\n执行表达式3\n&#125;\n...\nelse&#123;\n执行表达式n\n&#125;\n\n说明：\n\nelse 结构是可选的。\n\n针对于条件表达式：\n&gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。\n&gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。\n&gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了\n\nif-else结构是可以相互嵌套的。\n\n如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。\n\n\nswitch-case选择结构\nswitch(表达式)&#123;\ncase 常量1:\n执行语句1;\n&#x2F;&#x2F;break;\ncase 常量2:\n执行语句2;\n&#x2F;&#x2F;break;\n...\ndefault:\n执行语句n;\n&#x2F;&#x2F;break;\n&#125;\n\n说明：\n① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。\n当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。\n② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构\n③ switch结构中的表达式，只能是如下的6种数据类型之一：\nbyte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)\n④ case 之后只能声明常量。不能声明范围。\n⑤ break关键字是可选的。\n⑥ default:相当于if-else结构中的else.\ndefault结构是可选的，而且位置是灵活的。\n\n如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。\n\nbreak在switch-case中是可选的\n\n\n1.5.2循环结构1.循环结构的四要素\n① 初始化条件\n② 循环条件 —&gt;是boolean类型\n③ 循环体\n④ 迭代条件\n说明：通常情况下，循环结束都是因为②中循环条件返回false了。\n2.循环的三种结构\n2.1 for循环结构\nfor(①;②;④)&#123;\n③\n&#125;\n\n执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②\n2.2 while循环结构\n①\nwhile(②)&#123;\n③;\n④;\n&#125;\n\n执行过程：① - ② - ③ - ④ - ② - ③ - ④ - … - ②\n说明：\n写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！\nfor和while循环总结：\n\n开发中，基本上我们都会从for、while中进行选择，实现循环结构。\nfor循环和while循环是可以相互转换的！\n区别：for循环和while循环的初始化条件部分的作用范围不同。\n我们写程序，要避免出现死循环。\n\n2.3 do-while循环结构\n①\ndo&#123;\n③;\n④;\n&#125;while(②);\n\n执行过程：① - ③ - ④ - ② - ③ - ④ - … - ②\n说明：\n\ndo-while循环至少会执行一次循环体！\n开发中，使用for和while更多一些。较少使用do-while\n\n3.“无限循环”结构: while(true) 或 for(;;)\n总结：如何结束一个循环结构？\n方式一：当循环条件是false时\n方式二：在循环体中，执行break\n4.嵌套循环\n1.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环\n内层循环：循环结构A\n外层循环：循环结构B\n2.说明：\n① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次\n② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次\n③ 外层循环控制行数，内层循环控制列数\n补充:衡量一个功能代码的优劣：\n1.正确性\n2.可读性\n3.健壮性\n4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）\n1.5.3break和continue1.break用于跳出一个循环体或者完全结束一个循环，不仅可以结束其所在的循环，还可结束其外层循环。\n注意：（1）只能在循环体内和switch语句体内使用break。（2）不管是哪种循环，一旦在循环体中遇到break，系统将完全结束循环，开始执行循环之后的代码。（3）当break出现在循环体中的switch语句体内时，起作用只是跳出该switch语句体，并不能终止循环体的执行。若想强行终止循环体的执行，可以在循环体中，但并不在switch语句中设置break语句，满足某种条件则跳出本层循环体。\n2.continue语句的作用是跳过本次循环体中剩下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为只是中止(跳过)本次循环，接着开始下一次循环。\n注意：（1）continue语句并没有使整个循环终止。（2）continue 只能在循环语句中使用，即只能在 for、while 和 do…while 语句中使用。\n第二章数组2.1一维数组1.一维数组的声明与初始化\n正确的方式：\nint num;&#x2F;&#x2F;声明\nnum &#x3D; 10;&#x2F;&#x2F;初始化\nint id &#x3D; 1001;&#x2F;&#x2F;声明 + 初始化\n\nint[] ids;&#x2F;&#x2F;声明\n1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行\nids &#x3D; new int[]&#123;1001,1002,1003,1004&#125;;\n1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行\nString[] names &#x3D; new String[5];\n\n\n\n2.一维数组元素的引用：通过角标的方式调用。\n&#x2F;&#x2F;数组的角标（或索引从0开始的，到数组的长度-1结束。\nnames[0] &#x3D; &quot;王铭&quot;;\nnames[1] &#x3D; &quot;王赫&quot;;\nnames[2] &#x3D; &quot;张学良&quot;;\nnames[3] &#x3D; &quot;孙居龙&quot;;\nnames[4] &#x3D; &quot;王宏志&quot;;&#x2F;&#x2F;charAt(0)\n\n3.数组的属性：length\nSystem.out.println(names.length);&#x2F;&#x2F;5\nSystem.out.println(ids.length);\n\n说明：\n数组一旦初始化，其长度就是确定的。arr.length\n数组长度一旦确定，就不可修改。\n4.一维数组的遍历\nfor(int i &#x3D; 0;i &lt; names.length;i++)&#123;\nSystem.out.println(names[i]);\n&#125;\n\n5.一维数组元素的默认初始化值\n数组元素是整型：0\n数组元素是浮点型：0.0\n数组元素是char型：0或’\\u0000’，而非’0’\n数组元素是boolean型：false\n2.2二维数组1.如何理解二维数组？\n\n数组属于引用数据类型\n数组的元素也可以是引用数据类型\n一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。\n\n2.二维数组的声明与初始化\n正确的方式：\nint[] arr &#x3D; new int[]&#123;1,2,3&#125;;&#x2F;&#x2F;一维数组\n&#x2F;&#x2F;静态初始化 二维数组\nint[][] arr1 &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;\n&#x2F;&#x2F;动态初始化1\nString[][] arr2 &#x3D; new String[3][2];\n&#x2F;&#x2F;动态初始化2\nString[][] arr3 &#x3D; new String[3][];\n&#x2F;&#x2F;也是正确的写法：\nint[] arr4[] &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;\n\nint[] arr5[] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;&#x2F;&#x2F;类型推断\n\n3.如何调用二维数组元素:\nSystem.out.println(arr1[0][1]);&#x2F;&#x2F;2\nSystem.out.println(arr2[1][1]);&#x2F;&#x2F;null\n\n4.二维数组的属性：\nSystem.out.println(arr4.length);&#x2F;&#x2F;3\nSystem.out.println(arr4[0].length);&#x2F;&#x2F;3\nSystem.out.println(arr4[1].length);&#x2F;&#x2F;4\n\n5.遍历二维数组元素\nfor(int i &#x3D; 0;i &lt; arr4.length;i++)&#123;\n\tfor(int j &#x3D; 0;j &lt; arr4[i].length;j++)&#123;\n\tSystem.out.print(arr4[i][j] + &quot; &quot;);\n\t&#125;\n\tSystem.out.println();\n&#125;\n\n6.二维数组元素的默认初始化值\n规定：二维数组分为外层数组的元素，内层数组的元素\nint[][] arr &#x3D; new int[4][3];\n外层元素：arr[0],arr[1]等\n内层元素：arr[0][0],arr[1][2]等\n2.3数组常见算法1.数组的创建与元素赋值：\n杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。\n2.针对于数值型的数组：\n最大值、最小值、总和、平均数等\n3.数组的赋值与复制\nint[] array1,array2;\narray1 &#x3D; new int[]{1,2,3,4};\n3.1 赋值：\narray2 &#x3D; array1;\n如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。\n3.2 复制：\narray2 &#x3D; new int[array1.length];\nfor(int i &#x3D; 0;i &lt; array2.length;i++)&#123;\n\tarray2[i] &#x3D; array1[i];\n&#125;\n\n如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。\n4.数组元素的反转\n&#x2F;&#x2F;方法一：\nfor(int i &#x3D; 0;i &lt; arr.length &#x2F; 2;i++)&#123;\n\tString temp &#x3D; arr[i];\n\tarr[i] &#x3D; arr[arr.length - i -1];\n\tarr[arr.length - i -1] &#x3D; temp;\n&#125;\n\n\n\n&#x2F;&#x2F;方法二：\nfor(int i &#x3D; 0,j &#x3D; arr.length - 1;i &lt; j;i++,j--)&#123;\n\tString temp &#x3D; arr[i];\n\tarr[i] &#x3D; arr[j];\n\tarr[j] &#x3D; temp;\n&#125; \n\n5.数组中指定元素的查找：搜索、检索\n5.1 线性查找：\n实现思路：通过遍历的方式，一个一个的数据进行比较、查找。\n适用性：具有普遍适用性。\n5.2 二分法查找：\n实现思路：每次比较中间值，折半的方式检索。\n适用性：（前提：数组必须有序）\n6.数组的排序算法\n理解：\n1）衡量排序算法的优劣：\n时间复杂度、空间复杂度、稳定性\n2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）\n3）不同排序算法的时间复杂度\n4）手写冒泡排序\nint[] arr &#x3D; new int[]{43,32,76,-98,0,64,33,-21,32,99};\n&#x2F;&#x2F;冒泡排序\nfor(int i &#x3D; 0;i &lt; arr.length - 1;i++)&#123;\n\tfor(int j &#x3D; 0;j &lt; arr.length - 1 - i;j++)&#123;\n\t\tif(arr[j] &gt; arr[j + 1])&#123;\n\t\tint temp &#x3D; arr[j];\n\t\tarr[j] &#x3D; arr[j + 1];\n\t\tarr[j + 1] &#x3D; temp;\n\t\t&#125;\n\t&#125;\n&#125;        \n\n2.4Arrays工具类1.理解：\n① 定义在java.util包下。\n② Arrays:提供了很多操作数组的方法。\n2.使用：\n&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。\nint[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;\nint[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;\nboolean isEquals &#x3D; Arrays.equals(arr1, arr2);\nSystem.out.println(isEquals);\n\n&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。\nSystem.out.println(Arrays.toString(arr1));\n\n&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。\nArrays.fill(arr1,10);\nSystem.out.println(Arrays.toString(arr1));\n\n&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。\nArrays.sort(arr2);\nSystem.out.println(Arrays.toString(arr2));\n\n&#x2F;&#x2F;5.int binarySearch(int[] a,int key)\nint[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;\nint index &#x3D; Arrays.binarySearch(arr3, 210);\nif(index &gt;&#x3D; 0)&#123;\nSystem.out.println(index);\n&#125;else&#123;\nSystem.out.println(&quot;未找到&quot;);\n&#125;\n\n2.5数组的常见异常1.数组角标越界异常：ArrayIndexOutOfBoundsException\nint[] arr &#x3D; new int[]{1,2,3,4,5};\nfor(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;\n\tSystem.out.println(arr[i]);\n&#125;\n\nSystem.out.println(arr[-2]);\nSystem.out.println(&quot;hello&quot;);\n\n2.空指针异常：NullPointerException\n&#x2F;&#x2F;情况一：\nint[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;\narr1 &#x3D; null;\nSystem.out.println(arr1[0]);\n\n&#x2F;&#x2F;情况二：\nint[][] arr2 &#x3D; new int[4][];\nSystem.out.println(arr2[0][0]);\n\n&#x2F;&#x2F;情况三：\nString[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;\narr3[0] &#x3D; null;\nSystem.out.println(arr3[0].toString());\n\n小知识：一旦程序出现异常，未处理时，就终止执行。\n","slug":"学习笔记/JavaSE","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"942bb69cff6f2eb67f0b841ccb267414","title":"Java高频面试题总结","content":"1.抽象类与接口的区别\n接口中除了static、final变量以外不能有其他变量，而抽象类不一定\n一个类可以实现多个接口但是实现一个抽象类，接口本身可以通过extends关键字扩展多个接口\n接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供实现，抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法\n接口中不能有构造器，抽象类中可以(用于子类调用完成抽象类的初始化操作)\n\n2.final、static、synchronizedfinal：\n\n被final修饰的类不能被继承\n被final修饰的方法不可用被重写\n被final修饰的变量不可用被改变，如果修饰引用表示引用不可变，引用指向的内容可变\n被final修饰的方法，jvm会尝试将其内联，以提高运行效率\n被final修饰的常量，在编译阶段会存入常量池\n\nstatic：\n\n被static修饰的变量&#x2F;方法都属于类的静态资源，由类的实例所共享\n\nsynchronized（同步锁）：\n被sychronized修饰的代码块或方法只会有一个线程执行，已到达保证并发安全的效果\n\n修饰实例方法：作用于当前实例加锁\n修饰静态方法：作用于当前类对象加锁\n修饰代码块：指定加锁对象，对给定对象加锁\n\n3.String、StringBuilder、StringBuffer区别String类中使用final关键字修饰字符数组来保存字符串，所以String是不可变的\nStringBuilder和StringBuffer都是继承自AbstractStringBuilder 类，底层字符数组没有使用final修饰，所以可变\nStringBuffer中对方法加了同步锁，所以线程安全，而StringBuilder则没有\n总结：\n操作少量数据时使用String\n单线程操作字符串缓冲区下操作大量数据时使用StringBuilder\n多线程操作字符串缓冲区下操作大量数据时使用StringBuffer\n4.equals与&#x3D;&#x3D;的区别和使用场景如果是基本数据类型 &#x3D;&#x3D; 就是比较的值，引用数据类型&#x3D;&#x3D;比较的是内存地址\nequals没有被重写时，比较的是内存地址，被重写则是比较值\n5.深拷贝和浅拷贝浅拷贝 ：只复制指向某个对象的指针，而不复制对象本身，相当于是新建了一个对象，该对象复制了原对象的指针，新旧对象还是共用一个内存块\n深拷贝：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象\n6.Error和Exception\nException 和 Error体现了java平台设计者对不同异常情况的分类, Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理.\nError 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获, 常见的OutOfMemoryError 是Error的子类.\n\n7.反射的机制和应用场景反射：动态获取信息或动态调用对象方法的机制，对于任何一个类都能知道他的所有属性和方法，对于任何对象，都可以获取对象的方法\n应用场景：\n\n通过配置信息调用类的方法\n结合注解实现特殊功能\n按需加载jar包或class\n\n8.谈谈List,Set,Map的区别？\n谈谈ArrayList和LinkedList的区别？\n请说一下HashMap与HashTable的区别\n谈一谈ArrayList的扩容机制？\nHashMap 的实现原理？\n请简述 LinkedHashMap 的工作原理和使用方式？\n谈谈对于ConcurrentHashMap的理解?\n\nJava 中使用多线程的方式有哪些？\n说一下线程的几种状态？\n如何实现多线程中的同步？\n谈谈线程死锁，如何有效的避免线程死锁？\n谈谈线程阻塞的原因？\n请谈谈 Thread 中 run() 与 start()的区别？\nsynchronized和volatile关键字的区别？\n如何保证线程安全？\n谈谈ThreadLocal用法和原理？\nJava 线程中notify 和 notifyAll有什么区别？\nsynchronized和volatile关键字的区别？\n","slug":"学习笔记/Java高频面试题","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"面试","author_index":"Aurora"},{"id":"3fe1ee3f3830128bf539e5f4ed9fbbe9","title":"Linux","content":"Linux\n","slug":"学习笔记/Linux","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"操作系统","author_index":"Aurora"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"MyBatis\n","slug":"学习笔记/MyBatis","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"a29e07a1f79a3f2735cebc4555df7972","title":"MyBatisPlus","content":"MyBatisPlus\n","slug":"学习笔记/MyBatisPlus","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"Maven\n","slug":"学习笔记/Maven","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"版本控制","author_index":"Aurora"},{"id":"838ae74e3a76757d637de803a615bfd9","title":"MySQL","content":"MySQL\n","slug":"学习笔记/MySQL","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"数据库","author_index":"Aurora"},{"id":"ee30ef9a588d2ac3314205f5348312b8","title":"RabbtiMQ学习笔记","content":"RabbitMQ\n","slug":"学习笔记/RabbitMQ","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"中间件","author_index":"Aurora"},{"id":"af6a277a1f79cc7652a602f9f57ed64f","title":"Nginx","content":"第一章认识Nginx","slug":"学习笔记/Nginx","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"00f7272b819970a0b81a0a2ebb098979","title":"Redis6","content":"Redis6\n","slug":"学习笔记/Redis6","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"数据库","author_index":"Aurora"},{"id":"fceed54d2b78e915f81cbddb878dcc7f","title":"SpringSecurity","content":"Spring Security\n","slug":"学习笔记/Spring Security","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"b26b54b0cb74df6cb29813cfb88d3e9d","title":"SSM框架整合","content":"SSM整合\n","slug":"学习笔记/SSM整合","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"d6ae9949d97b7b62e8df1871093bd77d","title":"Spring5","content":"Spring5\n","slug":"学习笔记/Spring5","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"SpringBoot2\n","slug":"学习笔记/SpringBoot2","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"SpringMVC\n","slug":"学习笔记/SpringMVC","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"11c0f2fa5655c019aeb2222b34a90ab0","title":"数据结构与算法","content":"数据结构与算法\n","slug":"学习笔记/数据结构与算法","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"},{"id":"8c6c59136f9c0c8c29b87ea646eed9d1","title":"操作系统","content":"操作系统\n","slug":"学习笔记/操作系统","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"},{"id":"2fdfe1e1ace8a4912a23a4cbc1c92824","title":"SpringCloud","content":"微服务技术栈🤤基础篇\n\n认识微服务\n服务拆分\n远程调用\nEureka\nRibbon\nNacos\nFeign\nGateway\nRabbitMQ\nElasticsearch\n\n💻高级篇\n\nJMeter\nSentinel\nSeata\nRedis\n。。。\n\n认识微服务单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署\n优点：架构简单，部署成本较低\n缺点：耦合度高（维护困难、升级困难）\n分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务\n优点：降低服务耦合，有利于服务升级和拓展\n缺点：调用服务关系错综复杂\n分布式架构虽然降低了服务耦合，但是服务拆分时也会有很多问题需要思考：\n\n服务拆分的粒度如何界定？\n服务之间如何调用？\n服务的调用关系如何管理？\n\n所以需要一套行之有效的标准来约束分布式架构\n微服务微服务的架构特征：\n\n单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n\n自治：团队独立、技术独立、数据独立，独立部署和交付\n\n面向服务：服务提供统一标准的接口，与语言和技术无关\n\n隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n\n\n微服务的上述特征其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。\n因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法其中在Java领域最引人注目的就是SpringCloud提供的方案了\nSpringCloudSpringCloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。\nSpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。\n其中常见的组件包括：\n\n另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：\n\n内容知识\n\n\n技术栈对比\n服务拆分：代码参考：\nGitee：https:&#x2F;&#x2F;gitee.com&#x2F;xn2001&#x2F;cloudcode&#x2F;tree&#x2F;master&#x2F;01-cloud-demo\n\n服务拆分注意事项\n单一职责：不同微服务，不要重复开发相同业务\n数据独立：不要访问其它微服务的数据库\n面向服务：将自己的业务暴露为接口，供其它微服务调用\n\ncloud-demo：父工程，管理依赖\n\norder-service：订单微服务，负责订单相关业务\nuser-service：用户微服务，负责用户相关业务\n\n要求：\n\n订单微服务和用户微服务都必须有各自的数据库，相互独立\n订单服务和用户服务都对外暴露 Restful 的接口\n订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库\n\n微服务项目下，打开 idea 中的 Service，可以很方便的启动。\n\n启动完成后，访问 http://localhost:8080/order/101\n\n远程调用正如上面的服务拆分要求中所提到，\n订单服务如果需要查询用户信息，**只能调用用户服务的 Restful 接口**，不能查询用户数据库\n\n因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）\n\n发送请求，自动序列化为 Java 对象。\n\n启动完成后，访问：http://localhost:8080/order/101\n\n在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要服务注册中心（Eureka）来帮我们解决这个事情。\nEureka注册中心服务调用关系\n\n服务提供者：暴露接口给其它微服务调用\n服务消费者：调用其它微服务提供的接口\n\n服务调用中可能出现的问题\n\nEureka的作用：提供一个注册中心，将所有的服务进行注册，需要时动态调用，每30秒检测一次服务是否正常\n\n\norder-service 如何得知 user-service 实例地址？\n\nuser-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做服务注册\neureka-server 保存服务名称到服务实例地址列表的映射关系\norder-service 根据服务名称，拉取实例地址列表，这个叫服务发现或服务拉取\n\norder-service 如何从多个 user-service 实例中选择具体的实例？\norder-service从实例列表中利用负载均衡算法选中一个实例地址，向该实例地址发起远程调用\norder-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？\n\nuser-service 会每隔一段时间(默认30秒)向 eureka-server 发起请求，报告自己状态，称为心跳\n当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除\norder-service 拉取服务时，就能将故障实例排除了\n\n接下来我们动手实践的步骤包括\n\n搭建注册中心搭建 eureka-server\n引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 server\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n编写启动类\n注意要添加一个 @EnableEurekaServer 注解，开启 eureka 的注册中心功能\npackage cn.itcast.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(EurekaApplication.class,args);\n    &#125;\n&#125;\n\n编写配置文件\n编写一个 application.yml 文件，内容如下：\nserver:\n  port: 10086\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka\n\n其中 default-zone 是因为前面配置类开启了注册中心所需要配置的 eureka 的地址信息，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka 集群时，这里就可以填写多个，使用 “,” 隔开。\n启动完成后，访问 http://localhost:10086/\n\n到这 服务注册中心就搭建完成了\n服务注册\n将 user-service、order-service 都注册到 eureka\n\n引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 client\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n在启动类上添加注解：@EnableEurekaClient\n\n在 application.yml 文件，添加下面的配置：\nspring:\n  application:\n      #name：orderservice\n    name: userservice\neureka:\n  client:\n    service-url: \n      defaultZone: http:127.0.0.1:10086&#x2F;eureka\n\n3个项目启动后，访问 http://localhost:10086/\n\n可以看到eureka本身和另外两个服务都注册成功\n这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。\n\n4个项目启动后，访问 http://localhost:10086/\n\n服务拉取在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用\n\n下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。\n首先给 RestTemplate 这个 Bean 添加一个 @LoadBalanced 注解，用于开启负载均衡。（后面会讲）\n@Bean\n@LoadBalanced\npublic RestTemplate restTemplate()&#123;\n    return new RestTemplate();\n&#125;\n\n修改 OrderService 访问的url路径，用服务名代替ip、端口：\n\nspring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。\nRibbon负载均衡我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？\nSpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。\n源码跟踪为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。\n进入源码跟踪查看底层原理：\n\n这里的 intercept() 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：\n\nrequest.getURI()：获取请求uri，即 http://user-service/user/8\noriginalUri.getHost()：获取uri路径的主机名，其实就是服务id user-service\nthis.loadBalancer.execute()：处理服务id，和用户请求\n\n这里的 this.loadBalancer 是 LoadBalancerClient 类型\n继续跟入 execute() 方法：\n\n\ngetLoadBalancer(serviceId)：根据服务id获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表。\ngetServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。在图中可以看到获取了8082端口的服务\n\n可以看到获取服务时，通过一个 getServer() 方法来做负载均衡:\n\n我们继续跟入：\n\n继续跟踪源码 chooseServer() 方法，发现这么一段代码：\n\n我们看看这个 rule 是谁：\n\n这里的 rule 默认值是一个 RoundRobinRule ，看类的介绍：\n\n流程总结SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。\n基本流程如下：\n\n拦截我们的 RestTemplate 请求 http://userservice/user/1\nRibbonLoadBalancerClient 会从请求url中获取服务名称，也就是 user-service\nDynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表\neureka 返回列表，localhost:8081、localhost:8082\nIRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081\nRibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 http://localhost:8081/user/1，发起真实请求\n\n\n\n负载均衡策略负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：\n\n不同规则的含义如下：\n\n\n\n内置负载均衡规则类\n规则描述\n\n\n\nRoundRobinRule\n简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。\n\n\nAvailabilityFilteringRule\n对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule  规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。\n\n\nWeightedResponseTimeRule\n为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。\n\n\nZoneAvoidanceRule\n以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。\n\n\nBestAvailableRule\n忽略那些短路的服务器，并选择并发数较低的服务器。\n\n\nRandomRule\n随机选择一个可用的服务器。\n\n\nRetryRule\n重试机制的选择逻辑\n\n\n默认的实现就是 ZoneAvoidanceRule，是一种轮询方案。\n自定义策略通过定义 IRule 实现可以修改负载均衡规则，有两种方式：\n1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：\n\n2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：\nuserservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n\n注意：一般情况下都采用默认的负载均衡规则，不做修改。\n饥饿加载当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。\n\nRibbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。\n而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：\nribbon:\n  eager-load:\n    enabled: true\n    clients: \n    \t-userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;-&quot;隔开\n\nNacos注册中心SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，功能相对eureka会有提升\n\n解压启动 Nacos，详细请看 安装指南\n由于nacos默认采用集群启动， 所以需要使用如下命令进行单机启动\nstartup.cmd -m standalone\n\n访问：http://localhost:8848/nacos/ 就可以看到nocas管理界面了\n\n服务注册这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。引入依赖\n在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：\n如果之前引入过eureka的依赖，需要注释掉~\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.6.RELEASE&lt;&#x2F;version&gt;\n    &lt;type&gt;pom&lt;&#x2F;type&gt;\n    &lt;scope&gt;import&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置nacos地址\n在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：\nspring:\n  cloud:\n    nacos:\n      server-addr: 127.0.0.1:8848\n\n项目重新启动后，可以看到三个服务都被注册进了 Nacos\n\n浏览器访问：http://localhost:8080/order/101，正常访问，同时负载均衡也正常。\n分级存储模型一个服务可以有多个实例，例如我们的 user-service，可以有:\n\n127.0.0.1:8081\n127.0.0.1:8082\n127.0.0.1:8083\n\n假如这些实例分布于全国各地的不同机房，例如：\n\n127.0.0.1:8081，在上海机房\n127.0.0.1:8082，在上海机房\n127.0.0.1:8083，在杭州机房\n\nNacos就将同一机房内的实例，划分为一个集群。\n\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。\n\n配置集群接下来我们给 user-service 配置集群\n修改 user-service 的 application.yml 文件，添加集群配置：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称 HZ杭州\n\n重启两个 user-service 实例后，我们再去启动一个上海集群的实例。\n-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH\n\n\n查看 nacos 控制台\n\nNacosRuleRibbon的默认实现 ZoneAvoidanceRule 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 NacosRule 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。\n@Bean\npublic IRule iRule()&#123;\n    &#x2F;&#x2F;默认为轮询规则，这里自定义为随机规则\n    return new NacosRule();\n&#125;\n\n另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。\nuserservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则\n\n然后，再对 orderservice 配置集群。\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n\n现在我启动了四个服务，分别是：\n\norderservice - HZ\nuserservice - HZ\nuserservice1 - HZ\nuserservice2 - SH\n\n访问地址：http://localhost:8080/order/101\n在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。\n我们试着把 userservice、userservice2 停掉。依旧可以访问。\n在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。\n\n权重配置实际部署中会出现这样的场景：\n服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。\n因此，Nacos 提供了权重配置来控制访问频率，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。\n在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。\n\n在弹出的编辑窗口，修改权重\n\n另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到  0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。\n环境隔离Nacos 提供了 namespace 来实现环境隔离功能。\n\nNacos 中可以有多个 namespace\n\nnamespace 下可以有 group、service 等\n\n不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见\n\n环境隔离Nacos 提供了 namespace 来实现环境隔离功能。\n\nNacos 中可以有多个 namespace\nnamespace 下可以有 group、service 等\n不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见\n\n\n\n\n创建namespace默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)\n\n我们可以点击页面新增按钮，添加一个 namespace：\n\n然后，填写表单：\n\n就能在页面看到一个新的 namespace：\n\n配置namespace给微服务配置 namespace 只能通过修改配置来实现。\n例如，修改 order-service 的 application.yml 文件：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ\n        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID\n\n重启 order-service 后，访问控制台。\npublic\n\ndev\n\n此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：\n\n临时实例Nacos 的服务实例分为两种类型：\n\n临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。\n非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\nspring:\n  cloud:\n    nacos:\n      discovery:\n        ephemeral: false # 设置为非临时实例\n\n另外，Nacos 集群**默认采用AP方式(可用性)，当集群中存在非临时实例时，采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）\nNacos配置中心Nacos除了可以做注册中心，同样可以做配置管理来使用。\n当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\nNacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n创建配置在 Nacos 控制面板中添加配置文件\n\n然后在弹出的表单中，填写配置信息：\n\n注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。\n拉取配置首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：\n\n加入 Nacos 配置，它的读取是在 application.yml 之前的：\n\n这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，Nacos 就无法根据地址去获取配置了。\n因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。\n\n引入 nacos-config 依赖\n首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：\n&lt;!--nacos配置管理依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n添加 bootstrap.yml\n然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：\nspring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev \n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n\n根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;作为文件id，来读取配置。\n在这个例子例中，就是去读取 userservice-dev.yaml\n\n使用代码来验证是否拉取成功\n在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：\n@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)\nprivate String dateformat;\n\n@GetMapping(&quot;now&quot;)\npublic String now()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n&#125;\n\n\n启动服务后，访问：http://localhost:8081/user/now\n\n配置热更新我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。\n有两种方式：1. 用 @value 读取配置时，搭配 @RefreshScope；2. 直接用 @ConfigurationProperties 读取配置\n@RefreshScope方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope\n\n@ConfigurationProperties方式二：使用 @ConfigurationProperties 注解读取配置文件，就不需要加 @RefreshScope 注解。\n在 user-service 服务中，添加一个 PatternProperties 类，读取 patterrn.dateformat 属性\n@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)\npublic class PatternProperties &#123;\n    public String dateformat;\n&#125;\n\n@Autowired\nprivate PatternProperties patternProperties;\n\n@GetMapping(&quot;now2&quot;)\npublic String now2()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));\n&#125;\n\n配置共享其实在服务启动时，nacos 会读取多个配置文件，例如：\n\n[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml\n[spring.application.name].yaml，例如：userservice.yaml\n\n这里的 [spring.application.name].yaml 不包含环境，因此可以被多个环境共享。\n添加一个环境共享配置\n我们在 nacos 中添加一个 userservice.yaml 文件：\n\n在 user-service 中读取共享配置\n在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：\n\n在 user-service 服务中，修改 UserController，添加一个方法：\n\n运行两个 UserApplication，使用不同的profile\n修改 UserApplication2 这个启动项，改变其profile值：\n\n\n这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test\n启动 UserApplication 和 UserApplication2\n访问地址：http://localhost:8081/user/prop，结果：\n\n访问地址：http://localhost:8082/user/prop，结果：\n\n可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。\n上面的都是同一个微服务下，那么不同微服务之间可以环境共享吗？\n通过下面的两种方式来指定：\n\nextension-configs\nshared-configs\n\nspring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        extends-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id\n\nspring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        shared-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id\n\n配置优先级当 nacos、服务本地同时出现相同属性时，优先级有高低之分。\n\n更细致的配置\n\nNacos集群架构介绍\n其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。\n\n三个 Nacos 节点的地址\n\n\n\n节点\nip\nport\n\n\n\nnacos1\n192.168.150.1\n8845\n\n\nnacos2\n192.168.150.1\n8846\n\n\nnacos3\n192.168.150.1\n8847\n\n\n初始化数据库Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。\n首先新建一个数据库，命名为 nacos，而后导入下面的 SQL\nCREATE TABLE &#96;config_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) DEFAULT NULL,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  &#96;c_desc&#96; varchar(256) DEFAULT NULL,\n  &#96;c_use&#96; varchar(64) DEFAULT NULL,\n  &#96;effect&#96; varchar(64) DEFAULT NULL,\n  &#96;type&#96; varchar(64) DEFAULT NULL,\n  &#96;c_schema&#96; text,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_aggr&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_beta&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_tag&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_tags_relation&#96; (\n  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,\n  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,\n  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (&#96;nid&#96;),\n  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;group_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;his_config_info&#96; (\n  &#96;id&#96; bigint(64) unsigned NOT NULL,\n  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  &#96;data_id&#96; varchar(255) NOT NULL,\n  &#96;group_id&#96; varchar(128) NOT NULL,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL,\n  &#96;md5&#96; varchar(32) DEFAULT NULL,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;src_user&#96; text,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL,\n  &#96;op_type&#96; char(10) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;nid&#96;),\n  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),\n  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),\n  KEY &#96;idx_did&#96; (&#96;data_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;tenant_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;\n\n\nCREATE TABLE &#96;tenant_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,\n  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,\n  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,\n  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,\n  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;\n\nCREATE TABLE &#96;users&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,\n\t&#96;password&#96; varchar(500) NOT NULL,\n\t&#96;enabled&#96; boolean NOT NULL\n);\n\nCREATE TABLE &#96;roles&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL,\n\t&#96;role&#96; varchar(50) NOT NULL,\n\tUNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE\n);\n\nCREATE TABLE &#96;permissions&#96; (\n    &#96;role&#96; varchar(50) NOT NULL,\n    &#96;resource&#96; varchar(255) NOT NULL,\n    &#96;action&#96; varchar(8) NOT NULL,\n    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE\n);\n\nINSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);\n\nINSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);\n\n配置Nacos进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf\n\n添加内容\n127.0.0.1:8845\n127.0.0.1.8846\n127.0.0.1.8847\n\n然后修改 application.properties 文件，添加数据库配置\nspring.datasource.platform&#x3D;mysql\ndb.num&#x3D;1\ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC\ndb.user.0&#x3D;root\ndb.password.0&#x3D;123456\n\n\n\n将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\n\n然后分别修改三个文件夹中的 application.properties，\nnacos1\nserver.port&#x3D;8845\n\nnacos2\nserver.port&#x3D;8846\n\nnacos3\nserver.port&#x3D;8847\n\n然后分别启动三个 nacos\nstartup.cmd\n\nNginx反向代理修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下\nupstream nacos-cluster &#123;\n    server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n&#125;\n\nserver &#123;\n    listen       80;\n    server_name  localhost;\n\n    location &#x2F;nacos &#123;\n        proxy_pass http:&#x2F;&#x2F;nacos-cluster;\n    &#125;\n&#125;\n\n启动 nginx，在浏览器访问：http://localhost/nacos\n在代码中的 application.yml 文件配置改为如下：\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n\n实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。\nFeign远程调用我们以前利用 RestTemplate 发起远程调用的代码：\n\n\n代码可读性差，编程体验不统一\n参数复杂URL难以维护\n\nFeign 是一个声明式的 http 客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。\n\nFeign使用引入依赖\n我们在 order-service 引入 feign 依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n添加注解\n在 order-service 启动类添加注解开启 Feign\n\n请求接口\n在 order-service 中新建一个接口，内容如下\npackage cn.itcast.order.clients;\n\nimport cn.itcast.order.pojo.User;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(&quot;userservice&quot;)\npublic interface UserClient &#123;\n    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\n    User findById(@PathVariable(&quot;id&quot;) Long id);\n&#125;\n\n@FeignClient(&quot;userservice&quot;)：其中参数填写的是微服务名\n@GetMapping(&quot;/user/&#123;id&#125;&quot;)：其中参数填写的是请求路径\n这个客户端主要是基于 SpringMVC 的注解 @GetMapping 来声明远程调用的信息\nFeign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。\n测试\n@Autowired\nprivate UserClient userClient;\n\npublic Order queryOrderById(Long orderId) &#123;\n    &#x2F;&#x2F; 1.查询订单\n    Order order &#x3D; orderMapper.findById(orderId);\n    &#x2F;&#x2F; 2.用feign进行远程调用，替代之前的RestTemplate\n    User user &#x3D; userClient.findById(order.getUserId());\n    order.setUser(user);\n    &#x2F;&#x2F; 4.返回\n    return order;\n&#125;\n\n自定义配置Feign 可以支持很多的自定义配置，如下表所示：\n\n\n\n类型\n作用\n说明\n\n\n\nfeign.Logger.Level\n修改日志级别\n包含四种不同的级别：NONE、BASIC、HEADERS、FULL\n\n\nfeign.codec.Decoder\n响应结果的解析器\nhttp远程调用的结果做解析，例如解析json字符串为java对象\n\n\nfeign.codec.Encoder\n请求参数编码\n将请求参数编码，便于通过http请求发送\n\n\nfeign.Contract\n支持的注解格式\n默认是SpringMVC的注解\n\n\nfeign.Retryer\n失败重试机制\n请求失败的重试机制，默认是没有，不过会使用Ribbon的重试\n\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。\n基于配置文件修改 feign 的日志级别可以针对单个服务：\nfeign:  \n  client:\n    config: \n      userservice: # 针对某个微服务的配置\n        loggerLevel: FULL #  日志级别 \n\n也可以针对所有服务：\nfeign:  \n  client:\n    config: \n      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n        loggerLevel: FULL #  日志级别\n\n而日志的级别分为四种：\n\nNONE：不记录任何日志信息，这是默认值。\nBASIC：仅记录请求的方法，URL以及响应状态码和执行时间\nHEADERS：在BASIC的基础上，额外记录了请求和响应的头信息\nFULL：记录所有请求和响应的明细，包括头信息、请求体、元数据\n\n也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象\npublic class DefaultFeignConfiguration  &#123;\n    @Bean\n    public Logger.Level feignLogLevel()&#123;\n        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC\n    &#125;\n&#125;\n\n如果要全局生效，将其放到启动类的 @EnableFeignClients 这个注解中：\n@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) \n\n如果是局部生效，则把它放到对应的 @FeignClient 这个注解中：\n@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) \n\n性能优化Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：\n\nURLConnection：默认实现，不支持连接池\nApache HttpClient ：支持连接池\nOKHttp：支持连接池\n\n因此提高 Feign 性能的主要手段就是使用连接池代替默认的 URLConnection\n另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。\n这里我们用 Apache 的HttpClient来演示连接池。\n在 order-service 的 pom 文件中引入 HttpClient 依赖\n&lt;!--httpClient的依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n配置连接池\n在 order-service 的 application.yml 中添加配置\nfeign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n\n在 FeignClientFactoryBean 中的 loadBalance 方法中打断点\n\nDebug 方式启动 order-service  服务，可以看到这里的 client，底层就是 HttpClient\n\n最佳实践继承方式一样的代码可以通过继承来共享：\n1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明\n2）Feign 客户端、Controller 都集成该接口\n\n优点\n\n简单\n实现了代码共享\n\n缺点\n\n服务提供方、服务消费方紧耦合\n参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解\n\n抽取方式将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。\n例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。\n\n接下来我们就用该方法在代码中实现\n首先创建一个 module，命名为 feign-api\n\n在 feign-api 中然后引入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\norder-service中 的 UserClient、User 都复制到 feign-api 项目中\n\n接下来在 order-service 中使用 feign-api\n由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service  中引入 feign-api\n&lt;dependency&gt;\n    &lt;groupId&gt;com.xn2001.feign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n修改注解\n当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。\n修改 order-service 启动类上的 @EnableFeignClients 注解\n@EnableFeignClients(basePackages &#x3D; &quot;com.xn2001.feign.clients&quot;)\n\nGateway网关\n\n\n\n\n\n\n\n\n代码参考：\nGitee：https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway\nGitHub：https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway\nSpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring  Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API  路由管理方式。\nGateway 网关是我们服务的守门神，所有微服务的统一入口。\n网关的核心功能特性：\n\n请求路由\n权限控制\n限流\n\n\n权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n在 SpringCloud 中网关的实现包括两种：\n\ngateway\nzuul\n\nZuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。\n入门使用\n创建 SpringBoot 工程 gateway，引入网关依赖\n编写启动类\n编写基础配置和路由规则\n启动网关服务进行测试\n\n&lt;!--网关--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--nacos服务发现依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n创建 application.yml 文件，内容如下：\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求\n\n我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。\n上面的例子中，我们将 /user/** 开头的请求，代理到 lb://userservice，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。\n重启网关，访问 http://localhost:10010/user/1 时，符合 /user/** 规则，请求转发到 uri：http://userservice/user/1\n\n多个 predicates 的话，要同时满足规则，下文有例子。\n流程图\n路由配置包括：\n\n路由id：路由的唯一标示\n路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡\n路由断言（predicates）：判断路由的规则\n路由过滤器（filters）：对请求或响应做处理\n\n断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。\n例如 Path=/user/** 是按照路径匹配，这个规则是由\norg.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个\n\n\n\n名称\n说明\n示例\n\n\n\nAfter\n是某个时间点后的请求\n-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nBefore\n是某个时间点之前的请求\n-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n\nBetween\n是某两个时间点之前的请求\n-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nCookie\n请求必须包含某些cookie\n- Cookie&#x3D;chocolate, ch.p\n\n\nHeader\n请求必须包含某些header\n- Header&#x3D;X-Request-Id, \\d+\n\n\nHost\n请求必须是访问某个host（域名）\n-  Host&#x3D;**.somehost.org, **.anotherhost.org\n\n\nMethod\n请求方式必须是指定方式\n- Method&#x3D;GET,POST\n\n\nPath\n请求路径必须符合指定规则\n- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**\n\n\nQuery\n请求参数必须包含指定参数\n- Query&#x3D;name, Jack或者-  Query&#x3D;name\n\n\nRemoteAddr\n请求者的ip必须是指定范围\n- RemoteAddr&#x3D;192.168.1.1&#x2F;24\n\n\nWeight\n权重处理\n\n\n\n\n\n\n\n\n\n\n\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\n一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。\npredicates:\n  - Path&#x3D;&#x2F;order&#x2F;**\n  - After&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。\n过滤器工厂GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。\n\nSpring提供了31种不同的路由过滤器工厂。\n\n\n\n\n\n\n\n\n\n官方文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories\n\n\n\n名称\n说明\n\n\n\nAddRequestHeader\n给当前请求添加一个请求头\n\n\nRemoveRequestHeader\n移除请求中的一个请求头\n\n\nAddResponseHeader\n给响应结果中添加一个响应头\n\n\nRemoveResponseHeader\n从响应结果中移除有一个响应头\n\n\nRequestRateLimiter\n限制请求的流量\n\n\n下面我们以 AddRequestHeader 为例：\n\n需求：给所有进入 userservice 的请求添加一个请求头：sign=xn2001.com is eternal\n只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。\nspring:\n  cloud:\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求\n          filters:\n            - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头\n\n如何验证，我们修改 userservice 中的一个接口\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value &#x3D; &quot;sign&quot;, required &#x3D; false) String sign) &#123;\n    log.warn(sign);\n    return userService.queryById(id);\n&#125;\n\n重启两个服务，访问：http://localhost:10010/user/1\n可以看到控制台打印出了这个请求头\n\n当然，Gateway 也是有全局过滤器的，如果要对所有的路由都生效，则可以将过滤器工厂写到 default-filters 下：\nspring:\n  cloud:\n    gateway:\n      default-filters:\n        - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头\n\n全局过滤器上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GlobalFilter 的逻辑可以写代码来自定义规则；而 GatewayFilter 通过配置定义，处理逻辑是固定的。\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件\n\n参数中是否有 authorization\nauthorization 参数值是否为 admin\n\n如果同时满足则放行，否则拦截。\n@Component\npublic class AuthorizeFilter implements GlobalFilter, Ordered &#123;\n\n    &#x2F;&#x2F; 测试：http:&#x2F;&#x2F;localhost:10010&#x2F;order&#x2F;101?authorization&#x3D;admin\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;\n        &#x2F;&#x2F; 获取第一个 authorization 参数\n        String authorization &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;authorization&quot;);\n        if (&quot;admin&quot;.equals(authorization))&#123;\n            &#x2F;&#x2F; 放行\n            return chain.filter(exchange);\n        &#125;\n        &#x2F;&#x2F; 设置拦截状态码信息\n        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n        &#x2F;&#x2F; 设置拦截\n        return exchange.getResponse().setComplete();\n    &#125;\n\n    &#x2F;&#x2F; 设置过滤器优先级，值越低优先级越高\n    &#x2F;&#x2F; 也可以使用 @Order 注解\n    @Override\n    public int getOrder() &#123;\n        return 0;\n    &#125;\n&#125;\n\n过滤器顺序请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；\n请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.\n\n排序的规则是什么呢？\n\n每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。\nGlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。\n路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。\n当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。\n\n跨域问题不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。\nspring:\n  cloud:\n    gateway:\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          &#39;[&#x2F;**]&#39;:\n            allowedOrigins: # 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站\n              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - &quot;GET&quot;\n              - &quot;POST&quot;\n              - &quot;DELETE&quot;\n              - &quot;PUT&quot;\n              - &quot;OPTIONS&quot;\n            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n","slug":"学习笔记/SpringCloud","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"Java框架","author_index":"Aurora"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"计网\n","slug":"学习笔记/计网","date":"2022-12-05T08:00:50.000Z","categories_index":"","tags_index":"计算机基础","author_index":"Aurora"}]