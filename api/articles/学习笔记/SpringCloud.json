{"title":"SpringCloud","uid":"2fdfe1e1ace8a4912a23a4cbc1c92824","slug":"学习笔记/SpringCloud","date":"2022-12-05T08:00:50.000Z","updated":"2023-02-11T08:04:28.218Z","comments":true,"path":"api/articles/学习笔记/SpringCloud.json","keywords":null,"cover":"https://img0.baidu.com/it/u=1943652969,3627755974&fm=253&fmt=auto?w=889&h=500","content":"<h4 id=\"微服务技术栈\"><a href=\"#微服务技术栈\" class=\"headerlink\" title=\"微服务技术栈\"></a>微服务技术栈</h4><p>🤤基础篇</p>\n<ul>\n<li>认识微服务</li>\n<li>服务拆分</li>\n<li>远程调用</li>\n<li>Eureka</li>\n<li>Ribbon</li>\n<li>Nacos</li>\n<li>Feign</li>\n<li>Gateway</li>\n<li>RabbitMQ</li>\n<li>Elasticsearch</li>\n</ul>\n<p>💻高级篇</p>\n<ul>\n<li>JMeter</li>\n<li>Sentinel</li>\n<li>Seata</li>\n<li>Redis</li>\n<li>。。。</li>\n</ul>\n<h4 id=\"认识微服务\"><a href=\"#认识微服务\" class=\"headerlink\" title=\"认识微服务\"></a>认识微服务</h4><h5 id=\"单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署\"><a href=\"#单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署\" class=\"headerlink\" title=\"单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署\"></a>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署</h5><p><img src=\"https://cdn.xn2001.com/img/2021/20210901083809.png\" alt=\"img\"></p>\n<p>优点：架构简单，部署成本较低</p>\n<p>缺点：耦合度高（维护困难、升级困难）</p>\n<h5 id=\"分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务\"><a href=\"#分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务\" class=\"headerlink\" title=\"分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务\"></a>分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务</h5><p><img src=\"https://cdn.xn2001.com/img/2021/20210901092921.png\" alt=\"img\"></p>\n<p>优点：降低服务耦合，有利于服务升级和拓展</p>\n<p>缺点：调用服务关系错综复杂</p>\n<p>分布式架构虽然降低了服务耦合，但是服务拆分时也会有很多问题需要思考：</p>\n<ul>\n<li>服务拆分的粒度如何界定？</li>\n<li>服务之间如何调用？</li>\n<li>服务的调用关系如何管理？</li>\n</ul>\n<p>所以需要一套行之有效的标准来约束分布式架构</p>\n<h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4><p>微服务的架构特征：</p>\n<ul>\n<li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</p>\n</li>\n<li><p>自治：团队独立、技术独立、数据独立，独立部署和交付</p>\n</li>\n<li><p>面向服务：服务提供统一标准的接口，与语言和技术无关</p>\n</li>\n<li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p>\n<p><img src=\"https://cdn.xn2001.com/img/2022/202205162352847.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>微服务的上述特征其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>\n<h5 id=\"因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法\"><a href=\"#因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法\" class=\"headerlink\" title=\"因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法\"></a>因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法</h5><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了</p>\n<h2 id=\"SpringCloud\"><a href=\"#SpringCloud\" class=\"headerlink\" title=\"SpringCloud\"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href=\"https://spring.io/projects/spring-cloud%E3%80%82\">https://spring.io/projects/spring-cloud。</a></p>\n<p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>\n<p>其中常见的组件包括：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901083717.png\" alt=\"img\"></p>\n<p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901084050.png\" alt=\"img\"></p>\n<h4 id=\"内容知识\"><a href=\"#内容知识\" class=\"headerlink\" title=\"内容知识\"></a>内容知识</h4><p><img src=\"https://cdn.xn2001.com/img/2021/20210901092925.png\" alt=\"需要学习的微服务知识内容\"></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901084131.png\" alt=\"技术栈\"></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901090737.png\" alt=\"自动化部署\"></p>\n<h4 id=\"技术栈对比\"><a href=\"#技术栈对比\" class=\"headerlink\" title=\"技术栈对比\"></a>技术栈对比</h4><p><img src=\"https://cdn.xn2001.com/img/2021/20210901090726.png\" alt=\"img\"></p>\n<h4 id=\"服务拆分：\"><a href=\"#服务拆分：\" class=\"headerlink\" title=\"服务拆分：\"></a>服务拆分：</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">代码参考：\nGitee：https:&#x2F;&#x2F;gitee.com&#x2F;xn2001&#x2F;cloudcode&#x2F;tree&#x2F;master&#x2F;01-cloud-demo</code></pre>\n\n<p><strong>服务拆分注意事项</strong></p>\n<p>单一职责：不同微服务，不要重复开发相同业务</p>\n<p>数据独立：不要访问其它微服务的数据库</p>\n<p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901090745.png\" alt=\"img\"></p>\n<p>cloud-demo：父工程，管理依赖</p>\n<ul>\n<li>order-service：订单微服务，负责订单相关业务</li>\n<li>user-service：用户微服务，负责用户相关业务</li>\n</ul>\n<p>要求：</p>\n<ul>\n<li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li>\n<li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li>\n<li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li>\n</ul>\n<p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615132840054.png\" alt=\"image-20220615132840054\"></p>\n<p>启动完成后，访问 <a href=\"http://localhost:8080/order/101\">http://localhost:8080/order/101</a></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901090757.png\" alt=\"img\"></p>\n<h4 id=\"远程调用\"><a href=\"#远程调用\" class=\"headerlink\" title=\"远程调用\"></a>远程调用</h4><p>正如上面的服务拆分要求中所提到，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">订单服务如果需要查询用户信息，**只能调用用户服务的 Restful 接口**，不能查询用户数据库</code></pre>\n\n<p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615133219788.png\" alt=\"image-20220615133219788\"></p>\n<p>发送请求，自动序列化为 Java 对象。</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615133314248.png\" alt=\"image-20220615133314248\"></p>\n<p>启动完成后，访问：<a href=\"http://localhost:8080/order/101\">http://localhost:8080/order/101</a></p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615132930294.png\" alt=\"image-20220615132930294\"></p>\n<p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p>\n<h1 id=\"Eureka注册中心\"><a href=\"#Eureka注册中心\" class=\"headerlink\" title=\"Eureka注册中心\"></a>Eureka注册中心</h1><p>服务调用关系</p>\n<ul>\n<li>服务提供者：暴露接口给其它微服务调用</li>\n<li>服务消费者：调用其它微服务提供的接口</li>\n</ul>\n<p>服务调用中可能出现的问题</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615134720536.png\" alt=\"image-20220615134720536\"></p>\n<h4 id=\"Eureka的作用：\"><a href=\"#Eureka的作用：\" class=\"headerlink\" title=\"Eureka的作用：\"></a>Eureka的作用：</h4><p>提供一个注册中心，将所有的服务进行注册，需要时动态调用，每30秒检测一次服务是否正常</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901090919.png\" alt=\"img\"></p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901090919.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901090919.png\" alt=\"img\"></a></p>\n<p><strong>order-service 如何得知 user-service 实例地址？</strong></p>\n<ul>\n<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li>\n<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>\n<li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li>\n</ul>\n<p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p>\n<p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p>\n<p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p>\n<ul>\n<li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li>\n<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>\n<li>order-service 拉取服务时，就能将故障实例排除了</li>\n</ul>\n<p>接下来我们动手实践的步骤包括</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901090932.png\" alt=\"img\"></p>\n<h2 id=\"搭建注册中心\"><a href=\"#搭建注册中心\" class=\"headerlink\" title=\"搭建注册中心\"></a>搭建注册中心</h2><p>搭建 eureka-server</p>\n<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>编写启动类</strong></p>\n<p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(EurekaApplication.class,args);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>编写配置文件</strong></p>\n<p>编写一个 application.yml 文件，内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n  port: 10086\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url:\n      defaultZone: http:&#x2F;&#x2F;127.0.0.1:10086&#x2F;eureka</code></pre>\n\n<p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p>\n<p>启动完成后，访问 <a href=\"http://localhost:10086/\">http://localhost:10086/</a></p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615144833798.png\" alt=\"image-20220615144833798\"></p>\n<p>到这 服务注册中心就搭建完成了</p>\n<p>服务注册</p>\n<pre><code>将 user-service、order-service 都注册到 eureka\n</code></pre>\n<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 client</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在启动类上添加注解：@EnableEurekaClient</code></pre>\n\n<p>在 application.yml 文件，添加下面的配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  application:\n      #name：orderservice\n    name: userservice\neureka:\n  client:\n    service-url: \n      defaultZone: http:127.0.0.1:10086&#x2F;eureka</code></pre>\n\n<p>3个项目启动后，访问 <a href=\"http://localhost:10086/\">http://localhost:10086/</a></p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615151100786.png\" alt=\"image-20220615151100786\"></p>\n<p>可以看到eureka本身和另外两个服务都注册成功</p>\n<p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091005.png\" alt=\"img\"></p>\n<p>4个项目启动后，访问 <a href=\"http://localhost:10086/\">http://localhost:10086/</a></p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615151554375.png\"></p>\n<h5 id=\"服务拉取\"><a href=\"#服务拉取\" class=\"headerlink\" title=\"服务拉取\"></a>服务拉取</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</code></pre>\n\n<p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>\n<p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\n@LoadBalanced\npublic RestTemplate restTemplate()&#123;\n    return new RestTemplate();\n&#125;</code></pre>\n\n<p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615175754571.png\" alt=\"image-20220615175754571\"></p>\n<p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p>\n<h1 id=\"Ribbon负载均衡\"><a href=\"#Ribbon负载均衡\" class=\"headerlink\" title=\"Ribbon负载均衡\"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p>\n<h5 id=\"SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。\"><a href=\"#SpringCloud-底层提供了一个名为-Ribbon-的组件，来实现负载均衡功能。\" class=\"headerlink\" title=\"SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。\"></a>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</h5><p><img src=\"https://cdn.xn2001.com/img/2021/20210901091242.png\" alt=\"img\"></p>\n<h2 id=\"源码跟踪\"><a href=\"#源码跟踪\" class=\"headerlink\" title=\"源码跟踪\"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>\n<p>进入源码跟踪查看底层原理：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091323.png\" alt=\"img\"></p>\n<p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>\n<ul>\n<li><code>request.getURI()</code>：获取请求uri，即 <a href=\"http://user-service/user/8\">http://user-service/user/8</a></li>\n<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li>\n<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li>\n</ul>\n<p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p>\n<p>继续跟入 <code>execute()</code> 方法：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091330.png\" alt=\"img\"></p>\n<ul>\n<li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li>\n<li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li>\n</ul>\n<p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091345.png\" alt=\"img\"></p>\n<p>我们继续跟入：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091355.png\" alt=\"img\"></p>\n<p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091414.png\" alt=\"img\"></p>\n<p>我们看看这个 <code>rule</code> 是谁：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091432.png\" alt=\"img\"></p>\n<p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091442.png\" alt=\"img\"></p>\n<h2 id=\"流程总结\"><a href=\"#流程总结\" class=\"headerlink\" title=\"流程总结\"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p>\n<p>基本流程如下：</p>\n<ul>\n<li>拦截我们的 <code>RestTemplate</code> 请求 <a href=\"http://userservice/user/1\">http://userservice/user/1</a></li>\n<li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li>\n<li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li>\n<li>eureka 返回列表，localhost:8081、localhost:8082</li>\n<li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>\n<li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href=\"http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82\">http://localhost:8081/user/1，发起真实请求</a></li>\n</ul>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091755.png\" alt=\"img\"></p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901091755.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901091755.png\" alt=\"img\"></a></p>\n<h2 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091811.png\" alt=\"img\"></p>\n<p>不同规则的含义如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>内置负载均衡规则类</strong></th>\n<th align=\"left\"><strong>规则描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">RoundRobinRule</td>\n<td align=\"left\">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>\n</tr>\n<tr>\n<td align=\"left\">AvailabilityFilteringRule</td>\n<td align=\"left\">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule  规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td>\n</tr>\n<tr>\n<td align=\"left\">WeightedResponseTimeRule</td>\n<td align=\"left\">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>ZoneAvoidanceRule</strong></td>\n<td align=\"left\">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>\n</tr>\n<tr>\n<td align=\"left\">BestAvailableRule</td>\n<td align=\"left\">忽略那些短路的服务器，并选择并发数较低的服务器。</td>\n</tr>\n<tr>\n<td align=\"left\">RandomRule</td>\n<td align=\"left\">随机选择一个可用的服务器。</td>\n</tr>\n<tr>\n<td align=\"left\">RetryRule</td>\n<td align=\"left\">重试机制的选择逻辑</td>\n</tr>\n</tbody></table>\n<p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p>\n<h2 id=\"自定义策略\"><a href=\"#自定义策略\" class=\"headerlink\" title=\"自定义策略\"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p>\n<p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220615193912474.png\" alt=\"image-20220615193912474\"></p>\n<p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">userservice: # 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre>\n\n<p><strong>注意</strong>：一般情况下都采用默认的负载均衡规则，不做修改。</p>\n<h2 id=\"饥饿加载\"><a href=\"#饥饿加载\" class=\"headerlink\" title=\"饥饿加载\"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091850.png\" alt=\"img\"></p>\n<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p>\n<p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">ribbon:\n  eager-load:\n    enabled: true\n    clients: \n    \t-userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;-&quot;隔开</code></pre>\n\n<h1 id=\"Nacos注册中心\"><a href=\"#Nacos注册中心\" class=\"headerlink\" title=\"Nacos注册中心\"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，功能相对eureka会有提升</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091857.png\" alt=\"img\"></p>\n<p>解压启动 Nacos，详细请看 安装指南</p>\n<p>由于nacos默认采用集群启动， 所以需要使用如下命令进行单机启动</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">startup.cmd -m standalone</code></pre>\n\n<p>访问：<a href=\"http://localhost:8848/nacos/\">http://localhost:8848/nacos/</a> 就可以看到nocas管理界面了</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091904.png\" alt=\"img\"></p>\n<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。<strong>引入依赖</strong></p>\n<p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p>\n<p>如果之前引入过eureka的依赖，需要注释掉~</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.6.RELEASE&lt;&#x2F;version&gt;\n    &lt;type&gt;pom&lt;&#x2F;type&gt;\n    &lt;scope&gt;import&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>配置nacos地址</strong></p>\n<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: 127.0.0.1:8848</code></pre>\n\n<p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091918.png\" alt=\"img\"></p>\n<p>浏览器访问：<a href=\"http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82\">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p>\n<h2 id=\"分级存储模型\"><a href=\"#分级存储模型\" class=\"headerlink\" title=\"分级存储模型\"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>\n<ul>\n<li>127.0.0.1:8081</li>\n<li>127.0.0.1:8082</li>\n<li>127.0.0.1:8083</li>\n</ul>\n<p>假如这些实例分布于全国各地的不同机房，例如：</p>\n<ul>\n<li>127.0.0.1:8081，在上海机房</li>\n<li>127.0.0.1:8082，在上海机房</li>\n<li>127.0.0.1:8083，在杭州机房</li>\n</ul>\n<p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091928.png\" alt=\"img\"></p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901091928.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901091928.png\" alt=\"img\"></a></p>\n<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091937.png\" alt=\"img\"></p>\n<h2 id=\"配置集群\"><a href=\"#配置集群\" class=\"headerlink\" title=\"配置集群\"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p>\n<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称 HZ杭州</code></pre>\n\n<p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH</code></pre>\n\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091947.png\" alt=\"img\"></p>\n<p>查看 nacos 控制台</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901091957.png\" alt=\"img\"></p>\n<h2 id=\"NacosRule\"><a href=\"#NacosRule\" class=\"headerlink\" title=\"NacosRule\"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npublic IRule iRule()&#123;\n    &#x2F;&#x2F;默认为轮询规则，这里自定义为随机规则\n    return new NacosRule();\n&#125;</code></pre>\n\n<p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">userservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则</code></pre>\n\n<p>然后，再对 orderservice 配置集群。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称</code></pre>\n\n<p>现在我启动了四个服务，分别是：</p>\n<ul>\n<li>orderservice - HZ</li>\n<li>userservice - HZ</li>\n<li>userservice1 - HZ</li>\n<li>userservice2 - SH</li>\n</ul>\n<p>访问地址：<a href=\"http://localhost:8080/order/101\">http://localhost:8080/order/101</a></p>\n<p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p>\n<p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p>\n<p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092012.png\" alt=\"img\"></p>\n<h2 id=\"权重配置\"><a href=\"#权重配置\" class=\"headerlink\" title=\"权重配置\"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p>\n<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p>\n<p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p>\n<p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092020.png\" alt=\"img\"></p>\n<p>在弹出的编辑窗口，修改权重</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092026.png\" alt=\"img\"></p>\n<p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到  0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p>\n<h2 id=\"环境隔离\"><a href=\"#环境隔离\" class=\"headerlink\" title=\"环境隔离\"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p>\n<ul>\n<li><p>Nacos 中可以有多个 namespace</p>\n</li>\n<li><p>namespace 下可以有 group、service 等</p>\n</li>\n<li><p>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</p>\n</li>\n<li><h2 id=\"环境隔离-1\"><a href=\"#环境隔离-1\" class=\"headerlink\" title=\"环境隔离\"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p>\n<ul>\n<li>Nacos 中可以有多个 namespace</li>\n<li>namespace 下可以有 group、service 等</li>\n<li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092032.png\" alt=\"img\"></p>\n<h3 id=\"创建namespace\"><a href=\"#创建namespace\" class=\"headerlink\" title=\"创建namespace\"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092038.png\" alt=\"img\"></p>\n<p>我们可以点击页面新增按钮，添加一个 namespace：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092050.png\" alt=\"img\"></p>\n<p>然后，填写表单：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092059.png\" alt=\"img\"></p>\n<p>就能在页面看到一个新的 namespace：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092114.png\" alt=\"img\"></p>\n<h3 id=\"配置namespace\"><a href=\"#配置namespace\" class=\"headerlink\" title=\"配置namespace\"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p>\n<p>例如，修改 order-service 的 application.yml 文件：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ\n        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间ID</code></pre>\n\n<p>重启 order-service 后，访问控制台。</p>\n<p><strong>public</strong></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092143.png\" alt=\"img\"></p>\n<p><strong>dev</strong></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092130.png\" alt=\"img\"></p>\n<p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092138.png\" alt=\"img\"></p>\n<h2 id=\"临时实例\"><a href=\"#临时实例\" class=\"headerlink\" title=\"临时实例\"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p>\n<ul>\n<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li>\n<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>\n</ul>\n<p>配置一个服务实例为永久实例：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      discovery:\n        ephemeral: false # 设置为非临时实例</code></pre>\n\n<p>另外，Nacos 集群**默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p>\n<h1 id=\"Nacos配置中心\"><a href=\"#Nacos配置中心\" class=\"headerlink\" title=\"Nacos配置中心\"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>\n<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092150.png\" alt=\"img\"></p>\n<p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p>\n<h2 id=\"创建配置\"><a href=\"#创建配置\" class=\"headerlink\" title=\"创建配置\"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092159.png\" alt=\"img\"></p>\n<p>然后在弹出的表单中，填写配置信息：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092206.png\" alt=\"img\"></p>\n<p><strong>注意</strong>：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。</p>\n<h2 id=\"拉取配置\"><a href=\"#拉取配置\" class=\"headerlink\" title=\"拉取配置\"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092215.png\" alt=\"img\"></p>\n<p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092223.png\" alt=\"img\"></p>\n<p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p>\n<p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092228.png\" alt=\"img\"></p>\n<p><strong>引入 nacos-config 依赖</strong></p>\n<p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--nacos配置管理依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>添加 bootstrap.yml</strong></p>\n<p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev \n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名</code></pre>\n\n<p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>\n<p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092237.png\" alt=\"img\"></p>\n<p>使用代码来验证是否拉取成功</p>\n<p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)\nprivate String dateformat;\n\n@GetMapping(&quot;now&quot;)\npublic String now()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n&#125;</code></pre>\n\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092243.png\" alt=\"img\"></p>\n<p>启动服务后，访问：<a href=\"http://localhost:8081/user/now\">http://localhost:8081/user/now</a></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092251.png\" alt=\"img\"></p>\n<h2 id=\"配置热更新\"><a href=\"#配置热更新\" class=\"headerlink\" title=\"配置热更新\"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>\n<p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p>\n<h3 id=\"RefreshScope\"><a href=\"#RefreshScope\" class=\"headerlink\" title=\"@RefreshScope\"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092258.png\" alt=\"img\"></p>\n<h3 id=\"ConfigurationProperties\"><a href=\"#ConfigurationProperties\" class=\"headerlink\" title=\"@ConfigurationProperties\"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p>\n<p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)\npublic class PatternProperties &#123;\n    public String dateformat;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate PatternProperties patternProperties;\n\n@GetMapping(&quot;now2&quot;)\npublic String now2()&#123;\n    &#x2F;&#x2F;格式化时间\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));\n&#125;</code></pre>\n\n<h2 id=\"配置共享\"><a href=\"#配置共享\" class=\"headerlink\" title=\"配置共享\"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p>\n<ul>\n<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>\n<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>\n</ul>\n<p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p>\n<p><strong>添加一个环境共享配置</strong></p>\n<p>我们在 nacos 中添加一个 userservice.yaml 文件：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092323.png\" alt=\"img\"></p>\n<p><strong>在 user-service 中读取共享配置</strong></p>\n<p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092314.png\" alt=\"img\"></p>\n<p>在 user-service 服务中，修改 UserController，添加一个方法：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092331.png\" alt=\"img\"></p>\n<p><strong>运行两个 UserApplication，使用不同的profile</strong></p>\n<p>修改 UserApplication2 这个启动项，改变其profile值：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092345.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092338.png\" alt=\"img\"></p>\n<p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p>\n<p>启动 UserApplication 和 UserApplication2</p>\n<p>访问地址：<a href=\"http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A\">http://localhost:8081/user/prop，结果：</a></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092400.png\" alt=\"img\"></p>\n<p>访问地址：<a href=\"http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A\">http://localhost:8082/user/prop，结果：</a></p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092419.png\" alt=\"img\"></p>\n<p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p>\n<p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p>\n<p>通过下面的两种方式来指定：</p>\n<ul>\n<li>extension-configs</li>\n<li>shared-configs</li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        extends-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id</code></pre>\n\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring: \n  cloud:\n    nacos:\n      config:\n        file-extension: yaml # 文件后缀名\n        shared-configs: # 多微服务间共享的配置列表\n          - dataId: common.yaml # 要共享的配置文件id</code></pre>\n\n<h2 id=\"配置优先级\"><a href=\"#配置优先级\" class=\"headerlink\" title=\"配置优先级\"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092501.png\" alt=\"img\"></p>\n<p>更细致的配置</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092520.png\" alt=\"img\"></p>\n<h1 id=\"Nacos集群\"><a href=\"#Nacos集群\" class=\"headerlink\" title=\"Nacos集群\"></a>Nacos集群</h1><h2 id=\"架构介绍\"><a href=\"#架构介绍\" class=\"headerlink\" title=\"架构介绍\"></a>架构介绍</h2><p><img src=\"https://cdn.xn2001.com/img/2021/202108181959897.png\" alt=\"img\"></p>\n<p>其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/202108182000220.png\" alt=\"img\"></p>\n<p>三个 Nacos 节点的地址</p>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>ip</th>\n<th>port</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>nacos1</td>\n<td>192.168.150.1</td>\n<td>8845</td>\n</tr>\n<tr>\n<td>nacos2</td>\n<td>192.168.150.1</td>\n<td>8846</td>\n</tr>\n<tr>\n<td>nacos3</td>\n<td>192.168.150.1</td>\n<td>8847</td>\n</tr>\n</tbody></table>\n<h2 id=\"初始化数据库\"><a href=\"#初始化数据库\" class=\"headerlink\" title=\"初始化数据库\"></a>初始化数据库</h2><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。</p>\n<p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;config_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) DEFAULT NULL,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  &#96;c_desc&#96; varchar(256) DEFAULT NULL,\n  &#96;c_use&#96; varchar(64) DEFAULT NULL,\n  &#96;effect&#96; varchar(64) DEFAULT NULL,\n  &#96;type&#96; varchar(64) DEFAULT NULL,\n  &#96;c_schema&#96; text,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_aggr&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_beta&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_info_tag&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,\n  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  &#96;src_user&#96; text COMMENT &#39;source user&#39;,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;config_tags_relation&#96; (\n  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,\n  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,\n  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,\n  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (&#96;nid&#96;),\n  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;group_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;his_config_info&#96; (\n  &#96;id&#96; bigint(64) unsigned NOT NULL,\n  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  &#96;data_id&#96; varchar(255) NOT NULL,\n  &#96;group_id&#96; varchar(128) NOT NULL,\n  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,\n  &#96;content&#96; longtext NOT NULL,\n  &#96;md5&#96; varchar(32) DEFAULT NULL,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  &#96;src_user&#96; text,\n  &#96;src_ip&#96; varchar(50) DEFAULT NULL,\n  &#96;op_type&#96; char(10) DEFAULT NULL,\n  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,\n  PRIMARY KEY (&#96;nid&#96;),\n  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),\n  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),\n  KEY &#96;idx_did&#96; (&#96;data_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;\n\n\n&#x2F;******************************************&#x2F;\n&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;\n&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;\n&#x2F;******************************************&#x2F;\nCREATE TABLE &#96;tenant_capacity&#96; (\n  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,\n  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,\n  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,\n  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,\n  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,\n  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,\n  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,\n  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;\n\n\nCREATE TABLE &#96;tenant_info&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,\n  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,\n  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,\n  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,\n  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,\n  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,\n  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),\n  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;\n\nCREATE TABLE &#96;users&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,\n\t&#96;password&#96; varchar(500) NOT NULL,\n\t&#96;enabled&#96; boolean NOT NULL\n);\n\nCREATE TABLE &#96;roles&#96; (\n\t&#96;username&#96; varchar(50) NOT NULL,\n\t&#96;role&#96; varchar(50) NOT NULL,\n\tUNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE\n);\n\nCREATE TABLE &#96;permissions&#96; (\n    &#96;role&#96; varchar(50) NOT NULL,\n    &#96;resource&#96; varchar(255) NOT NULL,\n    &#96;action&#96; varchar(8) NOT NULL,\n    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE\n);\n\nINSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);\n\nINSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);</code></pre>\n\n<h2 id=\"配置Nacos\"><a href=\"#配置Nacos\" class=\"headerlink\" title=\"配置Nacos\"></a>配置Nacos</h2><p>进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/202108182004564.png\" alt=\"img\"></p>\n<p>添加内容</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">127.0.0.1:8845\n127.0.0.1.8846\n127.0.0.1.8847</code></pre>\n\n<p>然后修改 application.properties 文件，添加数据库配置</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">spring.datasource.platform&#x3D;mysql\ndb.num&#x3D;1\ndb.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC\ndb.user.0&#x3D;root\ndb.password.0&#x3D;123456</code></pre>\n\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"></code></pre>\n\n<p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/202108182004103.png\" alt=\"img\"></p>\n<p>然后分别修改三个文件夹中的 application.properties，</p>\n<p>nacos1</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">server.port&#x3D;8845</code></pre>\n\n<p>nacos2</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">server.port&#x3D;8846</code></pre>\n\n<p>nacos3</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">server.port&#x3D;8847</code></pre>\n\n<p>然后分别启动三个 nacos</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">startup.cmd</code></pre>\n\n<h2 id=\"Nginx反向代理\"><a href=\"#Nginx反向代理\" class=\"headerlink\" title=\"Nginx反向代理\"></a>Nginx反向代理</h2><p>修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下</p>\n<pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">upstream nacos-cluster &#123;\n    server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n&#125;\n\nserver &#123;\n    listen       80;\n    server_name  localhost;\n\n    location &#x2F;nacos &#123;\n        proxy_pass http:&#x2F;&#x2F;nacos-cluster;\n    &#125;\n&#125;</code></pre>\n\n<p>启动 nginx，在浏览器访问：<a href=\"http://localhost/nacos\">http://localhost/nacos</a></p>\n<p>在代码中的 application.yml 文件配置改为如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址</code></pre>\n\n<p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。</p>\n<h1 id=\"Feign远程调用\"><a href=\"#Feign远程调用\" class=\"headerlink\" title=\"Feign远程调用\"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092616.png\" alt=\"img\"></p>\n<ul>\n<li>代码可读性差，编程体验不统一</li>\n<li>参数复杂URL难以维护</li>\n</ul>\n<p>Feign 是一个声明式的 http 客户端，官方地址：<a href=\"https://github.com/OpenFeign/feign\">https://github.com/OpenFeign/feign</a></p>\n<p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092639.png\" alt=\"img\"></p>\n<h2 id=\"Feign使用\"><a href=\"#Feign使用\" class=\"headerlink\" title=\"Feign使用\"></a>Feign使用</h2><p><strong>引入依赖</strong></p>\n<p>我们在 order-service 引入 feign 依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>添加注解</strong></p>\n<p>在 order-service 启动类添加注解开启 Feign</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220710135442258.png\" alt=\"image-20220710135442258\"></p>\n<p><strong>请求接口</strong></p>\n<p>在 order-service 中新建一个接口，内容如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.order.clients;\n\nimport cn.itcast.order.pojo.User;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(&quot;userservice&quot;)\npublic interface UserClient &#123;\n    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\n    User findById(@PathVariable(&quot;id&quot;) Long id);\n&#125;</code></pre>\n\n<p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p>\n<p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p>\n<p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p>\n<p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Autowired\nprivate UserClient userClient;\n\npublic Order queryOrderById(Long orderId) &#123;\n    &#x2F;&#x2F; 1.查询订单\n    Order order &#x3D; orderMapper.findById(orderId);\n    &#x2F;&#x2F; 2.用feign进行远程调用，替代之前的RestTemplate\n    User user &#x3D; userClient.findById(order.getUserId());\n    order.setUser(user);\n    &#x2F;&#x2F; 4.返回\n    return order;\n&#125;</code></pre>\n\n<h2 id=\"自定义配置\"><a href=\"#自定义配置\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>feign.Logger.Level</strong></td>\n<td>修改日志级别</td>\n<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>\n</tr>\n<tr>\n<td>feign.codec.Decoder</td>\n<td>响应结果的解析器</td>\n<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>\n</tr>\n<tr>\n<td>feign.codec.Encoder</td>\n<td>请求参数编码</td>\n<td>将请求参数编码，便于通过http请求发送</td>\n</tr>\n<tr>\n<td>feign.Contract</td>\n<td>支持的注解格式</td>\n<td>默认是SpringMVC的注解</td>\n</tr>\n<tr>\n<td>feign.Retryer</td>\n<td>失败重试机制</td>\n<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>\n</tr>\n</tbody></table>\n<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p>\n<p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">feign:  \n  client:\n    config: \n      userservice: # 针对某个微服务的配置\n        loggerLevel: FULL #  日志级别 </code></pre>\n\n<p><strong>也可以针对所有服务</strong>：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">feign:  \n  client:\n    config: \n      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n        loggerLevel: FULL #  日志级别</code></pre>\n\n<p>而日志的级别分为四种：</p>\n<ul>\n<li>NONE：不记录任何日志信息，这是默认值。</li>\n<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>\n<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>\n<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li>\n</ul>\n<p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DefaultFeignConfiguration  &#123;\n    @Bean\n    public Logger.Level feignLogLevel()&#123;\n        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC\n    &#125;\n&#125;</code></pre>\n\n<p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) </code></pre>\n\n<p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) </code></pre>\n\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p>\n<ul>\n<li><strong>URLConnection</strong>：默认实现，不支持连接池</li>\n<li><strong>Apache HttpClient</strong> ：支持连接池</li>\n<li><strong>OKHttp</strong>：支持连接池</li>\n</ul>\n<p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p>\n<p>另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。</p>\n<p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p>\n<p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--httpClient的依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>配置连接池</strong></p>\n<p>在 order-service 的 application.yml 中添加配置</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">feign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数</code></pre>\n\n<p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p>\n<p><img src=\"C:\\Users\\63194\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220712153433953.png\" alt=\"image-20220712153433953\"></p>\n<p>Debug 方式启动 order-service  服务，可以看到这里的 client，底层就是 HttpClient</p>\n<p><img src=\"https://cdn.xn2001.com/img/2021/20210901092737.png\" alt=\"img\"></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p>\n<p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p>\n<p>2）Feign 客户端、Controller 都集成该接口</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901092803.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901092803.png\" alt=\"img\"></a></p>\n<p>优点</p>\n<ul>\n<li>简单</li>\n<li>实现了代码共享</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>服务提供方、服务消费方紧耦合</li>\n<li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li>\n</ul>\n<h3 id=\"抽取方式\"><a href=\"#抽取方式\" class=\"headerlink\" title=\"抽取方式\"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>\n<p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901092811.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901092811.png\" alt=\"img\"></a></p>\n<p>接下来我们就用该方法在代码中实现</p>\n<p><strong>首先创建一个 module，命名为 feign-api</strong></p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901092835.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901092835.png\" alt=\"img\"></a></p>\n<p>在 feign-api 中然后引入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>order-service中 的 UserClient、User 都复制到 feign-api 项目中</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901092848.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901092848.png\" alt=\"img\"></a></p>\n<p>接下来在 order-service 中使用 feign-api</p>\n<p>由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service  中引入 feign-api</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;com.xn2001.feign&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>修改注解</strong></p>\n<p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p>\n<p>修改 order-service 启动类上的 <code>@EnableFeignClients</code> 注解</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableFeignClients(basePackages &#x3D; &quot;com.xn2001.feign.clients&quot;)</code></pre>\n\n<h1 id=\"Gateway网关\"><a href=\"#Gateway网关\" class=\"headerlink\" title=\"Gateway网关\"></a>Gateway网关</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代码参考：</p>\n<p>Gitee：<a href=\"https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway\">https://gitee.com/xn2001/cloudcode/tree/master/07-cloud-gateway</a></p>\n<p>GitHub：<a href=\"https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway\">https://github.com/lexinhu/cloudcode/tree/master/07-cloud-gateway</a></p></blockquote>\n<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring  Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API  路由管理方式。</p>\n<p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p>\n<p>网关的<strong>核心功能特性</strong>：</p>\n<ul>\n<li>请求路由</li>\n<li>权限控制</li>\n<li>限流</li>\n</ul>\n<p><a href=\"https://cdn.xn2001.com/img/2021/20210901092857.png\"><img src=\"https://cdn.xn2001.com/img/2021/20210901092857.png\" alt=\"img\"></a></p>\n<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>\n<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>\n<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>\n<p>在 SpringCloud 中网关的实现包括两种：</p>\n<ul>\n<li>gateway</li>\n<li>zuul</li>\n</ul>\n<p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>\n<h2 id=\"入门使用\"><a href=\"#入门使用\" class=\"headerlink\" title=\"入门使用\"></a>入门使用</h2><ol>\n<li>创建 SpringBoot 工程 gateway，引入网关依赖</li>\n<li>编写启动类</li>\n<li>编写基础配置和路由规则</li>\n<li>启动网关服务进行测试</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--网关--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--nacos服务发现依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>创建 application.yml 文件，内容如下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求</code></pre>\n\n<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>\n<p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p>\n<p>重启网关，访问 <a href=\"http://localhost:10010/user/1\">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href=\"http://userservice/user/1\">http://userservice/user/1</a></p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/202108220125749.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108220125749.png\" alt=\"img\"></a></p>\n<p>多个 predicates 的话，要同时满足规则，下文有例子。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p><a href=\"https://cdn.xn2001.com/img/2021/202108220127419.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108220127419.png\" alt=\"img\"></a></p>\n<p>路由配置包括：</p>\n<ol>\n<li>路由id：路由的唯一标示</li>\n<li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li>\n<li>路由断言（predicates）：判断路由的规则</li>\n<li>路由过滤器（filters）：对请求或响应做处理</li>\n</ol>\n<h2 id=\"断言工厂\"><a href=\"#断言工厂\" class=\"headerlink\" title=\"断言工厂\"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p>\n<p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p>\n<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>After</td>\n<td>是某个时间点后的请求</td>\n<td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>\n</tr>\n<tr>\n<td>Before</td>\n<td>是某个时间点之前的请求</td>\n<td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td>\n</tr>\n<tr>\n<td>Between</td>\n<td>是某两个时间点之前的请求</td>\n<td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>请求必须包含某些cookie</td>\n<td>- Cookie&#x3D;chocolate, ch.p</td>\n</tr>\n<tr>\n<td>Header</td>\n<td>请求必须包含某些header</td>\n<td>- Header&#x3D;X-Request-Id, \\d+</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求必须是访问某个host（域名）</td>\n<td>-  Host&#x3D;<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td>\n</tr>\n<tr>\n<td>Method</td>\n<td>请求方式必须是指定方式</td>\n<td>- Method&#x3D;GET,POST</td>\n</tr>\n<tr>\n<td>Path</td>\n<td>请求路径必须符合指定规则</td>\n<td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>\n</tr>\n<tr>\n<td>Query</td>\n<td>请求参数必须包含指定参数</td>\n<td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td>\n</tr>\n<tr>\n<td>RemoteAddr</td>\n<td>请求者的ip必须是指定范围</td>\n<td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>\n</tr>\n<tr>\n<td>Weight</td>\n<td>权重处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>官方文档：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p></blockquote>\n<p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">predicates:\n  - Path&#x3D;&#x2F;order&#x2F;**\n  - After&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</code></pre>\n\n<p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p>\n<h2 id=\"过滤器工厂\"><a href=\"#过滤器工厂\" class=\"headerlink\" title=\"过滤器工厂\"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/202108220133487.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108220133487.png\" alt=\"img\"></a></p>\n<p>Spring提供了31种不同的路由过滤器工厂。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>官方文档：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories\">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p></blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AddRequestHeader</td>\n<td>给当前请求添加一个请求头</td>\n</tr>\n<tr>\n<td>RemoveRequestHeader</td>\n<td>移除请求中的一个请求头</td>\n</tr>\n<tr>\n<td>AddResponseHeader</td>\n<td>给响应结果中添加一个响应头</td>\n</tr>\n<tr>\n<td>RemoveResponseHeader</td>\n<td>从响应结果中移除有一个响应头</td>\n</tr>\n<tr>\n<td>RequestRateLimiter</td>\n<td>限制请求的流量</td>\n</tr>\n</tbody></table>\n<p>下面我们以 AddRequestHeader 为例：</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/202108220139913.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108220139913.png\" alt=\"img\"></a></p>\n<p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p>\n<p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求\n          filters:\n            - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre>\n\n<p>如何验证，我们修改 userservice 中的一个接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User queryById(@PathVariable(&quot;id&quot;) Long id, @RequestHeader(value &#x3D; &quot;sign&quot;, required &#x3D; false) String sign) &#123;\n    log.warn(sign);\n    return userService.queryById(id);\n&#125;</code></pre>\n\n<p>重启两个服务，访问：<a href=\"http://localhost:10010/user/1\">http://localhost:10010/user/1</a></p>\n<p>可以看到控制台打印出了这个请求头</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/202108220145565.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108220145565.png\" alt=\"img\"></a></p>\n<p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    gateway:\n      default-filters:\n        - AddRequestHeader&#x3D;sign, xn2001.com is eternal # 添加请求头</code></pre>\n\n<h2 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p>\n<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p>\n<p><strong>需求</strong>：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p>\n<ul>\n<li>参数中是否有 authorization</li>\n<li>authorization 参数值是否为 admin</li>\n</ul>\n<p>如果同时满足则放行，否则拦截。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class AuthorizeFilter implements GlobalFilter, Ordered &#123;\n\n    &#x2F;&#x2F; 测试：http:&#x2F;&#x2F;localhost:10010&#x2F;order&#x2F;101?authorization&#x3D;admin\n    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;\n        &#x2F;&#x2F; 获取第一个 authorization 参数\n        String authorization &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;authorization&quot;);\n        if (&quot;admin&quot;.equals(authorization))&#123;\n            &#x2F;&#x2F; 放行\n            return chain.filter(exchange);\n        &#125;\n        &#x2F;&#x2F; 设置拦截状态码信息\n        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n        &#x2F;&#x2F; 设置拦截\n        return exchange.getResponse().setComplete();\n    &#125;\n\n    &#x2F;&#x2F; 设置过滤器优先级，值越低优先级越高\n    &#x2F;&#x2F; 也可以使用 @Order 注解\n    @Override\n    public int getOrder() &#123;\n        return 0;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"过滤器顺序\"><a href=\"#过滤器顺序\" class=\"headerlink\" title=\"过滤器顺序\"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p>\n<p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p>\n<p><a href=\"https://cdn.xn2001.com/img/2021/202108230002747.png\"><img src=\"https://cdn.xn2001.com/img/2021/202108230002747.png\" alt=\"img\"></a></p>\n<p>排序的规则是什么呢？</p>\n<ul>\n<li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li>\n<li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li>\n<li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li>\n<li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>\n</ul>\n<h2 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  cloud:\n    gateway:\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          &#39;[&#x2F;**]&#39;:\n            allowedOrigins: # 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站\n              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - &quot;GET&quot;\n              - &quot;POST&quot;\n              - &quot;DELETE&quot;\n              - &quot;PUT&quot;\n              - &quot;OPTIONS&quot;\n            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期</code></pre>\n","text":"微服务技术栈🤤基础篇 认识微服务 服务拆分 远程调用 Eureka Ribbon Nacos Feign Gateway RabbitMQ Elasticsearch 💻高级篇 JMeter Sentinel Seata Redis 。。。 认识微服务单体架构：将业务的所有功能集...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[],"tags":[{"name":"Java框架","slug":"Java框架","count":8,"path":"api/tags/Java框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88\"><span class=\"toc-text\">微服务技术栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">认识微服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%B0%86%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8A%9F%E8%83%BD%E9%9B%86%E4%B8%AD%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%80%E5%8F%91%EF%BC%8C%E6%89%93%E6%88%90%E4%B8%80%E4%B8%AA%E5%8C%85%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%AF%B9%E7%B3%BB%E7%BB%9F%E5%81%9A%E6%8B%86%E5%88%86%EF%BC%8C%E6%AF%8F%E4%B8%AA%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%BA%E7%8B%AC%E7%AB%8B%E4%B8%80%E9%A1%B9%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%EF%BC%8C%E7%A7%B0%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立一项业务开发，称为一个服务</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">微服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A4%E4%B8%BA%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BB%8F%E8%BF%87%E8%89%AF%E5%A5%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">因此，可以认为是微服务是一种经过良好架构设计的分布式架构方法</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringCloud\"><span class=\"toc-text\">SpringCloud</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AE%B9%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">内容知识</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">技术栈对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%EF%BC%9A\"><span class=\"toc-text\">服务拆分：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">远程调用</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">Eureka注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Eureka%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">Eureka的作用：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%AD%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">搭建注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96\"><span class=\"toc-text\">服务拉取</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">Ribbon负载均衡</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#SpringCloud-%E5%BA%95%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA-Ribbon-%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8A%9F%E8%83%BD%E3%80%82\"><span class=\"toc-text\">SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">源码跟踪</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">流程总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">负载均衡策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">自定义策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">饥饿加载</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">Nacos注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">服务注册</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">分级存储模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">配置集群</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NacosRule\"><span class=\"toc-text\">NacosRule</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">权重配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">环境隔离</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB-1\"><span class=\"toc-text\">环境隔离</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BAnamespace\"><span class=\"toc-text\">创建namespace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AEnamespace\"><span class=\"toc-text\">配置namespace</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%B4%E6%97%B6%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">临时实例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">Nacos配置中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">创建配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%89%E5%8F%96%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">拉取配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">配置热更新</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RefreshScope\"><span class=\"toc-text\">@RefreshScope</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ConfigurationProperties\"><span class=\"toc-text\">@ConfigurationProperties</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">配置共享</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">配置优先级</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nacos%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">Nacos集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">架构介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">初始化数据库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AENacos\"><span class=\"toc-text\">配置Nacos</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">Nginx反向代理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">Feign远程调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Feign%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Feign使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">自定义配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">性能优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">继承方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E5%8F%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">抽取方式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Gateway%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">Gateway网关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">入门使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">流程图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">断言工厂</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">过滤器工厂</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">全局过滤器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">过滤器顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">跨域问题</span></a>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot","uid":"af912e0d33a827f03582ef107fe8a87d","slug":"学习笔记/SpringBoot2","date":"2022-12-05T08:00:50.000Z","updated":"2023-02-11T05:57:46.029Z","comments":true,"path":"api/articles/学习笔记/SpringBoot2.json","keywords":null,"cover":"https://img1.baidu.com/it/u=791538071,3889773917&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800","text":"SpringBoot2 ","link":"","photos":[],"count_time":{"symbolsCount":12,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java框架","slug":"Java框架","count":8,"path":"api/tags/Java框架.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SpringMVC","uid":"cd53cdbf97b8f99c953dd3eda45eed25","slug":"学习笔记/SpringMVC","date":"2022-12-05T08:00:50.000Z","updated":"2023-02-11T05:58:06.217Z","comments":true,"path":"api/articles/学习笔记/SpringMVC.json","keywords":null,"cover":"https://img1.baidu.com/it/u=68948553,1079424840&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800","text":"SpringMVC ","link":"","photos":[],"count_time":{"symbolsCount":10,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java框架","slug":"Java框架","count":8,"path":"api/tags/Java框架.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}