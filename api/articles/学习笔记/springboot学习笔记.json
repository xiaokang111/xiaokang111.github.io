{"title":"SpringBoot","uid":"af912e0d33a827f03582ef107fe8a87d","slug":"学习笔记/springboot学习笔记","date":"2022-12-05T08:00:50.000Z","updated":"2023-04-25T04:02:35.192Z","comments":true,"path":"api/articles/学习笔记/springboot学习笔记.json","keywords":null,"cover":"https://img1.baidu.com/it/u=791538071,3889773917&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800","content":"<h1 id=\"SpringBoot学习笔记\"><a href=\"#SpringBoot学习笔记\" class=\"headerlink\" title=\"SpringBoot学习笔记\"></a>SpringBoot学习笔记</h1><h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><p>官方文档：<a href=\"https://spring.io/projects/spring-boot\">https://spring.io/projects/spring-boot</a></p>\n<h3 id=\"什么是Spring\"><a href=\"#什么是Spring\" class=\"headerlink\" title=\"什么是Spring\"></a>什么是Spring</h3><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。</p>\n<p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p>\n<h3 id=\"Spring如何简化Java开发\"><a href=\"#Spring如何简化Java开发\" class=\"headerlink\" title=\"Spring如何简化Java开发\"></a>Spring如何简化Java开发</h3><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">基于POJO的轻量级和最小侵入性编程，所有东西都是bean；\n通过IOC，依赖注入（DI）和面向接口实现松耦合；\n基于切面（AOP）和惯例进行声明式编程；\n通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</code></pre>\n\n<h3 id=\"什么是SpringBoot\"><a href=\"#什么是SpringBoot\" class=\"headerlink\" title=\"什么是SpringBoot\"></a>什么是SpringBoot</h3><p>就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</code></pre>\n\n<p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>\n<h3 id=\"SpringBoot优点\"><a href=\"#SpringBoot优点\" class=\"headerlink\" title=\"SpringBoot优点\"></a>SpringBoot优点</h3><ul>\n<li>为所有Spring开发者更快的入门</li>\n<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n</ul>\n<h2 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h2><h3 id=\"什么是微服务\"><a href=\"#什么是微服务\" class=\"headerlink\" title=\"什么是微服务\"></a>什么是微服务</h3><p> 微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合；可以通过http的方式进行互通，要说微服务架构，先得说说过去的单体应用架构。</p>\n<h3 id=\"单体应用架构\"><a href=\"#单体应用架构\" class=\"headerlink\" title=\"单体应用架构\"></a>单体应用架构</h3><p> 所谓单体应用架构(all in one)是指，我们将一个应用中的所有应用服务都封装在一个应用中。 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问，等等各个功能放在一个war包内。</p>\n<ul>\n<li>这么做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需把war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。</li>\n<li>单体应用架构缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能把所有内容都放在一个应用里，我们如何维护、如何分工合作都是问题。</li>\n</ul>\n<h3 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h3><p> all in one 的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。</p>\n<p> 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制。</p>\n<p>这样做的好处 ：</p>\n<ul>\n<li>节省了调用资源</li>\n<li>每个功能元素的服务都是一个可替换的、可独立升级的软件代码。</li>\n</ul>\n<h3 id=\"如何构建微服务架构\"><a href=\"#如何构建微服务架构\" class=\"headerlink\" title=\"如何构建微服务架构\"></a>如何构建微服务架构</h3><p> 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。<br>​ 但是这种庞大的系统架构给部署和运维带来很大的难度。于是，spring为我们带来了构建大型分布式微服务的全套、全程产品:</p>\n<ul>\n<li>构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用</li>\n<li>大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式</li>\n<li>在分布式中间，进行流式数据计算、批处理，我们有spring cloud data flow。</li>\n<li>spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。</li>\n</ul>\n<h2 id=\"第一个SpringBoot项目\"><a href=\"#第一个SpringBoot项目\" class=\"headerlink\" title=\"第一个SpringBoot项目\"></a>第一个SpringBoot项目</h2><p>环境准备：</p>\n<ul>\n<li>jdk1.8</li>\n<li>Maven-3.6.3</li>\n<li>SpringBoot 2.7.8</li>\n</ul>\n<p>开发工具：</p>\n<ul>\n<li>IDEA</li>\n</ul>\n<p>Spring官方提供了非常方便的工具让我们快速构建应用</p>\n<p>Spring Initializr：<a href=\"https://start.spring.io/\">https://start.spring.io/</a></p>\n<h3 id=\"项目创建方式一\"><a href=\"#项目创建方式一\" class=\"headerlink\" title=\"项目创建方式一\"></a>项目创建方式一</h3><p><strong>使用Spring Initializr 的 Web页面创建项目</strong></p>\n<p>1、打开 <a href=\"https://start.spring.io/\">https://start.spring.io/</a></p>\n<p>2、填写项目信息</p>\n<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>\n<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>\n<p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p>\n<h3 id=\"项目创建方式二\"><a href=\"#项目创建方式二\" class=\"headerlink\" title=\"项目创建方式二\"></a>项目创建方式二</h3><p><strong>使用 IDEA 直接创建项目</strong></p>\n<p>1、创建一个新项目</p>\n<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>\n<p>3、填写项目信息</p>\n<p>4、选择初始化的组件（初学勾选 Web 即可）</p>\n<p>5、填写项目路径</p>\n<p>6、等待项目构建成功</p>\n<h3 id=\"pom-xml分析\"><a href=\"#pom-xml分析\" class=\"headerlink\" title=\"pom.xml分析\"></a>pom.xml分析</h3><p>打开pom.xml，看看Spring Boot项目的依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;!--有父项目--&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.7.8&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;groupId&gt;com.lc&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;helloworld&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;helloworld&lt;&#x2F;name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n    &lt;&#x2F;properties&gt;\n    &lt;dependencies&gt;\n        &lt;!--web依赖:tomcat,dispatcherServlet,xml--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!--spring-boot-start所有的springboot依赖都是使用这个开头--&gt;\n        &lt;!--单元测试--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n    &lt;build&gt;\n        &lt;!--打jar包插件--&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n<h3 id=\"编写http接口\"><a href=\"#编写http接口\" class=\"headerlink\" title=\"编写http接口\"></a>编写http接口</h3><p>在主程序的同级目录下，新建一个controller包，一定要在启动类同级目录下，否则识别不到</p>\n<p>在包中新建一个HelloController类 :</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.lc.helloworld.controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n&#x2F;&#x2F;自动装配\n@RestController\npublic class HelloController &#123;\n    &#x2F;&#x2F;接口：http:&#x2F;&#x2F;localhost:8080&#x2F;hello\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String hello()&#123;\n        &#x2F;&#x2F;调用业务，接收前端参数\n        return &quot;hello,World&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425115905804.png\" alt=\"image-20230425115905804\"></p>\n<p>这样一个web接口的开发就完成了</p>\n<h3 id=\"将项目打成jar包\"><a href=\"#将项目打成jar包\" class=\"headerlink\" title=\"将项目打成jar包\"></a>将项目打成jar包</h3><p>点击右侧Maven Projectc工具栏中的package 即可将项目打包成一个jar包，如果打包成功，则会在target目录下生成一个 jar 包，打成了jar包后，就可以在任何地方运行了！</p>\n<h3 id=\"更改项目端口号\"><a href=\"#更改项目端口号\" class=\"headerlink\" title=\"更改项目端口号\"></a>更改项目端口号</h3><p>在配置文件中修改server.port</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#更改项目端口号\nserver.port&#x3D;8081</code></pre>\n\n<h3 id=\"更改启动时banner图案\"><a href=\"#更改启动时banner图案\" class=\"headerlink\" title=\"更改启动时banner图案\"></a>更改启动时banner图案</h3><p>到项目下的 resources 目录下新建一个banner.txt 即可:</p>\n<p>图案可以到网站 <a href=\"https://www.bootschool.net/ascii\">https://www.bootschool.net/ascii</a> 生成，拷贝到文件中即可！</p>\n<h2 id=\"SpringBoot运行原理\"><a href=\"#SpringBoot运行原理\" class=\"headerlink\" title=\"SpringBoot运行原理\"></a>SpringBoot运行原理</h2><h3 id=\"父依赖\"><a href=\"#父依赖\" class=\"headerlink\" title=\"父依赖\"></a>父依赖</h3><p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;\n    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;&#x2F;parent&gt;</code></pre>\n\n<p>点进去，发现还有一个父依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;\n    &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;\n&lt;&#x2F;parent&gt;</code></pre>\n\n<p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>\n<p><strong>以后我们导入依赖默认是不需要写版本，因为有这些版本仓库；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>\n<h3 id=\"启动器-spring-boot-starter\"><a href=\"#启动器-spring-boot-starter\" class=\"headerlink\" title=\"启动器 spring-boot-starter\"></a>启动器 spring-boot-starter</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>\n<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>\n<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>\n<h3 id=\"主启动类\"><a href=\"#主启动类\" class=\"headerlink\" title=\"主启动类\"></a>主启动类</h3><p><strong>默认的主启动类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lc;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n&#x2F;&#x2F;@SpringBootApplication 来标注一个主程序类\n&#x2F;&#x2F;说明这是一个Spring Boot应用\n@SpringBootApplication\npublic class Springboot01HellowroldApplication &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;以为是启动了一个方法，没想到启动了一个服务\n        SpringApplication.run(Springboot01HellowroldApplication.class, args);\n    &#125;\n&#125;</code></pre>\n\n<p>注解：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@SpringBootApplication : 标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\t@@SpringBootConfiguration : Spring配置类，标注在某个类上，表示这是一个SpringBoot的配置类；\n\t@Configuration : 说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；\n\t@Component : 说明启动类本身也是Spring中的一个组件而已，负责启动应用！\n\t@ComponentScan : 这个注解在Spring中很重要 ,它对应XML配置中的元素，扫码当前主启动类同级的包。\n作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中\n\n@EnableAutoConfiguration : 开启自动配置功能\n\tAutoConfigurationPackage : 自动配置包\n\t@Import(&#123;Registrar.class&#125;) : 自动配置 ‘包组件’\n\t\tSpring底层注解@import ， 给容器中导入一个组件\n\t\tRegistrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器\n\t@Import(&#123;AutoConfigurationImportSelector.class&#125;) : 给容器导入组件\nAutoConfigurationImportSelector ：自动配置导入选择器</code></pre>\n\n<h3 id=\"spring-factories\"><a href=\"#spring-factories\" class=\"headerlink\" title=\"spring.factories\"></a>spring.factories</h3><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！所有的自动配置类都在这里。</p>\n<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><ol>\n<li>SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值</li>\n<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>\n<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>\n<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>\n<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>\n</ol>\n<p><strong>SpringBoot所有自动配置都是在启动的时候扫描并加载: <code>spring.factories</code>所有的自动配置类都在这里面，但是不一定生效。要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功!</strong></p>\n<h2 id=\"SpringApplication\"><a href=\"#SpringApplication\" class=\"headerlink\" title=\"SpringApplication\"></a>SpringApplication</h2><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@SpringBootApplication\npublic class SpringbootApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringbootApplication.class, args);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>SpringApplication.run分析</strong></p>\n<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>\n<p><strong>SpringApplication这个类主要做了以下四件事情：</strong></p>\n<p>1、推断应用的类型是普通的项目还是Web项目</p>\n<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>\n<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>\n<p>4、推断并设置main方法的定义类，找到运行的主类</p>\n<p>查看构造器：</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;\n    &#x2F;&#x2F; ......\n    this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();\n    this.setInitializers(this.getSpringFactoriesInstances();\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();\n&#125;</code></pre>\n\n<h3 id=\"run方法流程\"><a href=\"#run方法流程\" class=\"headerlink\" title=\"run方法流程\"></a>run方法流程</h3><p><img src=\"https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2023/02/01/kuangstudy3bdd474f-d73b-4ad1-9cca-8f9e12683d0b.jpg\" alt=\"img\"></p>\n<h2 id=\"yaml语法\"><a href=\"#yaml语法\" class=\"headerlink\" title=\"yaml语法\"></a>yaml语法</h2><h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>\n<ul>\n<li><p>application.properties</p>\n<p>​\t语法结构 ：key&#x3D;value</p>\n</li>\n<li><p>application.yml</p>\n<p>​\t语法结构 ：key：空格 value</p>\n</li>\n</ul>\n<p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>\n<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>\n<p>server.port&#x3D;8081</p>\n<h3 id=\"yaml概述\"><a href=\"#yaml概述\" class=\"headerlink\" title=\"yaml概述\"></a>yaml概述</h3><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p>\n<p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p>\n<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>\n<p>传统xml配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;server&gt;    \n\t&lt;port&gt;8081&lt;port&gt;\n&lt;&#x2F;server&gt;</code></pre>\n\n<p>yaml配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server:\n\tprot: 8080</code></pre>\n\n<h3 id=\"yaml基础语法\"><a href=\"#yaml基础语法\" class=\"headerlink\" title=\"yaml基础语法\"></a>yaml基础语法</h3><p>说明：语法要求严格！</p>\n<ul>\n<li>空格不能省略</li>\n<li>以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</li>\n<li>属性和值的大小写都是十分敏感的。</li>\n</ul>\n<p><strong>字面量：普通的值 [ 数字，布尔值，字符串 ]</strong></p>\n<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>k: v</p></blockquote>\n<p>注意：</p>\n<ul>\n<li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>\n<p>比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen</p>\n</li>\n<li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>\n<p>比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen</p>\n</li>\n</ul>\n<p><strong>对象、Map（键值对）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#对象、Map格式\nk:     \n\tv1:\n\tv2:</code></pre>\n\n<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">student: \n\t\t name: qinjiang\n\t\t age: 3</code></pre>\n\n<p>行内写法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">student: &#123;name: qinjiang,age: 3&#125;</code></pre>\n\n<p><strong>数组（ List、set ）</strong></p>\n<p>用 - 值表示数组中的一个元素,比如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pets: \n\t  - cat\n\t  - dog\n\t  - pig</code></pre>\n\n<p>行内写法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pets: [cat,dog,pig]</code></pre>\n\n<p><strong>修改SpringBoot的默认端口号</strong></p>\n<p><strong>配置文件中添加，端口号的参数，就可以切换端口；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">server: \n\tport: 8082</code></pre>\n\n<h3 id=\"给属性赋值\"><a href=\"#给属性赋值\" class=\"headerlink\" title=\"给属性赋值\"></a>给属性赋值</h3><p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>\n<p><strong>yaml注入配置文件</strong></p>\n<p>在springboot项目中的resources目录下新建一个文件 application.yml</p>\n<p>编写一个实体类 Dog，原来使用@Value给bean注入属性值 :</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.kuang.springboot.pojo;\n@Component  &#x2F;&#x2F;注册bean到容器中\npublic class Dog &#123;\n    @Value(&quot;旺财&quot;)    &#x2F;&#x2F;注入属性值\n    private String name;\n    @Value(&quot;3&quot;)\n    private Integer age;\n    &#x2F;&#x2F;有参无参构造、get、set方法、toString()方法  \n&#125;</code></pre>\n\n<p>在SpringBoot的测试类下注入狗狗输出一下 :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@SpringBootTest\nclass DemoApplicationTests &#123;\n    @Autowired &#x2F;&#x2F;将狗狗自动注入进来\n    private Dog dog;\n    @Test\n    public void contextLoads() &#123;\n        System.out.println(dog); &#x2F;&#x2F;打印看下狗狗对象\n    &#125;\n&#125;</code></pre>\n\n<p>结果成功输出，@Value注入成功</p>\n<p><strong>指定配置文件</strong></p>\n<p><strong>@PropertySource：</strong>加载指定的配置文件；</p>\n<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>\n<p>在resources目录下新建一个<strong>person.properties</strong>文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">name&#x3D;lisi</code></pre>\n\n<p>然后代码中指定加载person.properties文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Component  &#x2F;&#x2F;注册bean\n&#x2F;&#x2F;@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n&#x2F;&#x2F;加载指定的配置文件@PropertySource(value &#x3D; &quot;classpath:lisi.properties&quot;)\npublic class Person &#123;\n\t&#x2F;&#x2F;SPEL表达式取出配置文件的值\n\t@Value(&quot;$&#123;name&#125;&quot;)\n\tprivate String name;\n\t……\n&#125;</code></pre>\n\n<p>输出测试，指定配置文件绑定成功！</p>\n<h3 id=\"配置文件占位符\"><a href=\"#配置文件占位符\" class=\"headerlink\" title=\"配置文件占位符\"></a>配置文件占位符</h3><p>配置文件还可以编写占位符生成随机数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">person:\n    name: 张三$&#123;random.uuid&#125; # 随机uuid\n    age: $&#123;random.int&#125;  # 随机int\n    happy: false\n    birth: 2000&#x2F;01&#x2F;01\n    maps: &#123;k1: v1,k2: v2&#125;\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: $&#123;person.hello:other&#125;_旺财\n      age: 1</code></pre>\n\n<h3 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>\n<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>\n<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接configurationProperties</p>\n<h2 id=\"JSR303校验\"><a href=\"#JSR303校验\" class=\"headerlink\" title=\"JSR303校验\"></a>JSR303校验</h2><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。这里写个注解让我们的name只能支持Email格式；</p>\n<p>添加依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@Component &#x2F;&#x2F;注册bean\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n@Validated  &#x2F;&#x2F;数据校验\npublic class Person &#123;\n    @Email(message&#x3D;&quot;邮箱格式错误&quot;) &#x2F;&#x2F;name必须是邮箱格式\n    private String name;\n&#125;</code></pre>\n\n<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425115938719.png\" alt=\"image-20230425115938719\"></p>\n<p><strong>使用数据校验，可以保证数据的正确性；</strong></p>\n<p><strong>常见校验参数</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@NotNull(message&#x3D;&quot;名字不能为空&quot;)\nprivate String userName;\n@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)\nprivate int age;\n@Email(message&#x3D;&quot;邮箱格式错误&quot;)\nprivate String email;\n空检查\n@Null       验证对象是否为null\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\nBooelan检查\n@AssertTrue     验证 Boolean 对象是否为 true  \n@AssertFalse    验证 Boolean 对象是否为 false  \n长度检查\n@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  \n@Length(min&#x3D;, max&#x3D;) string is between min and max included.\n日期检查\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前  \n@Future     验证 Date 和 Calendar 对象是否在当前时间之后  \n@Pattern    验证 String 对象是否符合正则表达式的规则\n.......等等\n除此以外，我们还可以自定义一些数据校验规则</code></pre>\n\n\n\n<h2 id=\"多环境装配\"><a href=\"#多环境装配\" class=\"headerlink\" title=\"多环境装配\"></a>多环境装配</h2><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>\n<h3 id=\"多配置文件\"><a href=\"#多配置文件\" class=\"headerlink\" title=\"多配置文件\"></a>多配置文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties&#x2F;yml , 用来指定多个环境版本；</p>\n<p><strong>例如：</strong></p>\n<p>application-test.properties 代表测试环境配置</p>\n<p>application-dev.properties 代表开发环境配置</p>\n<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>。</p>\n<p>我们需要通过一个配置来选择需要激活的环境：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；\n#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；\nspring.profiles.active&#x3D;dev</code></pre>\n\n<h3 id=\"yaml的多文档块\"><a href=\"#yaml的多文档块\" class=\"headerlink\" title=\"yaml的多文档块\"></a>yaml的多文档块</h3><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">server:\n  port: 8081\n#选择要激活那个环境块\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev #配置环境的名称\n---\nserver:\n  port: 8084\nspring:\n  profiles: prod  #配置环境的名称</code></pre>\n\n<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>\n<h3 id=\"配置文件加载位置\"><a href=\"#配置文件加载位置\" class=\"headerlink\" title=\"配置文件加载位置\"></a>配置文件加载位置</h3><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>\n<p>官方外部配置文件说明参考文档</p>\n<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>\n<p>优先级1：项目路径下的config文件夹配置文件</p>\n<p>优先级2：项目路径下配置文件</p>\n<p>优先级3：资源路径下的config文件夹配置文件</p>\n<p>优先级4：资源路径下配置文件</p>\n<p>优先级由高到低，高优先级的配置会覆盖低优先级的配置</p>\n<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>\n<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#配置项目的访问路径\nserver.servlet.context-path&#x3D;&#x2F;kuang</code></pre>\n\n<h3 id=\"扩展，运维小技巧\"><a href=\"#扩展，运维小技巧\" class=\"headerlink\" title=\"扩展，运维小技巧\"></a>扩展，运维小技巧</h3><p>指定位置加载配置文件</p>\n<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>\n<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java -jar spring-boot-config.jar --spring.config.location&#x3D;F:&#x2F;application.properties</code></pre>\n\n\n\n<h2 id=\"自动配置原理\"><a href=\"#自动配置原理\" class=\"headerlink\" title=\"自动配置原理\"></a>自动配置原理</h2><h3 id=\"分析自动配置原理\"><a href=\"#分析自动配置原理\" class=\"headerlink\" title=\"分析自动配置原理\"></a>分析自动配置原理</h3><p>以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；\n@Configuration \n&#x2F;&#x2F;启动指定类的ConfigurationProperties功能；\n  &#x2F;&#x2F;进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；\n  &#x2F;&#x2F;并把HttpProperties加入到ioc容器中\n@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) \n&#x2F;&#x2F;Spring底层@Conditional注解\n  &#x2F;&#x2F;根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；\n  &#x2F;&#x2F;这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效\n@ConditionalOnWebApplication(\n    type &#x3D; Type.SERVLET\n)\n&#x2F;&#x2F;判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\n@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)\n&#x2F;&#x2F;判断配置文件中是否存在某个配置：spring.http.encoding.enabled；\n  &#x2F;&#x2F;如果不存在，判断也是成立的\n  &#x2F;&#x2F;即使我们配置文件中不配置pring.http.encoding.enabled&#x3D;true，也是默认生效的；\n@ConditionalOnProperty(\n    prefix &#x3D; &quot;spring.http.encoding&quot;,\n    value &#x3D; &#123;&quot;enabled&quot;&#125;,\n    matchIfMissing &#x3D; true\n)\npublic class HttpEncodingAutoConfiguration &#123;\n    &#x2F;&#x2F;他已经和SpringBoot的配置文件映射了\n    private final Encoding properties;\n    &#x2F;&#x2F;只有一个有参构造器的情况下，参数的值就会从容器中拿\n    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;\n        this.properties &#x3D; properties.getEncoding();\n    &#125;\n    &#x2F;&#x2F;给容器中添加一个组件，这个组件的某些值需要从properties中获取\n    @Bean\n    @ConditionalOnMissingBean &#x2F;&#x2F;判断容器没有这个组件？\n    public CharacterEncodingFilter characterEncodingFilter() &#123;\n        CharacterEncodingFilter filter &#x3D; new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));\n        return filter;\n    &#125;\n    &#x2F;&#x2F;......\n&#125;</code></pre>\n\n<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>\n<ul>\n<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>\n<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>\n<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>\n<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;从配置文件中获取指定的值和bean的属性进行绑定\n@ConfigurationProperties(prefix &#x3D; &quot;spring.http&quot;) \npublic class HttpProperties &#123;\n    &#x2F;&#x2F; .....\n&#125;</code></pre>\n\n<p><strong>这就是自动装配的原理！</strong></p>\n<h3 id=\"精髓\"><a href=\"#精髓\" class=\"headerlink\" title=\"精髓\"></a>精髓</h3><p>1、SpringBoot启动会加载大量的自动配置类</p>\n<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>\n<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>\n<p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>\n<p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p>\n<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>\n<p><strong>了解：</strong>@Conditionl：</p>\n<p>了解完自动装配的原理后，关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>\n<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>\n<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>\n<p><img src=\"https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2023/02/01/kuangstudy31d7f34c-829b-4fe1-a184-d9114bb328a3.jpg\" alt=\"img\"></p>\n<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>\n<p>我们怎么知道哪些自动配置类生效？</p>\n<p><strong>我们可以通过启用 debug&#x3D;true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#开启springboot的调试类\ndebug&#x3D;true</code></pre>\n\n<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>\n<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>\n<p><strong>Unconditional classes: （没有条件的类）</strong></p>\n<h2 id=\"SpringBoot-Web开发\"><a href=\"#SpringBoot-Web开发\" class=\"headerlink\" title=\"SpringBoot Web开发\"></a>SpringBoot Web开发</h2><p><strong>使用SpringBoot的步骤：</strong></p>\n<p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p>\n<p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p>\n<p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p>\n<p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p>\n<p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p>\n<ul>\n<li>向容器中自动配置组件 ：<strong>Autoconfiguration</strong></li>\n<li>自动配置类，封装配置文件的内容：<strong>Properties</strong></li>\n</ul>\n<h3 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h3><ul>\n<li>导入静态资源</li>\n<li>首页</li>\n<li>jsp，模板引擎Thymeleaf</li>\n<li>装配扩展SpringMVC</li>\n<li>增删改查</li>\n<li>拦截器</li>\n<li>国际化</li>\n</ul>\n<h3 id=\"静态资源处理\"><a href=\"#静态资源处理\" class=\"headerlink\" title=\"静态资源处理\"></a>静态资源处理</h3><p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>\n<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>\n<p>有一个方法：addResourceHandlers 添加资源处理</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    if (!this.resourceProperties.isAddMappings()) &#123;\n        &#x2F;&#x2F; 已禁用默认资源处理\n        logger.debug(&quot;Default resource handling disabled&quot;);\n        return;\n    &#125;\n    &#x2F;&#x2F; 缓存控制\n    Duration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod();\n    CacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n    &#x2F;&#x2F; webjars 配置\n    if (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;\n        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)\n                                             .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    &#125;\n    &#x2F;&#x2F; 静态资源配置\n    String staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();\n    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    &#125;\n&#125;</code></pre>\n\n<p>读一下源代码：比如所有的 &#x2F;webjars&#x2F;** ， 都需要去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找对应的资源；</p>\n<h4 id=\"1-webjars方式引入\"><a href=\"#1-webjars方式引入\" class=\"headerlink\" title=\"1.webjars方式引入\"></a>1.webjars方式引入</h4><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>\n<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>\n<p>网站：<a href=\"https://www.webjars.org/\">https://www.webjars.org</a></p>\n<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源</p>\n<p>我们这里访问：<a href=\"http://localhost:8080/webjars/jquery/3.4.1/jquery.js\">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120052766.png\" alt=\"image-20230425120052766\"></p>\n<h4 id=\"2-静态资源映射规则\"><a href=\"#2-静态资源映射规则\" class=\"headerlink\" title=\"2.静态资源映射规则\"></a>2.静态资源映射规则</h4><p>我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>\n<p>我们去找staticPathPattern发现第二种映射规则 ：&#x2F;** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 进入方法\npublic String[] getStaticLocations() &#123;\n    return this.staticLocations;\n&#125;\n&#x2F;&#x2F; 找到对应的值\nprivate String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;\n&#x2F;&#x2F; 找到路径\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; \n    &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,\n  &quot;classpath:&#x2F;resources&#x2F;&quot;, \n    &quot;classpath:&#x2F;static&#x2F;&quot;, \n    &quot;classpath:&#x2F;public&#x2F;&quot; \n&#125;;</code></pre>\n\n<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>\n<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">“classpath:&#x2F;META-INF&#x2F;resources&#x2F;“\n“classpath:&#x2F;resources&#x2F;“\n“classpath:&#x2F;static&#x2F;“\n“classpath:&#x2F;public&#x2F;“</code></pre>\n\n<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>\n<p>比如我们访问 <a href=\"http://localhost:8080/1.js\">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p>\n<h4 id=\"3-自定义静态资源路径\"><a href=\"#3-自定义静态资源路径\" class=\"headerlink\" title=\"3.自定义静态资源路径\"></a>3.自定义静态资源路径</h4><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring.resources.static-locations&#x3D;classpath:&#x2F;coding&#x2F;,classpath:&#x2F;kuang&#x2F;</code></pre>\n\n<p><strong>注意：</strong>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>\n<h3 id=\"首页和图标定制\"><a href=\"#首页和图标定制\" class=\"headerlink\" title=\"首页和图标定制\"></a>首页和图标定制</h3><p>继续向下看源码，可以看到一个欢迎页的映射，就是我们的首页！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n                                                           FormattingConversionService mvcConversionService,\n                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;\n    WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(\n        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), &#x2F;&#x2F; getWelcomePage 获得欢迎页\n        this.mvcProperties.getStaticPathPattern());\n    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n    return welcomePageHandlerMapping;\n&#125;</code></pre>\n\n<p>点进去继续看</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private Optional&lt;Resource&gt; getWelcomePage() &#123;\n    String[] locations &#x3D; getResourceLocations(this.resourceProperties.getStaticLocations());\n    &#x2F;&#x2F; ::是java8 中新引入的运算符\n    &#x2F;&#x2F; Class::function的时候function是属于Class的，应该是静态方法。\n    &#x2F;&#x2F; this::function的funtion是属于这个对象的。\n    &#x2F;&#x2F; 简而言之，就是一种语法糖而已，是一种简写\n    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();\n&#125;\n&#x2F;&#x2F; 欢迎页就是一个location下的的 index.html 而已\nprivate Resource getIndexHtml(String location) &#123;\n    return this.resourceLoader.getResource(location + &quot;index.html&quot;);\n&#125;</code></pre>\n\n<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 &#x2F;** 映射。</p>\n<p>比如我访问 <a href=\"http://localhost:8080/\">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p>\n<p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 <a href=\"http://localhost:8080/\">http://localhost:8080/</a> 看结果！</p>\n<h4 id=\"网站图标\"><a href=\"#网站图标\" class=\"headerlink\" title=\"网站图标\"></a><strong>网站图标</strong></h4><p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p>\n<p>1、关闭SpringBoot默认图标</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#关闭默认图标\nspring.mvc.favicon.enabled&#x3D;false</code></pre>\n\n<p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p>\n<p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p>\n<p><img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230424164500756.png\" alt=\"image-20230424164500756\"></p>\n<p>新版将 favicon.ico图片放入static目录即可。</p>\n<h3 id=\"thymeleaf模板引擎\"><a href=\"#thymeleaf模板引擎\" class=\"headerlink\" title=\"thymeleaf模板引擎\"></a>thymeleaf模板引擎</h3><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>\n<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>\n<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦</p>\n<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>\n<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120148915.png\" alt=\"image-20230425120148915\"></p>\n<p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且功能更强大。</p>\n<h4 id=\"引入Thymeleaf\"><a href=\"#引入Thymeleaf\" class=\"headerlink\" title=\"引入Thymeleaf\"></a>引入Thymeleaf</h4><p>Thymeleaf 官网：<a href=\"https://www.thymeleaf.org/\">https://www.thymeleaf.org/</a></p>\n<p>Thymeleaf 在Github 的主页：<a href=\"https://github.com/thymeleaf/thymeleaf\">https://github.com/thymeleaf/thymeleaf</a></p>\n<p>Spring官方文档：找到我们对应的版本</p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter\">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>\n<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!--thymeleaf--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425120206867.png\" alt=\"image-20230425120206867\"></p>\n<h4 id=\"Thymeleaf分析\"><a href=\"#Thymeleaf分析\" class=\"headerlink\" title=\"Thymeleaf分析\"></a>Thymeleaf分析</h4><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>\n<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>\n<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@ConfigurationProperties(\n    prefix &#x3D; &quot;spring.thymeleaf&quot;\n)\npublic class ThymeleafProperties &#123;\n    private static final Charset DEFAULT_ENCODING;\n    public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n    public static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;\n    private boolean checkTemplate &#x3D; true;\n    private boolean checkTemplateLocation &#x3D; true;\n    private String prefix &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n    private String suffix &#x3D; &quot;.html&quot;;\n    private String mode &#x3D; &quot;HTML&quot;;\n    private Charset encoding;\n&#125;</code></pre>\n\n<p>我们可以在其中看到默认的前缀和后缀！</p>\n<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>\n<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>\n<h4 id=\"Thymeleaf语法学习\"><a href=\"#Thymeleaf语法学习\" class=\"headerlink\" title=\"Thymeleaf语法学习\"></a>Thymeleaf语法学习</h4><p>修改测试请求，增加数据传输；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@RequestMapping(&quot;&#x2F;t1&quot;)\npublic String test1(Model model)&#123;\n    &#x2F;&#x2F;存入数据\n    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);\n    &#x2F;&#x2F;classpath:&#x2F;templates&#x2F;test.html\n    return &quot;test&quot;;\n&#125;</code></pre>\n\n<p>要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。可以去官方文档的#3中看一下命名空间拿来过来：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;</code></pre>\n\n<p>去编写下前端页面</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE html&gt;\n&lt;!--使用http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;thymeleaf-extras-spring,红色下划线消失--&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;测试页面&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Test&lt;&#x2F;h1&gt;\n&lt;!--th:text就是将div中的内容设置为它指定的值--&gt;\n&lt;div th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n\n\n<h4 id=\"提取公共页面\"><a href=\"#提取公共页面\" class=\"headerlink\" title=\"提取公共页面\"></a>提取公共页面</h4><p>可以将导航栏、侧边栏、底部栏等放入一个html文件中，在第一句标签上加上th:fragment&#x3D;”XXXX”。</p>\n<p>在其它html文件中调用只需:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div th:insert&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--插入--&gt;\n&lt;div th:replace&#x3D;&quot;~&#123;路径&#x2F;页面名::XXXX&#125;&quot;&gt;&lt;&#x2F;div&gt;&lt;!--替换--&gt;</code></pre>\n\n<p>如果要传递参数，直接在XXXX后面用(参数名&#x3D;参数值)传参。</p>\n<p>(接收可以th:class&#x3D;”${参数名&#x3D;&#x3D;参数值?”正确就执行的属性”:”不正确执行的属性”}”)</p>\n<h4 id=\"日期转义\"><a href=\"#日期转义\" class=\"headerlink\" title=\"日期转义\"></a>日期转义</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)</code></pre>\n\n<h3 id=\"MVC配置\"><a href=\"#MVC配置\" class=\"headerlink\" title=\"MVC配置\"></a>MVC配置</h3><p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>\n<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>\n<p>地址 ：<a href=\"https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration\">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>\n<h2 id=\"SpringBoot-Web项目练习\"><a href=\"#SpringBoot-Web项目练习\" class=\"headerlink\" title=\"SpringBoot Web项目练习\"></a>SpringBoot Web项目练习</h2><h3 id=\"登录实现\"><a href=\"#登录实现\" class=\"headerlink\" title=\"登录实现\"></a>登录实现</h3><p>在LoginController中编写登陆方法 :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.lc.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.thymeleaf.util.StringUtils;\nimport javax.servlet.http.HttpSession;\n@Controller\npublic class LoginController &#123;\n    @RequestMapping(&quot;&#x2F;user&#x2F;login&quot;)\n    public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model model, HttpSession session)&#123;\n        &#x2F;&#x2F;具体业务\n        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password))&#123;\n            session.setAttribute(&quot;loginUser&quot;,username);\n            return &quot;redirect:&#x2F;main.html &quot;;\n        &#125;else &#123;\n            &#x2F;&#x2F;告知用户登陆失败\n            model.addAttribute(&quot;msg&quot;,&quot;用户名或密码错误!&quot;);\n            return &quot;login&quot;;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在MyMvcConfig中添加跳转视图控制 :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F;添加视图控制\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;访问&#x2F;前往登录页\n        registry.addViewController(&quot;&#x2F;login.html&quot;).setViewName(&quot;login&quot;);   &#x2F;&#x2F;前往登录页\n        registry.addViewController(&quot;&#x2F;main.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页\n        registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;index&quot;);   &#x2F;&#x2F;映射为主页\n    &#125;\n    &#x2F;&#x2F;自定义的国际化组件就生效了\n    @Bean\n    public LocaleResolver localeResolver()&#123;\n        return new MyLocaleResolver();\n    &#125;\n&#125;</code></pre>\n\n<p>在templates中编写登陆页面login.html :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;amazeui.min.css&#125;&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;admin.css&#125;&quot;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;app.css&#125;&quot;&gt;\n    &lt;title&gt;登陆页面&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        div.set_center&#123;\n            margin-left: auto;\n            margin-right: auto;\n            width: 450px;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body class&#x3D;&quot;am-text-center&quot;&gt;\n    &lt;form class&#x3D;&quot;&quot; th:action&#x3D;&quot;@&#123;&#x2F;user&#x2F;login&#125;&quot;&gt;\n        &lt;div class&#x3D;&quot;set_center&quot;&gt;\n            &lt;h1 th:text&#x3D;&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;&#x2F;h1&gt;\n            &lt;!--如果msg为空则不显示--&gt;\n            &lt;p style&#x3D;&quot;color: red&quot; th:text&#x3D;&quot;$&#123;msg&#125;&quot; th:if&#x3D;&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;&#x2F;p&gt;\n            &lt;label&gt;Username:&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;username&quot; th:placeholder&#x3D;&quot;#&#123;login.username&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;&lt;br&gt;\n            &lt;label&gt;Password:&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; th:placeholder&#x3D;&quot;#&#123;login.password&#125;&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;\n            &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;remember-me&quot; th:text&#x3D;&quot;#&#123;login.remember&#125;&quot;&gt;&lt;br&gt;\n            &lt;button class&#x3D;&quot;btn-box&quot; th:text&#x3D;&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;&#x2F;button&gt;\n            &lt;!-- 这里传入参数不需要使用 ？使用 （key&#x3D;value）--&gt;&lt;br&gt;\n            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;&#x2F;a&gt;&amp;nbsp;&amp;nbsp;\n            &lt;a class&#x3D;&quot;btn btn-sell&quot; th:href&#x3D;&quot;@&#123;&#x2F;login.html(l&#x3D;&#39;en_US&#39;)&#125;&quot;&gt;English&lt;&#x2F;a&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>运行，输入任意账号和123456密码成功登陆:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425102149050.png\" alt=\"image-20230425102149050\"></p>\n<h3 id=\"登录拦截器\"><a href=\"#登录拦截器\" class=\"headerlink\" title=\"登录拦截器\"></a>登录拦截器</h3><p>新建LoginHandlerInterceptor继承HandlerInterceptor方法实现拦截器 </p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.lc.config;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\npublic class LoginHandlerInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        &#x2F;&#x2F;登录成功后，应该有用户的session\n        Object loginUser &#x3D; request.getSession().getAttribute(&quot;loginUser&quot;);\n        if(loginUser &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;没有登陆\n            request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;);\n            request.getRequestDispatcher(&quot;&#x2F;login.html&quot;).forward(request,response);\n            return false;\n        &#125;else&#123;\n            return true;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在MyMvcConfig中添加自定义拦截器</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F;自定义拦截器\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    &#x2F;&#x2F;拦截所有页面除了登陆页面和静态资源\n    registry.addInterceptor(new LoginHandlerInterceptor())\n            .addPathPatterns(&quot;&#x2F;**&quot;)\n            .excludePathPatterns(&quot;&#x2F;login.html&quot;,&quot;&#x2F;&quot;,&quot;&#x2F;user&#x2F;login&quot;,&quot;&#x2F;css&#x2F;*&quot;,&quot;&#x2F;js&#x2F;*&quot;);\n&#125;</code></pre>\n\n<p>直接访问main.html拦截成功，转入登录页面 :</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/kuangstudy47189c2f-8ff2-436b-96c2-fca9d53e41e8.png\" alt=\"img\"></p>\n<h3 id=\"展示员工列表\"><a href=\"#展示员工列表\" class=\"headerlink\" title=\"展示员工列表\"></a>展示员工列表</h3><p>在EmployeeController中写入员工列表代码 ,传入员工列表:</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@Controller\npublic class EmployeeController &#123;\n    @Autowired\n    EmployeeDao employeeDao;\n    @RequestMapping(&quot;&#x2F;emps&quot;)\n    public String list(Model model)&#123;\n        Collection&lt;Employee&gt; employees &#x3D; employeeDao.getAllEmployee();\n        model.addAttribute(&quot;emps&quot;,employees);\n        System.out.println(&quot;!!!!!!!!!!!!&quot;);\n        return &quot;emp&#x2F;user&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>部分前端代码 :</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;table class&#x3D;&quot;am-table am-table-striped am-table-hover table-main&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n    &lt;th class&#x3D;&quot;table-check&quot;&gt;\n        &lt;input id&#x3D;&quot;chkAll&quot; type&#x3D;&quot;checkbox&quot;&gt;\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-id&quot;&gt;\n        ID\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-title&quot;&gt;\n        姓名\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        性别\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        部门名称\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        邮箱\n    &lt;&#x2F;th&gt;\n    &lt;th&gt;\n        生日\n    &lt;&#x2F;th&gt;\n    &lt;th class&#x3D;&quot;table-set&quot;&gt;\n        操作\n    &lt;&#x2F;th&gt;\n&lt;&#x2F;tr&gt;\n&lt;&#x2F;thead&gt;\n&lt;tbody id&#x3D;&quot;tUser&quot;&gt;\n&lt;tr th:each&#x3D;&quot;emp:$&#123;emps&#125;&quot;&gt;\n    &lt;td&gt;&lt;input name&#x3D;&quot;ids&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getId()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getName()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getGander()&#x3D;&#x3D;0?&#39;女&#39;:&#39;男&#39;&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getDepartment().getDepartmentName()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;emp.getEmail()&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td th:text&#x3D;&quot;$&#123;#dates.format(emp.getBirth(),&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;&#x2F;td&gt;\n    &lt;td&gt;\n        &lt;div class&#x3D;&quot;am-btn-toolbar&quot;&gt;\n            &lt;div class&#x3D;&quot;am-btn-group am-btn-group-xs&quot;&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-secondary btnEdit&quot;&gt;&lt;span class&#x3D;&quot;am-icon-pencil-square-o&quot;&gt;&lt;&#x2F;span&gt; 编辑&lt;&#x2F;button&gt;&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;am-btn am-btn-default am-btn-xs am-text-danger am-hide-sm-only&quot; onclick&#x3D;&quot;delUser(1,1)&quot;&gt;&lt;span class&#x3D;&quot;am-icon-trash-o&quot;&gt;&lt;&#x2F;span&gt; 删除&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n&lt;&#x2F;tbody&gt;\n&lt;&#x2F;table&gt;</code></pre>\n\n<h3 id=\"添加员工\"><a href=\"#添加员工\" class=\"headerlink\" title=\"添加员工\"></a>添加员工</h3><p>在EmployeeController中添加方法 :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F;跳转到addUser页面\n@GetMapping(&quot;&#x2F;add&quot;)\npublic String toAddUser(Model model)&#123;\n    Collection&lt;Department&gt; departments &#x3D; departmentDao.getDepartment();\n    model.addAttribute(&quot;departs&quot;,departments);\n    return &quot;emp&#x2F;addUser&quot;;\n&#125;\n&#x2F;&#x2F;添加员工\n@RequestMapping(&quot;&#x2F;addEmp&quot;)\npublic String addEmp(Employee employee)&#123;\n    employeeDao.addEmployee(employee);\n    System.out.println(&quot;employee++&gt;&quot;+employee);\n    return &quot;redirect:&#x2F;emps&quot;;\n&#125;</code></pre>\n\n<p>部分前端代码 :</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form class&#x3D;&quot;am-form am-form-horizontal&quot; th:action&#x3D;&quot;@&#123;&#x2F;addEmp&#125;&quot; method&#x3D;&quot;post&quot; style&#x3D;&quot;padding-top: 30px;&quot;&gt;\n&lt;input name&#x3D;&quot;id&quot; type&#x3D;&quot;hidden&quot;&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n    姓名\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入姓名&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small&gt;请输入姓名。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n    邮箱\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入邮箱&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;email&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small &gt;请输入邮箱。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n            性别 &#x2F; sex\n        &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot; style&#x3D;&quot;line-height: 30px;&quot;&gt;\n        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;man&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n        &lt;label for&#x3D;&quot;man&quot;&gt;\n                男\n            &lt;&#x2F;label&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\n        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;woman&quot; name&#x3D;&quot;gander&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;\n        &lt;label for&#x3D;&quot;woman&quot;&gt;\n                女\n            &lt;&#x2F;label&gt;\n        &lt;br &#x2F;&gt;\n        &lt;small&gt;请选择性别&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n            部门\n        &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;select name&#x3D;&quot;department.id&quot; required&gt;\n            &lt;option th:each&#x3D;&quot;dept:$&#123;departs&#125;&quot; th:text&#x3D;&quot;$&#123;dept.getDepartmentName()&#125;&quot; th:value&#x3D;&quot;$&#123;dept.getId()&#125;&quot;&gt;&lt;&#x2F;option&gt;\n        &lt;&#x2F;select&gt;\n        &lt;small&gt;请选择部门&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;label class&#x3D;&quot;am-u-sm-3 am-form-label&quot;&gt;\n        生日\n    &lt;&#x2F;label&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9&quot;&gt;\n        &lt;input required&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入生日&quot; value&#x3D;&quot;&quot; name&#x3D;&quot;birth&quot; type&#x3D;&quot;text&quot;&gt;\n        &lt;small&gt;请输入生日。&lt;&#x2F;small&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;am-form-group&quot;&gt;\n    &lt;div class&#x3D;&quot;am-u-sm-9 am-u-sm-push-3&quot;&gt;\n        &lt;input class&#x3D;&quot;am-btn am-btn-success&quot; value&#x3D;&quot;添加&quot; type&#x3D;&quot;submit&quot;&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<p>知识点:</p>\n<p>默认时间格式为y&#x2F;m&#x2F;d，可以在配置文件中修改为y-m-d:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#时间日期格式化\nspring.mvc.date-format&#x3D;yyyy-MM-dd</code></pre>\n\n<h3 id=\"404错误页面\"><a href=\"#404错误页面\" class=\"headerlink\" title=\"404错误页面\"></a>404错误页面</h3><p>在templates下新建error文件夹</p>\n<p>在里面建404.html，发生404自动使用该页面</p>\n<p>存入500.html，发生500错误则自动跳入。</p>\n<h2 id=\"整合JDBC\"><a href=\"#整合JDBC\" class=\"headerlink\" title=\"整合JDBC\"></a>整合JDBC</h2><h3 id=\"SpringDate\"><a href=\"#SpringDate\" class=\"headerlink\" title=\"SpringDate\"></a>SpringDate</h3><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>\n<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>\n<p>Sping Data 官网：<a href=\"https://spring.io/projects/spring-data\">https://spring.io/projects/spring-data</a></p>\n<p>数据库相关的启动器 ：可以参考官方文档：</p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter\">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>\n<h3 id=\"整合JDBC-1\"><a href=\"#整合JDBC-1\" class=\"headerlink\" title=\"整合JDBC\"></a>整合JDBC</h3><p>创建一个项目，引入 依赖</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425112158482.png\" alt=\"image-20230425112158482\"></p>\n<p>项目建好之后，发现自动帮我们导入了如下的启动器：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>编写yaml配置文件连接数据库；</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre>\n\n<p>配置完这一些东西后，就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@SpringBootTest\nclass SpringbootDataJdbcApplicationTests &#123;\n    &#x2F;&#x2F;DI注入数据源\n    @Autowired\n    DataSource dataSource;\n    @Test\n    public void contextLoads() throws SQLException &#123;\n        &#x2F;&#x2F;看一下默认数据源    com.zaxxer.hikari.HikariDataSource\n        System.out.println(dataSource.getClass());\n        &#x2F;&#x2F;获得连接\n        Connection connection &#x3D; dataSource.getConnection();\n        System.out.println(connection);\n        &#x2F;&#x2F;关闭连接\n        connection.close();\n    &#125;\n&#125;</code></pre>\n\n<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>\n<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>\n<p>有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>\n<h3 id=\"JDBC-Template\"><a href=\"#JDBC-Template\" class=\"headerlink\" title=\"JDBC Template\"></a>JDBC Template</h3><p>即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>\n<p>数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>\n<p>Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>\n<p>JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>\n<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>\n<ul>\n<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>\n<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>\n<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>\n<li>call方法：用于执行存储过程、函数相关语句。</li>\n</ul>\n<p>现在编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.lc.controller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n@RestController\n@RequestMapping(&quot;&#x2F;jdbc&quot;)\npublic class JdbcController &#123;\n    &#x2F;**\n     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate\n     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作\n     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接\n     *&#x2F;\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n    &#x2F;&#x2F;查询employee表中所有数据\n    &#x2F;&#x2F;List 中的1个 Map 对应数据库的 1行数据\n    &#x2F;&#x2F;Map 中的 key 对应数据库的字段名，value 对应数据库的字段值\n    @GetMapping(&quot;&#x2F;list&quot;)\n    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;\n        String sql &#x3D; &quot;select * from mybatis.user&quot;;\n        List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; jdbcTemplate.queryForList(sql);\n        return maps;\n    &#125;\n    &#x2F;&#x2F;新增一个用户\n    @GetMapping(&quot;&#x2F;add&quot;)\n    public String addUser()&#123;\n        &#x2F;&#x2F;插入语句，注意时间问题\n        String sql &#x3D; &quot;insert into mybatis.user(id, name, pwd) &quot; +\n                &quot; values (10,&#39;张三&#39;,&#39;123456&#39;)&quot;;\n        jdbcTemplate.update(sql);\n        &#x2F;&#x2F;查询\n        return &quot;addOk&quot;;\n    &#125;\n    &#x2F;&#x2F;修改用户信息\n    @GetMapping(&quot;&#x2F;update&#x2F;&#123;id&#125;&quot;)\n    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        &#x2F;&#x2F;插入语句\n        String sql &#x3D; &quot;update mybatis.user set name&#x3D;?,pwd&#x3D;? where id&#x3D;&quot;+id;\n        &#x2F;&#x2F;数据\n        Object[] objects &#x3D; new Object[2];\n        objects[0] &#x3D; &quot;修改名&quot;;\n        objects[1] &#x3D; &quot;AAAAAA&quot;;\n        jdbcTemplate.update(sql,objects);\n        &#x2F;&#x2F;查询\n        return &quot;updateOk&quot;;\n    &#125;\n    &#x2F;&#x2F;删除用户\n    @GetMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)\n    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        &#x2F;&#x2F;插入语句\n        String sql &#x3D; &quot;delete from mybatis.user where id&#x3D;?&quot;;\n        jdbcTemplate.update(sql,id);\n        &#x2F;&#x2F;查询\n        return &quot;deleteOk&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>测试请求，结果正常；</p>\n<p>到此，CURD的基本操作，使用 JDBC 就搞定了。</p>\n<h2 id=\"整合Druid数据源\"><a href=\"#整合Druid数据源\" class=\"headerlink\" title=\"整合Druid数据源\"></a>整合Druid数据源</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>\n<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p>\n<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>\n<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>\n<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>\n<p>Github地址：<a href=\"https://github.com/alibaba/druid/\">https://github.com/alibaba/druid/</a></p>\n<h3 id=\"配置数据源\"><a href=\"#配置数据源\" class=\"headerlink\" title=\"配置数据源\"></a>配置数据源</h3><p>添加上 Druid 数据源依赖。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.1.21&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">spring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源</code></pre>\n\n<p>数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425112640019.png\" alt=\"image-20230425112640019\"></p>\n<p>确定切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500</code></pre>\n\n<p>导入Log4j 的依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.kuang.config;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport javax.sql.DataSource;\n@Configuration\npublic class DruidConfig &#123;\n    &#x2F;*\n       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\n       @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)：作用就是将 全局配置文件中\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中\n     *&#x2F;\n    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druidDataSource() &#123;\n        return new DruidDataSource();\n    &#125;\n&#125;</code></pre>\n\n<p>去测试类中测试一下；看是否成功！</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">@SpringBootTest\nclass SpringbootDataJdbcApplicationTests &#123;\n    &#x2F;&#x2F;DI注入数据源\n    @Autowired\n    DataSource dataSource;\n    @Test\n    public void contextLoads() throws SQLException &#123;\n        &#x2F;&#x2F;看一下默认数据源\n        System.out.println(dataSource.getClass());\n        &#x2F;&#x2F;获得连接\n        Connection connection &#x3D;   dataSource.getConnection();\n        System.out.println(connection);\n        DruidDataSource druidDataSource &#x3D; (DruidDataSource) dataSource;\n        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());\n        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());\n        &#x2F;&#x2F;关闭连接\n        connection.close();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果 ：可见配置参数已经生效！</p>\n<h2 id=\"整合Mybatis\"><a href=\"#整合Mybatis\" class=\"headerlink\" title=\"整合Mybatis\"></a>整合Mybatis</h2><p>官方文档：<a href=\"http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>\n<p>Maven仓库地址：<a href=\"https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1\">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</a></p>\n<h3 id=\"整合测试\"><a href=\"#整合测试\" class=\"headerlink\" title=\"整合测试\"></a>整合测试</h3><p>导入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>配置数据库连接信息（不变）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone&#x3D;UTC解决时区的报错\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500</code></pre>\n\n<p><strong>测试数据库是否连接成功！</strong></p>\n<p><strong>创建实体类，导入 Lombok！</strong></p>\n<p>User.java</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.xiao.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User &#123;\n    private Integer id;\n    private String name;\n    private String pwd;\n&#125;</code></pre>\n\n<p><strong>创建mapper目录以及对应的 Mapper 接口</strong></p>\n<p>UserMapper.java</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.lc.mapper;\nimport com.lc.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.springframework.stereotype.Repository;\nimport java.util.List;\n&#x2F;&#x2F;这个注解表示这是一个Mybatis的mapper类\n@Mapper\n@Repository\npublic interface UserMapper &#123;\n    List&lt;User&gt; queryUserList();\n    User queryUserById(int id);\n    int addUser(User user);\n    int updateUser(User user);\n    int deleteUser(int id);\n&#125;</code></pre>\n\n<p><strong>对应的Mapper映射文件</strong></p>\n<p>UserMapper.xml，建在resources&#x2F;mybatis&#x2F;mapper下</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper&gt;\n    &lt;select id&#x3D;&quot;queryUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n        select * from mybatis.user;\n    &lt;&#x2F;select&gt;\n    &lt;select id&#x3D;&quot;queryUserById&quot; resultType&#x3D;&quot;User&quot;&gt;\n        select * from mybatis.user where id &#x3D; #&#123;id&#125;\n    &lt;&#x2F;select&gt;\n    &lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n        insert into mybatis.user(id, name, pwd)\n        values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);\n    &lt;&#x2F;insert&gt;\n    &lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n        update mybatis.user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;update&gt;\n    &lt;delete id&#x3D;&quot;deleteUser&quot;parameterType&#x3D;&quot;int&quot;&gt;\n        delete from mybatis.user where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;delete&gt;\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<p>在配置文件application.yml中整合Mybatis :</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#整合Mybatis\n#别名\n#mapper地址\nmybatis:\n  type-aliases-package: com.lc.pojo\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml</code></pre>\n\n<p><strong>编写UserController 进行测试！</strong></p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.lc.controller;\nimport com.lc.mapper.UserMapper;\nimport com.lc.pojo.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.List;\n@RestController\npublic class UserController &#123;\n    @Autowired\n    private UserMapper userMapper;\n    @RequestMapping(&quot;&#x2F;list&quot;)\n    public List&lt;User&gt; queryUserList()&#123;\n        List&lt;User&gt; list &#x3D; userMapper.queryUserList();\n        for (User user : list) &#123;\n            System.out.println(user);\n        &#125;\n        return list;\n    &#125;\n    @RequestMapping(&quot;&#x2F;queryUser&#x2F;&#123;id&#125;&quot;)\n    public User queryUserById(@PathVariable(&quot;id&quot;) int id)&#123;\n        return userMapper.queryUserById(id);\n    &#125;\n    @RequestMapping(&quot;&#x2F;addUser&quot;)\n    public String addUser()&#123;\n        int res &#x3D; userMapper.addUser(new User(10,&quot;增加&quot;,&quot;123456&quot;));\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)\n    public String deleteUser(@PathVariable(&quot;id&quot;) int id)&#123;\n        int res &#x3D; userMapper.deleteUser(id);\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n    @RequestMapping(&quot;&#x2F;updateUser&quot;)\n    public String updateUser()&#123;\n        int res &#x3D; userMapper.updateUser(new User(10,&quot;xxxx&quot;,&quot;111111&quot;));\n        if (res &#x3D;&#x3D; 1)\n            return &quot;OK&quot;;\n        else\n            return &quot;ERROR&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>启动项目访问进行测试！</strong></p>\n<h2 id=\"SpringSecurity-安全\"><a href=\"#SpringSecurity-安全\" class=\"headerlink\" title=\"SpringSecurity(安全)\"></a>SpringSecurity(安全)</h2><p>在 Web  开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>\n<p>市面上存在比较有名的：Shiro，Spring Security ！</p>\n<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>\n<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>\n<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web  应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>\n<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security  框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP  等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control  List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>\n<h3 id=\"实战测试\"><a href=\"#实战测试\" class=\"headerlink\" title=\"实战测试\"></a>实战测试</h3><p>新建一个初始的springboot项目web模块，thymeleaf模块</p>\n<p>导入静态资源</p>\n<p>controller实现跳转 :</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.kuang.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\npublic class RouterController &#123;\n   @RequestMapping(&#123;&quot;&#x2F;&quot;,&quot;&#x2F;index&quot;&#125;)\n   public String index()&#123;\n       return &quot;index&quot;;\n  &#125;\n   @RequestMapping(&quot;&#x2F;toLogin&quot;)\n   public String toLogin()&#123;\n       return &quot;views&#x2F;login&quot;;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level1&#x2F;&#123;id&#125;&quot;)\n   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level1&#x2F;&quot;+id;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level2&#x2F;&#123;id&#125;&quot;)\n   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level2&#x2F;&quot;+id;\n  &#125;\n   @RequestMapping(&quot;&#x2F;level3&#x2F;&#123;id&#125;&quot;)\n   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;\n       return &quot;views&#x2F;level3&#x2F;&quot;+id;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"认识SpringSecurity\"><a href=\"#认识SpringSecurity\" class=\"headerlink\" title=\"认识SpringSecurity\"></a>认识SpringSecurity</h3><p>Spring Security  是针对Spring项目的安全框架，也是Spring  Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入  spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>\n<p>记住几个类：</p>\n<ul>\n<li>WebSecurityConfigurerAdapter：自定义Security策略</li>\n<li>AuthenticationManagerBuilder：自定义认证策略</li>\n<li><a href=\"https://github.com/EnableWebSecurity\">@EnableWebSecurity</a>：开启WebSecurity模式</li>\n</ul>\n<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>\n<p><strong>“认证”（Authentication）</strong></p>\n<p>身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。</p>\n<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>\n<p> <strong>“授权” （Authorization）</strong></p>\n<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>\n<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>\n<h3 id=\"认证和授权\"><a href=\"#认证和授权\" class=\"headerlink\" title=\"认证和授权\"></a>认证和授权</h3><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>\n<p>引入 Spring Security 模块</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>编写 Spring Security 配置类</p>\n<p>参考官网：<a href=\"https://spring.io/projects/spring-security\">https://spring.io/projects/spring-security</a> </p>\n<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>\n<p><a href=\"https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5\">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>  #servlet-applications 8.16.4</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425113500453.png\" alt=\"image-20230425113500453\"></p>\n<p>编写基础配置类</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.kuang.config;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n@EnableWebSecurity &#x2F;&#x2F; 开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    &#x2F;&#x2F;授权\n   @Override\n   protected void configure(HttpSecurity http) throws Exception &#123;\n  &#125;\n&#125;</code></pre>\n\n<p>定制请求的授权规则</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> &#x2F;&#x2F;授权\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n   &#x2F;&#x2F; 定制请求的授权规则\n   &#x2F;&#x2F; 首页所有人可以访问\n   http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()\n  .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n  .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n  .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n&#125;</code></pre>\n\n<p>测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>\n<p>在configure()方法中加入以下配置，开启自动配置的登录功能！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 开启自动配置的登录功能\n&#x2F;&#x2F; &#x2F;login 请求来到登录页\n&#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败\n&#x2F;&#x2F;没有权限默认到登陆页面，需要开启登陆页面\nhttp.formLogin();</code></pre>\n\n<p>测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>\n<p>查看刚才登录页的注释信息；</p>\n<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n   auth.inMemoryAuthentication()\n          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n&#125;</code></pre>\n\n<p>测试，我们可以使用这些账号登录进行测试！发现会报错！</p>\n<p>There is no PasswordEncoder mapped for the id “null”</p>\n<p>原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n   &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n   &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n   &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n   &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。\n   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n          .and()\n          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n&#125;</code></pre>\n\n<p>测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>\n<h3 id=\"完整配置代码\"><a href=\"#完整配置代码\" class=\"headerlink\" title=\"完整配置代码\"></a>完整配置代码</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.kuang.config;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n   &#x2F;&#x2F;定制请求的授权规则\n   @Override\n   protected void configure(HttpSecurity http) throws Exception &#123;\n       http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()\n      .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n      .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n      .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n       &#x2F;&#x2F;开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！\n           &#x2F;&#x2F; &#x2F;login 请求来到登录页\n           &#x2F;&#x2F; &#x2F;login?error 重定向到这里表示登录失败\n       http.formLogin()\n          .usernameParameter(&quot;username&quot;)\n          .passwordParameter(&quot;password&quot;)\n          .loginPage(&quot;&#x2F;toLogin&quot;)\n          .loginProcessingUrl(&quot;&#x2F;login&quot;); &#x2F;&#x2F; 登陆表单提交请求\n       &#x2F;&#x2F;开启自动配置的注销的功能\n           &#x2F;&#x2F; &#x2F;logout 注销请求\n           &#x2F;&#x2F; .logoutSuccessUrl(&quot;&#x2F;&quot;); 注销成功来到首页\n       http.csrf().disable();&#x2F;&#x2F;关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求\n       http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);\n       &#x2F;&#x2F;记住我\n       http.rememberMe().rememberMeParameter(&quot;remember&quot;);\n  &#125;\n   &#x2F;&#x2F;定义认证规则\n   @Override\n   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n       &#x2F;&#x2F;在内存中定义，也可以在jdbc中去拿....\n       &#x2F;&#x2F;Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n       &#x2F;&#x2F;要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n       &#x2F;&#x2F;spring security 官方推荐的是使用bcrypt加密方式。\n       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n              .and()\n              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n              .and()\n              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);\n  &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"Shiro\"><a href=\"#Shiro\" class=\"headerlink\" title=\"Shiro\"></a>Shiro</h2><h3 id=\"什么是Shiro\"><a href=\"#什么是Shiro\" class=\"headerlink\" title=\"什么是Shiro\"></a>什么是Shiro</h3><ul>\n<li>Apache Shiro是一个Java的安全（权限）框架。</li>\n<li>Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。</li>\n<li>Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。</li>\n<li>下载地址: <a href=\"http://shiro.apache.org/\">http://shiro.apache.org/</a></li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ul>\n<li>Authentication:身份认证、登录，验证用户是不是拥有相应的身份;</li>\n<li>Authorization: 授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如:验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!</li>\n<li>Session Manager:会话管理，即用户登录后就是第一次会话，在没有退出之前，它的所有信息都在会话中;会话可以是普通的JavaSE环境，也可以是Web环境;</li>\n<li>Cryptography:加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储;</li>\n<li>Web Support: Web支持，可以非常容易的集成到Web环境;</li>\n<li>Caching:缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，这样可以提高效率</li>\n<li>Concurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去</li>\n<li>Testing:提供测试支持;</li>\n<li>Run As:允许一个用户假装为另一个用户(如果他们允许）的身份进行访问;</li>\n<li>Remember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</li>\n</ul>\n<h3 id=\"三大核心组件\"><a href=\"#三大核心组件\" class=\"headerlink\" title=\"三大核心组件\"></a>三大核心组件</h3><p>Shiro有三大核心组件，即<strong>Subject、SecurityManager和Realm</strong></p>\n<p><strong>Subject</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为认证主体。应用代码直接交互的对象是Subject,Subject代表了当前的用户。包含Principals和Credentials两个信息。</p>\n<p>Pricipals:代表身份。可以是用户名、邮件、手机号码等等，用来标识一个登陆主题的身份。</p>\n<p>Credentials:代表凭证。常见的有密码、数字证书等等。</p>\n<p>也就是说两者代表了认证的内容，最常见就是用户名密码了。用Shiro进行身份认证，其中就包括主体认证。</p></blockquote>\n<p><strong>SecurityManager</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为安全管理员。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager, Subject相当于是一个门面，而SecurityManager才是真正的执行者。它负责与Shiro 的其他组件进行交互。</p></blockquote>\n<p><strong>Realm</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>是一个域。充当了Shiro与应用安全数据间的“桥梁”。</p>\n<p>Shiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能过进行，可以把Realm看成DataSource，即安全数据源。</p></blockquote>\n<h3 id=\"内部架构\"><a href=\"#内部架构\" class=\"headerlink\" title=\"内部架构\"></a>内部架构</h3><ul>\n<li>Subject: 主体，主体可以是任何可以与应用交互的“用户”</li>\n<li>SecurityManager: 是Shiro的核心，所有具体的交互都需通过SecurityManager进行，它管理所有的Subject，且负责进行认证授权，会话，及缓存的管理。</li>\n<li>Authenticator:负责主体认证。当用户尝试登录时，该逻辑被Authenticatior执行。Authenticator知道如何与一个或多个Realm协调来存储相关的用户。从Realm中获得的数据被用来验证用户的身份来保证用户确实是他们所说的他们是谁。</li>\n<li>Autentication Strategy:如果不止一个Realm被配置，其会协调这些Realm来决定身份认证尝试成功或失败下的条件（比如，如果一个Realm成功，而其他的失败，是否该尝试成功？）</li>\n<li>Authorizer:负责在应用程序中决定用户的访问控制。它是一种最终判定用户是否被允许做某事的机制。与Authenticator相似，Authorizer也知道如何协调多个后台数据源来访问角色恶化权限信息。Authorizer使用该信息来准确度的决定用户是否被允许执行给定的动作。</li>\n<li>SessionManager：知道如何去创建及管理用户Session生命周期来为所有环境下的用户提供一个强健的session体验。</li>\n<li>SessionDAO：代表SessionManager执行Session持久化操作。允许数据存储**入到会员管理的基础之中。</li>\n<li>CacheManager:创建并管理其他Shiro组件使用的Cache实例声明周期。因为Shiro能访问许多后台数据源，由于身份验证、授权和会话管理，缓存在框架中一直是一流 的架构功能，用来在通过还是使用这些数据源时提高性能。</li>\n<li>Cryptograhy：是对企业安全框架的一个自然的补充。密码模块，shrio提高了一些常见的加密组件用于密码加密，解密等。</li>\n</ul>\n<h3 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;\n    &lt;artifactid&gt;shiro-spring&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n<h2 id=\"Swagger\"><a href=\"#Swagger\" class=\"headerlink\" title=\"Swagger\"></a>Swagger</h2><h3 id=\"什么是Swagger\"><a href=\"#什么是Swagger\" class=\"headerlink\" title=\"什么是Swagger\"></a>什么是Swagger</h3><ul>\n<li>号称世界上最流行的API框架</li>\n<li>Restful Api 文档在线自动生成器 &#x3D;&gt; <strong>API 文档 与API 定义同步更新</strong></li>\n<li>直接运行，在线测试API</li>\n<li>支持多种语言 （如：Java，PHP等）</li>\n<li>官网：<a href=\"https://swagger.io/\">https://swagger.io/</a></li>\n</ul>\n<p><strong>前后端分离</strong></p>\n<ul>\n<li>前端 -&gt; 前端控制层、视图层</li>\n<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>\n<li>前后端通过API进行交互</li>\n<li>前后端相对独立且松耦合</li>\n</ul>\n<p><strong>产生的问题</strong></p>\n<ul>\n<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>\n</ul>\n<p><strong>解决方案</strong></p>\n<ul>\n<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>\n</ul>\n<h3 id=\"Springboot集成Swagger\"><a href=\"#Springboot集成Swagger\" class=\"headerlink\" title=\"Springboot集成Swagger\"></a>Springboot集成Swagger</h3><p>需要如下两个jar包</p>\n<ul>\n<li><strong>Springfox-swagger2</strong></li>\n<li>swagger-springmvc</li>\n</ul>\n<p>同时要求：jdk 1.8 + 否则swagger2无法运行</p>\n<p>步骤：</p>\n<p>1、新建一个SpringBoot-web项目</p>\n<p>2、添加Maven依赖</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>3、编写HelloController，测试确保运行成功！</p>\n<p>4、要使用Swagger，我们需要编写一个配置类 SwaggerConfig 来配置 Swagger</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Configuration &#x2F;&#x2F;配置类\n@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置\npublic class SwaggerConfig &#123;  \n&#125;</code></pre>\n\n<p>5、访问测试 ：<a href=\"http://localhost:8080/swagger-ui.html\">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114030387.png\" alt=\"image-20230425114030387\"></p>\n<h3 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>\n<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>\n<table>\n<thead>\n<tr>\n<th>Swagger注解</th>\n<th>简单说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://github.com/Api\">@Api</a>(tags &#x3D; “xxx模块说明”)</td>\n<td>作用在模块类上</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ApiOperation\">@ApiOperation</a>(“xxx接口说明”)</td>\n<td>作用在接口方法上</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ApiModel\">@ApiModel</a>(“xxxPOJO说明”)</td>\n<td>作用在模型类上：如VO、BO</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ApiModelProperty\">@ApiModelProperty</a>(value &#x3D; “xxx属性说明”,hidden &#x3D; true)</td>\n<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ApiParam\">@ApiParam</a>(“xxx参数说明”)</td>\n<td>作用在参数、方法和字段上，类似<a href=\"https://github.com/ApiModelProperty\">@ApiModelProperty</a></td>\n</tr>\n</tbody></table>\n<p>我们也可以给请求的接口配置一些注释</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@ApiOperation(&quot;xiao的接口&quot;)\n@PostMapping(&quot;&#x2F;xiao&quot;)\n@ResponseBody\npublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;\n   return username;\n&#125;</code></pre>\n\n<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>\n<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>\n<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><p>RPC【Remote Procedure  Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114416458.png\" alt=\"image-20230425114416458\"></p>\n<p><strong>步骤解析：</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/xiaokang111/BlogPicture@main/img/image-20230425114433842.png\" alt=\"image-20230425114433842\"></p>\n<p>RPC两个核心模块：通讯，序列化。</p>\n<p>序列化：数据传输需要转换</p>\n","text":"SpringBoot学习笔记SpringBoot官方文档：https://spring.io/projects/spring-boot 什么是SpringSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是...","link":"","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"Java框架","slug":"Java框架","count":8,"path":"api/tags/Java框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">SpringBoot学习笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot\"><span class=\"toc-text\">SpringBoot</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFSpring\"><span class=\"toc-text\">什么是Spring</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Spring%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96Java%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">Spring如何简化Java开发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFSpringBoot\"><span class=\"toc-text\">什么是SpringBoot</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SpringBoot%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">SpringBoot优点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">微服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">什么是微服务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">单体应用架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">微服务架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">如何构建微服务架构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">第一个SpringBoot项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80\"><span class=\"toc-text\">项目创建方式一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%BA%8C\"><span class=\"toc-text\">项目创建方式二</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pom-xml%E5%88%86%E6%9E%90\"><span class=\"toc-text\">pom.xml分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99http%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">编写http接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85\"><span class=\"toc-text\">将项目打成jar包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E9%A1%B9%E7%9B%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">更改项目端口号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E5%90%AF%E5%8A%A8%E6%97%B6banner%E5%9B%BE%E6%A1%88\"><span class=\"toc-text\">更改启动时banner图案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">SpringBoot运行原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">父依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E5%99%A8-spring-boot-starter\"><span class=\"toc-text\">启动器 spring-boot-starter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">主启动类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#spring-factories\"><span class=\"toc-text\">spring.factories</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringApplication\"><span class=\"toc-text\">SpringApplication</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#run%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">run方法流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yaml%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">yaml语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#yaml%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">yaml概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#yaml%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">yaml基础语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%99%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">给属性赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8D%A0%E4%BD%8D%E7%AC%A6\"><span class=\"toc-text\">配置文件占位符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A-1\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSR303%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">JSR303校验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%8E%AF%E5%A2%83%E8%A3%85%E9%85%8D\"><span class=\"toc-text\">多环境装配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">多配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#yaml%E7%9A%84%E5%A4%9A%E6%96%87%E6%A1%A3%E5%9D%97\"><span class=\"toc-text\">yaml的多文档块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">配置文件加载位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%EF%BC%8C%E8%BF%90%E7%BB%B4%E5%B0%8F%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">扩展，运维小技巧</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">自动配置原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">分析自动配置原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B2%BE%E9%AB%93\"><span class=\"toc-text\">精髓</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot-Web%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">SpringBoot Web开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">要解决的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86\"><span class=\"toc-text\">静态资源处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-webjars%E6%96%B9%E5%BC%8F%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">1.webjars方式引入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2.静态资源映射规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">3.自定义静态资源路径</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A6%96%E9%A1%B5%E5%92%8C%E5%9B%BE%E6%A0%87%E5%AE%9A%E5%88%B6\"><span class=\"toc-text\">首页和图标定制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87\"><span class=\"toc-text\">网站图标</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">thymeleaf模板引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5Thymeleaf\"><span class=\"toc-text\">引入Thymeleaf</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Thymeleaf%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Thymeleaf分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Thymeleaf%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0\"><span class=\"toc-text\">Thymeleaf语法学习</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">提取公共页面</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A5%E6%9C%9F%E8%BD%AC%E4%B9%89\"><span class=\"toc-text\">日期转义</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVC%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">MVC配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringBoot-Web%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">SpringBoot Web项目练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">登录实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">登录拦截器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%95%E7%A4%BA%E5%91%98%E5%B7%A5%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">展示员工列表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E5%91%98%E5%B7%A5\"><span class=\"toc-text\">添加员工</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#404%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">404错误页面</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88JDBC\"><span class=\"toc-text\">整合JDBC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SpringDate\"><span class=\"toc-text\">SpringDate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88JDBC-1\"><span class=\"toc-text\">整合JDBC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDBC-Template\"><span class=\"toc-text\">JDBC Template</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88Druid%E6%95%B0%E6%8D%AE%E6%BA%90\"><span class=\"toc-text\">整合Druid数据源</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90\"><span class=\"toc-text\">配置数据源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88Mybatis\"><span class=\"toc-text\">整合Mybatis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">整合测试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SpringSecurity-%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">SpringSecurity(安全)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">实战测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A4%E8%AF%86SpringSecurity\"><span class=\"toc-text\">认识SpringSecurity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83\"><span class=\"toc-text\">认证和授权</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整配置代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Shiro\"><span class=\"toc-text\">Shiro</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFShiro\"><span class=\"toc-text\">什么是Shiro</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">三大核心组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">内部架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">依赖</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Swagger\"><span class=\"toc-text\">Swagger</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFSwagger\"><span class=\"toc-text\">什么是Swagger</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Springboot%E9%9B%86%E6%88%90Swagger\"><span class=\"toc-text\">Springboot集成Swagger</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">常用注解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RPC\"><span class=\"toc-text\">RPC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">基本原理</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SpringMVC","uid":"cd53cdbf97b8f99c953dd3eda45eed25","slug":"学习笔记/SpringMVC","date":"2022-12-05T08:00:50.000Z","updated":"2023-02-11T05:58:06.217Z","comments":true,"path":"api/articles/学习笔记/SpringMVC.json","keywords":null,"cover":"https://img1.baidu.com/it/u=68948553,1079424840&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800","text":"SpringMVC ","link":"","photos":[],"count_time":{"symbolsCount":10,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java框架","slug":"Java框架","count":8,"path":"api/tags/Java框架.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"操作系统","uid":"8c6c59136f9c0c8c29b87ea646eed9d1","slug":"学习笔记/操作系统","date":"2022-12-05T08:00:50.000Z","updated":"2023-02-11T06:00:56.457Z","comments":true,"path":"api/articles/学习笔记/操作系统.json","keywords":null,"cover":"https://img0.baidu.com/it/u=1295759570,254939844&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500","text":"操作系统 ","link":"","photos":[],"count_time":{"symbolsCount":5,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":3,"path":"api/tags/计算机基础.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}